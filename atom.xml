<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JimmyXu的小站</title>
  
  <subtitle>inner peace</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xujimmy.com/"/>
  <updated>2020-08-18T08:51:51.643Z</updated>
  <id>http://xujimmy.com/</id>
  
  <author>
    <name>jimmyxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟内存简介</title>
    <link href="http://xujimmy.com//2020/07/12/introduction-virtual-memory.html"/>
    <id>http://xujimmy.com//2020/07/12/introduction-virtual-memory.html</id>
    <published>2020-07-12T01:14:35.000Z</published>
    <updated>2020-08-18T08:51:51.643Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟内存是计算机领域中一个很重要的概念，不管是对于日常工作排查问题，还是技术面试，出现的频率都很高。之前对这块内容的理解一直只存在于头脑里，现在把它拿出来，形成书面记录。<br><a id="more"></a></p><blockquote><p>需要说明下，虚拟内存有两种理解：一种是操作系统把硬盘的一部分当内存使用，以达到扩大内存的目的，大学或者很多入门级电脑书籍里都这么说，这其实是不全面的，或者只是表象。另一种理解是计算机系统中对物理内存的一种抽象，这种理解更底层，更深层次，或者说本质的东西，本文介绍的是第二种。</p></blockquote><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>我们知道，冯·诺依曼结构的计算机中，任何一个程序想要运行，必须首先加载进内存，计算机的内存可以看成是一个连续的线性空间，同数组一样，也有下标，称之为内存地址，或物理地址。内存地址从 0 到 $N$，表示系统可以寻址的范围，例如，一个 4GB 的内存，内存地址范围为 $[0-2^{32}]$，也把这个范围称之为地址空间。程序只有加载到内存中，才能被 CPU 执行，如下图是一个简易的内存示例，每个格子代表一个内存地址，有 A、B 两个程序被加载到内存，A 占用了 [0-7] 这段内存区域，B 占用了 [17-28] 这段内存区域。其他空白的区域，可以被其他程序所使用。<br><img src="/images/virtual-memory/1.png" alt=""></p><h2 id="没有虚拟内存的年代"><a href="#没有虚拟内存的年代" class="headerlink" title="没有虚拟内存的年代"></a>没有虚拟内存的年代</h2><p>早期的计算机系统，程序可以直接访问整个内存，就如上图所示，程序员必须清楚的知道如何使用和管理主存，这是一个很麻烦的工作，程序员得确保他的程序在加载时，不能超过可用内存。当计算机发展成多任务系统时，即加载多个程序到内存，他们必须考虑以下问题：</p><ul><li>内存布局：多个程序如何共享主存的内存空间？例如上图， A，B 两个程序，如何保证它们在内存能“和平共存”？程序员必须知道 A 占用了哪些内存地址，B 占用了哪些内存地址，避免它们地址冲突、覆盖的情况。</li><li>内存碎片：随着多个程序的加载，内存开始出现一些碎片，如上图，A，B 两个程序中间的地址是空的，假如 [10-15] 这段内存又加载了一个程序 C，那么 [8-9]，[16] 地址剩下来，现在程序 D 想要一段大小为 5 的内存，但已经没有合适的地址分配给它了。这样 [8-9], [16] 就成了内存碎片。随着内存变大，程序加载数增多，碎片也变得越来越多，这是内存的极大浪费。</li><li>安全：由于程序可以访问整个内存空间，A 程序会不会有意或者无意读取 B 程序的数据？例如密码等一些敏感的信息？无论如何，这都是无法容忍的。</li></ul><p>可以看到，早期编程是很痛苦的，假想下，如果有一个自动的内存分配和管理机制，让程序员不用操心内存布局、碎片、安全等问题，那一定是极好的。于是，虚拟内存应运而生。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>在虚拟内存体系下，一个进程不能直接访问物理内存，而只能访问虚拟内存，它看到的是一个被称为虚拟地址空间的东西，进程只和虚拟地址打交道，然后由操作系统和硬件通过某种方式把虚拟地址转为实际的物理地址。这样，进程只需读写虚拟内存地址即可，根本不用管从虚拟地址到物理地址的转换，如下图所示。注意到，进程 2 使用的物理内存实际可以是不连续的。<br><img src="/images/virtual-memory/2.png" alt=""></p><h2 id="虚拟内存的好处"><a href="#虚拟内存的好处" class="headerlink" title="虚拟内存的好处"></a>虚拟内存的好处</h2><p>从上图的例子中，可以得出虚拟内存至少有以下好处：</p><ul><li>每个程序都有一个从 0 开始的，独立的虚拟地址空间，这样程序员就不用处理内存偏移这些琐碎的事情了，极大降低了编程的工作难度。</li><li>虚拟内存总是连续的，尽管实际映射的物理内存可能不连续。操作系统会把底层那些可用的、碎片化的内存整合成一个统一的虚拟内存地址，这就充分利用了碎片化的物理内存。</li><li>每个程序看到的虚拟地址空间大小是一致的，近似于无限，这样程序员就不用担心自己的程序太大而无法加载进内存。</li><li>虚拟内存保证了安全性，程序 A 和程序 B 的虚拟地址空间是独立的，它们无法访问到对方的地址，即使通过某种恶意手段访问到，也能被操作系统检测到并触发异常。同时，进程对自己虚拟地址空间的操作也不是为所欲为，如果对一个只读的地址写操作，也会引发操作系统异常，极大的保证了内存读写的安全性。</li></ul><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>上面我们也说到，虚拟地址最终会转换成物理地址，即给定一个虚拟地址 X，系统能把他转换成物理地址 Y。因此系统得保存虚拟地址到物理地址的映射关系。很容易想到维护一个 1 : 1 的映射表，即虚拟地址和物理地址一一对应，然而实际不可行，保存这样的一个映射表这需要占用大量的存储空间。</p><p>解决办法是通过把虚拟内存和物理内存分成连续、固定大小的块。虚拟内存中，我们把块称之为<strong>虚拟页（Virtual Page）</strong>，物理内存中，我们把块称之为<strong>物理页（Physical Page，有的地方也称之为帧，Frame）</strong>。绝大部分情况下，页的大小是 4KB，寻址时，以页为单位进行操作。同时，处理器上有个称为 <strong>MMU（Memory Management Unit）</strong>的部件，它的功能是将虚拟地址转换为物理地址，虚拟页和物理页间的映射关系保存在一个被称为<strong>页表</strong>的数据结构中，每个进程都有自己的页表，页表存放在内存，由操作系统管理。下图展示了这种映射关系，虚拟内存和物理内存中每个格子表示一个页。当应用程序读写一个虚拟地址时，MMU 会计算它的虚拟页索引，并在页表中找这个虚拟页对应的物理页，一旦找到，就返回给应用程序，这样就完成了一次实际的内存读写。<br><img src="/images/virtual-memory/3.png" alt=""></p><h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>上图 3 中，可以看到有的虚拟页并没有映射到物理页（编号6、7的虚拟页），当应用程序访问这种还没有映射的页时，找不到对应的物理页，这种情况被称为<strong>缺页（Page Missing）</strong>，缺页就会触发一个<strong>缺页异常（Page Fault）</strong>，MMU 会检测到缺页异常，并把控制权交给操作系统，操作系统会执行缺页异常处理程序，它会尽可能为这个虚拟页映射一个可用的物理页，如果找不到，就牺牲一个已经映射的物理页，把它回写到硬盘，然后把该页映射到新的虚拟页。当缺页异常处理程序返回时，它会重新执行导致缺页的指令，该指令把导致缺页的虚拟地址重新发给 MMU，由于现在页表已经有了映射关系，因此不会再引发缺页了。</p><h3 id="页面调度"><a href="#页面调度" class="headerlink" title="页面调度"></a>页面调度</h3><p>上述的这种在硬盘和内存交换页的行为，称为页面调度（Paging），或者页交换（Swapping）。页面调度有可能发生在缺页异常时，也可能发生在其他场景。由于内存总是稀缺资源，当一个应用程序暂时不活动，或者某些映射的物理页暂时未使用到，操作系统会把它先保存到硬盘里，等需要的时候，再从硬盘换到内存。这实际就提供了一种“部分加载”或“懒加载”的机制——直到应用需要某些数据时，才从硬盘中加载，否则先不加载。</p><p>页面调度对应用程序是透明的，应用程序不用考虑内存是否足够能加载它，正因为如此，在应用程序看来，内存是无限的，所以，在一个 4G 内存的机器上，可以运行需要 5G 或更多内存的程序。</p><p>但凡事都有两面性，换页也有负面作用。我们知道硬盘的速度远慢于内存(<a href="https://xujimmy.com/2019/09/29/computer-memory.html">10 万倍的数量级差距</a>)。因此换页时，操作系统把数据从硬盘拷贝到内存是一个很耗时的工作，表现就是“电脑突然卡了下”。当系统运行的程序过多，缺页异常频繁发生，系统不停的进行页面调度工作，换页操作花费的时间甚至比运行程序本身还要多，这时系统表现就是卡顿，这种情况称为<strong>系统颠簸（Thrashing）</strong>。处理方式就是对症下药：要么加大内存，或者关掉一些程序。</p><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>虚拟内存机制也很好的解决了进程的安全问题，有了 MMU 和页表，通过给页表加一些标志，可以实现一个进程只能访问属于它自己的虚拟内存，以及控制页的读写权限。任何试图访问一个不属于进程自己的的内存地址，或者对一个只读的内存地址进行写操作，都会被操作系统检测到，并抛出一个错误，Unix 系统中叫<strong>段错误（Segmentation Fault）</strong>，Windows 系统中叫<strong>非法访问（Access Violation）</strong>，通常此时操作系统会中止或杀掉进程。</p><p>虚拟内存还有很多其他的使用方式，例如内存映射文件。读写一个文件时，一般我们会通过 read/write 等系统调用的方式，把文件拷贝到内存。但如果使用内存映射的方式，可以省掉拷贝的操作，直接访问文件，就好像它已经被加载到了内存。当真正需要读写时，虚拟内存会保证把必要的数据从硬盘搬到内存，这种方式可以显著提高文件访问效率。</p><p>例如还有共享物理内存，当多个进程需要使用某个数据时，可以在物理内存中只放一份，然后在把各自的虚拟页指向它，这样就能达到共享内存的目的。典型的如 fork 系统调用创建子进程，实际就只是复制了一份父进程的页表，再配合写时复制机制，因此效率是很高的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟内存是对内存的一种抽象，使用虚拟内存时，CPU 寻址方式是虚拟寻址，即将虚拟地址转换为物理地址，这需要 MMU 硬件和操作系统的密切配合完成。虚拟内存系统简化了内存管理、链接、加载、代码和数据的共享以及访问权限的保护，是计算机系统中最重要的概念之一。理解了虚拟内存原理，可以帮助我们写出安全、高效的程序，对排查系统问题也大有裨益。也就理解了“把一部分硬盘当内存使用”只是操作系统实现虚拟内存的一个方式而已。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.internalpointers.com/post/introduction-virtual-memory" target="_blank" rel="noopener">https://www.internalpointers.com/post/introduction-virtual-memory</a></li><li><a href="https://en.wikipedia.org/wiki/Virtual_memory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Virtual_memory</a></li><li>《深入理解计算机系统》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟内存是计算机领域中一个很重要的概念，不管是对于日常工作排查问题，还是技术面试，出现的频率都很高。之前对这块内容的理解一直只存在于头脑里，现在把它拿出来，形成书面记录。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="操作系统" scheme="http://xujimmy.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="虚拟内存" scheme="http://xujimmy.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>由病毒检测想到的一种面试题</title>
    <link href="http://xujimmy.com//2020/05/22/poison-detect.html"/>
    <id>http://xujimmy.com//2020/05/22/poison-detect.html</id>
    <published>2020-05-22T01:56:40.000Z</published>
    <updated>2020-06-24T07:57:26.118Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一个新闻，武汉开展全城新冠病毒核酸检测，要在 10 天内检测全市 1000 多万人中病毒携带者，这无疑是一个巨大的工程。这里我不打算深究医护人员是采用什么方式完成这项任务，主要想从这个检测事例中，引出一个有意思、又很有实践意义的问题：有 N 瓶无色无味液体（N 可能很大，如 100，1000，10000 等），其中混入了一瓶有毒液体，同时也有试剂，可以检测液体的毒性，如果试剂滴入到有毒液体中，液体变蓝，否则不变色，除此之外，不能通过其他方式检测。问题来了，如何用最少的检测次数，找到这瓶有毒液体。</p><a id="more"></a><p>这是一类问题，网上也能找到很多类似变种，如用小白鼠检测毒药，但本质都是一样的。回到上述这个问题，最直观的办法，当然是一瓶一瓶的检测，最坏的情况下，需要 N -1 次才能找到有毒的那瓶，有没其他更快的办法呢？学计算机的都知道二分查找，又叫折半查找，但这个问题条件不具备有序性，是没法用二分查找的。</p><p>我们不妨把问题简化下，假如 N=2，即在 2 瓶液体中找到有毒的那瓶，这就简单了，随便把试剂滴入一瓶液体中，如果这瓶液体变蓝，则找到，有毒的就是这瓶，如果没变蓝，那有毒的就是另一瓶。所以，N=2 时，检测一次，可以确认有毒液体。<br>把 N 加大点，当 N=4 时，如何快速找到有毒的那瓶呢？可以这样，把 4 瓶液体均分为 A，B 两组，将每组的两瓶液体取少量混合放入新瓶，这样会得到两瓶混合液体，用试剂检测这两瓶混合液体，问题又变成上面 N=2 的情况了，假如 A 组的混合液体变蓝，说明有毒液体是 A 组两瓶液体中的一瓶，再检测一次，可以确定有毒液体；假如 A 组的混合液体没变蓝，那有毒液体是 B 组两瓶液体中的一瓶，再检测一次，同样可以确定有毒液体。用这种方式，N=4时，检测两次，就可以确认有毒液体。<br>当 N=8 时，我们同样先分为 A，B 两组，将每组的 4 瓶液体取少量混合，用试剂检测两瓶混合液体，假如 A 组的混合液体变蓝，说明有毒液体是 A 组 4 瓶液体中的一瓶，问题回到 N=4 的情况了，再测两次，即可确认有毒液体。<br>所以，当 N=8 时，共检测 3 次，可以确认有毒液体。<br>那么，当 N=16 时，共需要检测 4 次，可以确认有毒液体。这比一瓶一瓶的检测快多了。那么，假如 N 不等于 2、4、8、16 这种 2 的 n 次幂时，怎么办呢？其实是一样的，例如 N=7，还是可以先分两组，一组 4 瓶，一组 3 瓶，后面的流程类似。于是，我们可以得到一个一般性结论：<strong>当有 $N$ 瓶液体，一瓶有毒，则只需要 $\log_2{N}$ 次检测，即可确定有毒液体。或者说，如果有 $k$ 次检测机会，那么最多可以确定 $2^k$ 瓶液体中混入的那瓶有毒液体</strong>。</p><p>这种方式，有点类似于“折半查找”，每检测一次，可以排除一半的数据集，把问题规模缩小一半。但注意，这绝对不是二分查找，或者折半查找。其实用计算机体系里的观点来看，这种问题被称为二进制问题。我们考察下上面，当 N=8 时的情况，把这 8 瓶液体按二进制编号。从 000 到 111，为了方便叙述，也把各瓶标上号，如下图。<br><img src="/images/virus-detect/pic-1.png" alt=""><br>然后，按每一个二进制位是否是 1 来采样混合液体，例如，E、F、G、H 可以取少量组成混合液体，因为他们的第 3 位二进制位是 1，同理 B、D、F、H 可以取少量组成混合液体，C、D、G、H 可以取少量组成混合液体。这样，我们有了 3 瓶混合液体，编号为 1、2、3，用试剂分别检测这 3 瓶混合液体，就可以确定有毒的那瓶液体的二进制编号。比如，如果 1 号变蓝，说明有毒液体肯定在 E、F、G、H 中的一个，即有毒液体那瓶的第 3 位二进制位为 1，如果 2 号变蓝，则说明有毒液体肯定在 C、D、G、H 中的一个，即有毒液体那瓶的第 2 位二进制位为 1，如果 3 号瓶没变蓝，则说明有毒液体不在 B、D、F、H 中，即有毒液体那瓶的第 1 位二进制位为 0。于是，有毒液体的那瓶二进制编号是 110，即 G 是有毒的。于是，我们检测了 3 次，最终确定了要找的那瓶有毒液体。</p><p>那么，如果有 100 瓶，则需要 7 位二进制编码，检测 7 次，即可知道有毒液体的那瓶二进制编码。</p><p>这种方法科学而高效，考察的是对二进制的理解和使用，在面试中也经常出现，这里总结了下一般思路。可能有同学已经知道用二进制方法，但真到面试时，却不知道怎么运用，给别人讲明白。还有的同学陷入一个思维误区，一上来，看到是查找问题，想当然的就套用二分查找，这也是很多人会犯的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到一个新闻，武汉开展全城新冠病毒核酸检测，要在 10 天内检测全市 1000 多万人中病毒携带者，这无疑是一个巨大的工程。这里我不打算深究医护人员是采用什么方式完成这项任务，主要想从这个检测事例中，引出一个有意思、又很有实践意义的问题：有 N 瓶无色无味液体（N 可能很大，如 100，1000，10000 等），其中混入了一瓶有毒液体，同时也有试剂，可以检测液体的毒性，如果试剂滴入到有毒液体中，液体变蓝，否则不变色，除此之外，不能通过其他方式检测。问题来了，如何用最少的检测次数，找到这瓶有毒液体。&lt;/p&gt;
    
    </summary>
    
      <category term="Math" scheme="http://xujimmy.com/categories/Math/"/>
    
    
      <category term="math" scheme="http://xujimmy.com/tags/math/"/>
    
      <category term="二进制" scheme="http://xujimmy.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用 protobuf</title>
    <link href="http://xujimmy.com//2019/12/11/use-proto.html"/>
    <id>http://xujimmy.com//2019/12/11/use-proto.html</id>
    <published>2019-12-11T08:12:40.000Z</published>
    <updated>2020-06-24T08:27:43.309Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发过程中，通常会使用 http 方式调用别人的接口获取数据，json 是一种流行且易读的数据交换格式，因此在调接口时，大家都习惯用这种格式。但对于微服务来说，或者对于高性能的 rpc 请求，http 和 json 实际还是有点过重，具体体现在，http 协议规定了在传输数据时，必须要有请求头，请求行，请求体。而 protobuf 格式的数据，可以很好解决这个问题。它对传输的数据做了很好的编码和压缩，虽然不易阅读，但传输的体积和效率，比 json 或 xml 好很多。与 protobuf 类似的，还有 thrift。虽然使用上有差别，但目的都是类似：高性能的序列化框架。本文记录下如何使用 proto 格式处理数据，或者称为消息。</p><a id="more"></a><blockquote><p>注：本文的 protobuf 示例使用的语言是 C++，protobuf 版本是 proto2。</p></blockquote><p>首先，我们都要写一个 proto 的文件，用来描述接口的字段以及类型，假定文件名叫 user.proto，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package user</span><br><span class="line"></span><br><span class="line">message User</span><br><span class="line">&#123;</span><br><span class="line">message Addr </span><br><span class="line">&#123;</span><br><span class="line">optional string province = 1;</span><br><span class="line">optional string city = 2;</span><br><span class="line">optional string road = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Gender</span><br><span class="line">&#123;</span><br><span class="line">MALE = 0;</span><br><span class="line">FEMALE = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Phone</span><br><span class="line">&#123;</span><br><span class="line">enum Type</span><br><span class="line">&#123;</span><br><span class="line">HOME = 0;</span><br><span class="line">COMPANY = 1;</span><br><span class="line">&#125;</span><br><span class="line">optional Type type = 1 [default = HOME];</span><br><span class="line">optional string no = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">optional string name = 1;</span><br><span class="line">optional Gender gender = 2;</span><br><span class="line">optional uint32 age = 3;</span><br><span class="line">repeated Phone phone = 4;</span><br><span class="line">optional Addr address = 5;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是 user.proto 的定义，有几点值得注意：</p><ul><li>每个 proto 都要声明 package，以表明本 proto 的作用域，类似于 java 中的 package。</li><li>如果使用的 proto 版本是 v3，则文件第一行得写<code>syntax = &quot;proto3&quot;</code>，如果是 v2 版本，则可以省略。</li><li>message 是 proto 中最基本的关键字，写 message 就如同定义一个类一样，有各种字段，以及字段的类型，常用的基本类型有 uint32，uint64，string，message 也可以嵌套定义，因此也有复合类型，如上面的 Addr，就是复合类型。</li><li>每个字段都有序号，序号是 protobuf 在序列化和反序列时用来做标识，对于使用者来说不用过多关注，同时序号没有特别要求，可以调换字段位置，序号也可以不连续，但序号不能重复，序号最大 2^29-1，不过一般也不会定义这么大的序号。</li><li>字段可以有默认值，如上面的 Phone Message 中的 type 字段。</li></ul><p><strong>写好 proto 文件，就相当于写了一份类的说明书</strong>，可以使用 protobuf 提供的编译器生成相应的类和 api，如果已经下好了 protobuf，可以执行下面语句。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=<span class="variable">$SRC_DIR</span> --cpp_out=<span class="variable">$DST_DIR</span> <span class="variable">$SRC_DIR</span>/user.proto</span><br></pre></td></tr></table></figure></p><p>其中，SRC_DIR 是 user.proto 所在的目录，DST_DIR 是生成文件所在的目录，执行完后，DST_DIR 下会多了几个文件：<code>user.ph.h</code> 和 <code>user.ph.cc</code> ，打开文件，会发现是 User 类的定义，以及各种 api 方法。使用起来也很方便，下面是各种字段类型的读写操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.ph.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line">user::User admin;</span><br><span class="line">admin.set_name(<span class="string">"jim"</span>);</span><br><span class="line">admin.set_gender(user::User::Gender::MALE);</span><br><span class="line">admin.set_age(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">auto</span> phone = admin.mutable_phone()-&gt;Add();</span><br><span class="line">phone-&gt;set_type(user::User::Phone::Type::COMPANY);</span><br><span class="line">phone-&gt;set_no(<span class="string">"13599999"</span>);</span><br><span class="line"><span class="keyword">auto</span> addr = admin.mutable_address();</span><br><span class="line">addr-&gt;set_province();</span><br><span class="line">addr-&gt;set_city();</span><br><span class="line">addr-&gt;set_road();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 admin 填充完毕，可以进行序列化存到文件，或者 rpc 传输，这里省略</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作</span></span><br><span class="line"><span class="built_in">string</span> name = admin.name();</span><br><span class="line"><span class="keyword">if</span> (admin.has_age()) &#123;</span><br><span class="line">int32 age = admin.age();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> gender = admin.gender();</span><br><span class="line"><span class="keyword">if</span> (gender == user::User::Gender::MALE) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; item : admin.phone()) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = item.type();</span><br><span class="line"><span class="keyword">auto</span> n = item.no();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> province = admin.address().province();</span><br><span class="line"><span class="built_in">string</span> city = admin.address().city();</span><br><span class="line"><span class="built_in">string</span> road = admin.address().road();</span><br><span class="line"></span><br><span class="line">user::User admin2;</span><br><span class="line">admin2.CopyFrom(admin);</span><br></pre></td></tr></table></figure><p>上面就是对 User 类的读写操作，总结以下几点：</p><ul><li>对于基本数据类型的字段，如 string，int32，写就是 set_xxx，读就是调用与字段名相同的方法（在这点上我感觉有些别扭，为何写是 set，读不用 get 统一下？是为了保持和 C++ 的风格一致？）。</li><li>要检查字段是否赋值，使用 has_xxx 方法。而如果字段是 repeated，就不能简单的使用 has_xxx，而要使用 xxx.size() 是否大于 0 来判断。</li><li>对于复合类型的字段读写稍微麻烦点，写操作基本都是调用 mutable_xxx，获取相应的指针，然后对指针进行逐一赋值。读操作稍微简单，链式调用方法即可。</li><li><p>对于 repeated 类型，可以使用 for 循环读取，赋值时，可以使用 for 循环赋值，也可以使用标准库中的 transform 来赋值，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(phone_list.begin(), phone_list.end(), google::protobuf::RepeatedFieldBackInserter(admin.mutable_phone()), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; phone) &#123; </span><br><span class="line">user::User::Phone p;</span><br><span class="line">p.set_type(phone.type());</span><br><span class="line">p.set_no(phone.no());</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;);</span><br><span class="line">其中，phone_list 是类似于 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;user::User::Phone&gt; 的列表。</span><br></pre></td></tr></table></figure></li><li><p>如果使用了 C++11，对于复合类型，尽量使用 auto 来定义接收值，可以简化不少。</p></li><li>可以使用 CopyFrom 对一个对象赋值，避免字段的逐一赋值。</li></ul><p>以上就是对 protobuf 的一些使用总结，如果你使用的是其他语言，如 java, python，也可以使用 proto 工具生成对应的类和 api，读写方式也基本类似。</p><p>总结：</p><ul><li>与 json 类似，protobuf 也是网络传输的一种方式，不同的是，它有自己的格式，这种格式不像 json 那么直观，但却相当紧凑，可以大幅度提高信息传递的效率。</li><li>由于 protobuf 有自己的编码方式，但我们不用关心它是怎么编码，只需要使用它提供的编译器，自动生成 get/set 代码，直接对消息进行读写即可，极大提高了生产力。</li><li>protobuf 有详细友好的官方文档，而且也不难读，基本所有的问题都能在官方文档里找到答案。</li><li>protobuf 不是自我描述的，不像 json，xml，你拿到相应的内容，就能直观的看到每个字段以及值，protobuf 是以二进制方式存储和传输，无法直接读出任何内容，而只能通过 proto 文件，生成相应的 api，通过 api 才能正确读取。这点既是优点，使数据具有一定的 “加密性”，也是缺点，数据可读性极差。<strong>所以 protobuf 非常适合内部服务之间 RPC 调用和传递数据</strong>。目前大厂内部各服务间的调用，很多都是构建在 protobuf 上的。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/tutorials</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在软件开发过程中，通常会使用 http 方式调用别人的接口获取数据，json 是一种流行且易读的数据交换格式，因此在调接口时，大家都习惯用这种格式。但对于微服务来说，或者对于高性能的 rpc 请求，http 和 json 实际还是有点过重，具体体现在，http 协议规定了在传输数据时，必须要有请求头，请求行，请求体。而 protobuf 格式的数据，可以很好解决这个问题。它对传输的数据做了很好的编码和压缩，虽然不易阅读，但传输的体积和效率，比 json 或 xml 好很多。与 protobuf 类似的，还有 thrift。虽然使用上有差别，但目的都是类似：高性能的序列化框架。本文记录下如何使用 proto 格式处理数据，或者称为消息。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="protobuf" scheme="http://xujimmy.com/tags/protobuf/"/>
    
      <category term="rpc" scheme="http://xujimmy.com/tags/rpc/"/>
    
      <category term="C++" scheme="http://xujimmy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>程序员需要知道的数量级</title>
    <link href="http://xujimmy.com//2019/09/29/computer-memory.html"/>
    <id>http://xujimmy.com//2019/09/29/computer-memory.html</id>
    <published>2019-09-29T08:12:40.000Z</published>
    <updated>2019-11-08T08:55:08.650Z</updated>
    
    <content type="html"><![CDATA[<p>看书的时候，遇到这么一个表，我觉得非常有用，特此记录下。<br><a id="more"></a></p><p>下表展示了一个 3.3GHz 的 CPU，访问各存储设备的耗时，以及等比放大后的相对时间。</p><table><thead><tr><th>事件</th><th>延时</th><th>相对时间比例</th></tr></thead><tbody><tr><td>1个 CPU 周期</td><td>0.3 ns</td><td>1 s</td></tr><tr><td>L1 缓存访问</td><td>0.9 ns</td><td>3 s</td></tr><tr><td>L2 缓存访问</td><td>2.8 ns</td><td>9 s</td></tr><tr><td>L3 缓存访问</td><td>12.9 ns</td><td>43 s </td></tr><tr><td>主存访问</td><td>120 ns</td><td>6 分</td></tr><tr><td>固态硬盘（SSD）</td><td>50-150 us</td><td>2-6 天</td></tr><tr><td>旋转磁盘</td><td>1-10 ms</td><td>1-12 月</td></tr><tr><td>网络：从北京上海</td><td>30 ms</td><td>3 年</td></tr><tr><td>网络：从北京到旧金山</td><td>190 ms</td><td>19 年</td></tr><tr><td>TCP 重传</td><td>1-3 s</td><td>105-317 年</td></tr></tbody></table><p>从上面这张表，我们可以得到什么启示？我认为至少有以下几点：</p><ul><li>各存储器的访问时延，比我们想象中的要大，看似纳秒和微秒都很快，但实际上相差巨大，一次磁盘 IO 的时延，CPU 可以执行十万百万条指令。</li><li>各存储器访问的数量级，比如 SSD 访问在微秒(us)级别，而普通磁盘访问在毫秒(ms)级别</li><li>数据越“靠近” CPU，访问更快，但存储设备也越贵，存储容量也越小。如旋转磁盘现在 TB 级别很常见，而主存还基本是 GB 级别，L1~L3 缓存只有 KB 级别。这是一个速度和成本的博弈，如果想追求速度，钱不是问题，那么请用更好的 CPU，更大的内存，而不是更大的磁盘；反之，如果钱很紧张，数据访问的频次低，那么可以降低内存，而换上更大的硬盘。</li><li>所有的性能问题，都可以从四个方面优化：CPU，内存，IO，网络。且收益依次增高，如减少一次网络调用带来的收益，要比减少一次磁盘访问带来的收益更大更明显</li></ul><p>上面这个表，也印证了一句经典的话：<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>。L1~L3 缓存是 CPU 和内存之间的中间层，而内存又是磁盘和 CPU 缓存之间的中间层</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看书的时候，遇到这么一个表，我觉得非常有用，特此记录下。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="CPU" scheme="http://xujimmy.com/tags/CPU/"/>
    
      <category term="缓存" scheme="http://xujimmy.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="计算机系统" scheme="http://xujimmy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>云计算中的资源调度</title>
    <link href="http://xujimmy.com//2019/08/11/schedule-in-cloud.html"/>
    <id>http://xujimmy.com//2019/08/11/schedule-in-cloud.html</id>
    <published>2019-08-11T08:12:40.000Z</published>
    <updated>2019-11-08T08:55:08.650Z</updated>
    
    <content type="html"><![CDATA[<p>云厂商将机房中服务器的计算能力进行整合，如 CPU、内存等，并把这些硬件统一抽象为资源，然后按需卖给用户，这就是云计算理念，怎么把这些资源有效的管理和调度起来，最大化资源利用率，关系着云厂商的成本和营收，也是各厂商实现差异化的一个重要切入点。本文讲讲云计算中的资源调度，或者称为 scheduler。<br><a id="more"></a></p><p>openstack 中，有个叫做 nova-scheduler 的模块，类似于 k8s 中的 scheduler 组件，这两个模块就是资源调度，功能类似，是我们讨论的主角。要说明的是，本文并不打算拿源码逐行分析，而只是阐述资源调度里的一些核心思想。</p><h2 id="什么是资源调度"><a href="#什么是资源调度" class="headerlink" title="什么是资源调度"></a>什么是资源调度</h2><p><strong>资源调度要解决的核心问题是，用户创建的 VM 或 pod 应该分配到集群的哪个节点上</strong>。以及当某个节点负载超过报警阈值时，自动将 VM 或 pod 调度到其他负载较低的节点，以达到整个集群中所有节点的 CPU，内存，I/O 等指标保持大致相当的水平，类似于负载均衡。毫无疑问，这样做一方面提高集群的资源利用率，另一方面降低个别节点负载过高导致 VM 或 pod 性能跟着受影响。为了方便，下文只用 VM 代表被调度对象。</p><h2 id="怎么做资源调度"><a href="#怎么做资源调度" class="headerlink" title="怎么做资源调度"></a>怎么做资源调度</h2><p>资源调度的过程就是一个筛选最优解的过程，这里的解指的是集群中最优的节点。为了找到最优解，显然需要知道节点有哪些过滤条件，影响因子，以及各影响因子的权重。只要找到这些因素，我们就可以对各节点进行过滤筛选和打分排序，直到找出最优节点，筛选过程类似于下图。<br><img src="/images/schedule/filters.jpg" alt="筛选过程"></p><p>一般的，资源调度对节点的筛选会分为两个步骤：硬性条件筛选，软性条件筛选（需要说明下，这两个名词是我参考了文末的资料，并非原创）。在一些开源框架中，这两个步骤都有特定的叫法，如 openstack 中，这两个步骤分别称为 filter 和 weighting，在 k8s 中，分别称为 predicate 和 priority。</p><h3 id="硬性条件筛选"><a href="#硬性条件筛选" class="headerlink" title="硬性条件筛选"></a>硬性条件筛选</h3><p>硬性条件筛选，解决的是”能不能“的问题，即这个 VM 能不能建在这个节点上。那么有哪些硬性筛选条件呢？</p><ul><li><p><strong>节点类型</strong><br>  节点类型包括节点的固有属性，包括硬件类型，软件类型等。比如用户创建的 VM 对计算性能有要求，指定了 CPU 型号为 1802，因此那些 CPU 非指定型号的节点将直接被过滤掉；再比如，某个节点当前被设置为 disable 或 maintanced，表示该节点有问题或处于维护状态，这样的节点将被过滤掉。</p></li><li><p><strong>计算容量</strong><br>  整个很好理解，只有容量满足需求的节点才能通过筛选。比如用户创建的 VM 是 8 核 16 G，那么那些可用 CPU 数少于 8 或者可用内存少于 16 G 的节点将被过滤掉。</p></li><li><p><strong>磁盘容量</strong><br>  这个类似于计算容量，用户需要一个 500 G 的本地 SSD 磁盘，那些磁盘容量少于 500 G 的节点将被过滤掉。</p></li><li><p><strong>节点配额</strong><br>  当一个节点计算容量和磁盘容量都满足条件，并不一定能通过筛选，还要看该节点是否满足系统配额，比如系统规定，每个节点最多只能放有 10 个 VM，那么如果某节点已经到上限，此时也会被过滤掉。</p></li></ul><p>这里列举的只是一部分典型的筛选条件，还有其他的条件这里没有给出。</p><p>硬性条件筛选过滤掉了所有不满足条件的节点，剩下的节点都是满足创建 VM 的。硬性条件筛选不具有权重，筛选时，根据某一条件，节点要么能通过筛选，要么不能。任意一个条件筛选完后，发现没有可用的节点，那么就认为调度失败，要么直接返回错误，要么循环一直重新筛选，直到筛到有可用节点为止。<br>只有通过所有条件筛选的节点，才可以进行下一步软性条件筛选。</p><h3 id="软性条件筛选"><a href="#软性条件筛选" class="headerlink" title="软性条件筛选"></a>软性条件筛选</h3><p>通过上一步的硬性条件筛选，现在可以对剩下的所有节点进行软性条件筛选了。软性条件筛选解决的是”好不好“的问题，即 VM 建在这个节点上好不好，是不是最优的。我们也看下有哪些软性条件。</p><ul><li><p><strong>资源占用小</strong><br>  这个原则很直观：VM 最好是建在那些负载较低的节点上，这样有利于 VM 的快速启动以及性能。负载较高的节点，会导致上面的 VM 资源争抢严重。最坏的情况下，甚至导致节点宕机，因此最好不要选择负载高的节点。</p></li><li><p><strong>亲和性</strong><br>  亲和性是说，尽量将多个 VM 放在一个节点，或者绑定在一个节点上。例如，现在每个节点上有 500G 的磁盘空间供 VM 使用，假如 VM A 占用了 Node1 上的 300G，这时有一个创建 VM 的请求，它想要 200G 的空间，那么它可以选择节点 Node1，也可以选择其他 500G 的节点，但根据亲和性原则，它最好选择 Node1，因为这样正好可以把 Node1 上的磁盘用完，充分利用了磁盘资源。如果不这样选择，而是选择了其他有 500G 容量的节点，如 Node2，那么现在 Node1 上剩 200G，Node2 上剩 300G，如果这时再想创建一个 400G 或 500G 的 VM，Node1 和 Node2 均无法满足磁盘容量需求，这时不得不选择一个其他有 500G 的节点，如 Node3。这时 Node1 和 Node2 上剩余的磁盘资源就这么空着浪费掉了，有了亲和性，只需要使用 Node1 和 Node2 即可，这就是一个亲和性表现。</p></li><li><p><strong>打散分布</strong><br>  打散正好跟亲和性相反，也可以称为反亲和性。有的情况下，我们会按照某种规则，将资源尽量进行打散分布，例如，某个用户创建 5 台 VM，这里就可以将这 5 个 VM 做打散处理，将他的 VM 尽量分布在不同的节点上。这样的好处是，避免了某个节点宕机导致该用户在上面建的 VM 全挂，通俗点，不要将鸡蛋放在一个篮子里。这里是按照用户来进行打散筛选的，实际还有很多其他维度可以应用打散筛选规则，如根据标签打散，在创建 VM 时，给 VM 打上一个标签，有相同标签的多个 VM 打散分布在不同的节点上。</p></li><li><p><strong>本地基础镜像缓存</strong><br>  本地基础镜像是指 VM 运行时需要的 base 镜像。我们知道，KVM 使用了一种称为写时复制的技术，每个 VM 都是由一个 base 层和一个 top 层构成，base 层是只读的，里面的数据是操作系统，和一些预装程序，所有的写操作都在 top 层完成，这样的好处是，多个 VM 可以共用一个 base，而只有 top 层独立。base 一般称为基础镜像，也可以叫 backing file。这些基础镜像一般会集中放在一个镜像服务器上，当需要时，会被下载到指定节点，作为这个节点上所有相同系统的 VM 的 base。后面如果再创建了相同系统的 VM，就不用再去下载了，这样可以大大加快创建 VM 的速度。<br>  现在假如要创建一个 CentOS7 的 VM，Node1 上已经有 CentOS7 的 base，而 Node2 上没有，那么我们应该选择 Node1，这样免去了下载 base 的时间成本。</p></li></ul><p>软性条件筛选每个因素都可以有对应的权重，根据这些权重和分值，可以给通过了硬性条件筛选的所有节点计算加权分值，得分最高的节点即是最优节点。</p><p>最优节点找到后，调度的任务就完成了，剩下的就是在这节点上创建 VM 了。k8s 中，这个过程被称为 binding（pod 和 node 绑定）。</p><p>上面列出的只是一部分条件，其他的条件不一一列举，事实上，软性条件筛选灵活性很高，比硬性条件筛选更复杂，更主观，影响因子可以有很多，权重也可以动态调整，需要根据实际情况，业务情况，选择合适的条件，合理的权重。</p><p>总结下来，整个调度过程，就是一个不断过滤筛选的过程，输入 VM 的各项规格，调度器根据这些规格参数，以及集群中所有节点的属性，输出一个最合适的节点，可用下图来概括调度的作用。<br><img src="/images/schedule/scheduler.jpg" alt="调度器"></p><p>另外，上面的每个筛选流程都是独立的，也就是说，可以在任意两个流程中插入自己的筛选逻辑，只要符合期望即可，甚至完全不用框架提供的调度器，完全使用自定义的调度器。事实上很多企业内部自研的调度，都是在开源框架的基础上，加入了一些定制化的调度逻辑来满足自己的需求，比如，在硬性条件筛选阶段，把过滤效率高的流程提前，一次性过滤尽可能多的不符合条件的节点；软性条件筛选阶段，在允许一定容忍度情况下，寻找一个局部最优节点而不是全局最优节点，也能加快筛选过程。但也需要考虑到，筛选逻辑并非越多越好，过多反而会使筛选效率降低，得不偿失。</p><h2 id="资源重调度"><a href="#资源重调度" class="headerlink" title="资源重调度"></a>资源重调度</h2><p>经过上面的步骤，我们解决了如何为新创建的 VM 分配一个合理的节点。但需要注意，系统运行过程中，节点的各参数都是动态变化的，比如某节点现在负载较低，过了一会儿，该节点上面的 VM 做大量运算，或者节点执行像打快照这类比较重的操作，导致节点负载升高，超过警戒阈值，那么这时需要对节点上的 VM 做迁移操作，将部分 VM 迁到其他节点，以降低该节点的负载。迁到哪个节点上呢？这就又涉及到上面的调度过程了，还是需要经过硬性条件和软性条件筛选，这个过程就是重调度。</p><p>资源重调度是一个很重要，也很复杂的问题，最原始的方式是人肉盯监控报警，一旦出现负载高的节点，由人工手动迁移 VM，这种处理方式简单但费力，半夜被报警吵醒也是常事，相当于响应式处理。当集群节点数上去后，就需要一种能自动迁移的机制了，也就是智能调度，这种方式不仅免去人工操作的繁琐，还具有一定的预测能力，即依靠机器学习或神经网络等技术，能提前预知哪些节点可能会报警，那么就提前自动迁移该节点上的 VM，整个过程不需要人工干预。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>云计算完成了 CPU、内存、磁盘、网络等资源的抽象，资源调度解决的问题是如何将一个 VM，一个 pod，或者更抽象点说，一个应用，放到最合适的位置，以提高整个集群中节点的使用率，既不出现节点负载很高导致性能受影响，也不会有使用率低导致机器的浪费。本文简单介绍了资源调度的流程，包括硬性筛选和软性筛选，以及一些典型的筛选条件，实际使用的调度要比这复杂的多，基于此，智能调度也是未来资源调度领域的一个热点。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://tech.meituan.com/2019/08/22/kubernetes-cluster-management-practice.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/08/22/kubernetes-cluster-management-practice.html</a><br>《容器与容器云》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云厂商将机房中服务器的计算能力进行整合，如 CPU、内存等，并把这些硬件统一抽象为资源，然后按需卖给用户，这就是云计算理念，怎么把这些资源有效的管理和调度起来，最大化资源利用率，关系着云厂商的成本和营收，也是各厂商实现差异化的一个重要切入点。本文讲讲云计算中的资源调度，或者称为 scheduler。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="openstack" scheme="http://xujimmy.com/tags/openstack/"/>
    
      <category term="k8s" scheme="http://xujimmy.com/tags/k8s/"/>
    
      <category term="schedule" scheme="http://xujimmy.com/tags/schedule/"/>
    
      <category term="资源调度" scheme="http://xujimmy.com/tags/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用 PXE 从网络安装操作系统</title>
    <link href="http://xujimmy.com//2019/07/21/pxe-install-os.html"/>
    <id>http://xujimmy.com//2019/07/21/pxe-install-os.html</id>
    <published>2019-07-21T08:12:40.000Z</published>
    <updated>2019-11-08T08:55:08.649Z</updated>
    
    <content type="html"><![CDATA[<p>平时我们拿到一台新电脑后，第一件事就是安装操作系统，安装系统常规方式是用光盘或 U 盘，需要提前在 BIOS 里设置引导顺序，让 CDROM 或 U 盘为第一引导项，重启后就可以走安装系统流程了，安装过程中还需要手动设置一些选项，如设置时区，硬盘分区等。等安装完后，再设置 BIOS 从硬盘启动，系统就算安装好了。这是家庭或电脑店里的常规方式。试想下，企业采购一批服务器，100 台甚至上千台，如果仍然采用这种方式，那运维得累死。这时，我们可以采用 PXE 方式，从网络给服务器安装系统。</p><a id="more"></a><h2 id="什么是-PXE"><a href="#什么是-PXE" class="headerlink" title="什么是 PXE"></a>什么是 PXE</h2><p>这里我不打算把维基百科中的概念性语言搬到这里，我们只需要知道，<strong>PXE 也是一种装机技术，唯一和平时装机方式不同的地方是，PXE 使用的系统镜像和内核，不是放在光盘和 U 盘里，而是放在了远端网络上，装机过程中，PXE 会自动从远端下载文件到本地，然后完成系统安装。</strong><br>更重要的是，它可以在远端 ks 文件的指导下，完成无人值守，自动设置，自动装机。因此，企业中大部分都会采用这种方式来进行批量装机。</p><h2 id="需要准备哪些东西"><a href="#需要准备哪些东西" class="headerlink" title="需要准备哪些东西"></a>需要准备哪些东西</h2><p>原理知道了，但具体需要哪些准备条件呢？既然是从网络引导安装，那么至少具备：</p><ul><li>远端必须得有个存放系统镜像以及一些装机所需文件的服务器，并且提供下载服务</li><li>设置本地机器从网络引导</li><li>本地机器必须具备 IP，以便从远端下载文件到本地</li></ul><p>第一个条件很好具备，拿一台机器起个 nginx 或 ftp 服务就好了。在 PXE 装机环境下，这个服务器被称为部署服务器（pxe server）。</p><p>第二个问题可以直接进 BIOS 设置，但如果要装机的数量庞大，也得累死。更通用的方式是通过机器的 IPMI 设备进行设置，IPMI 是一个通用接口标准，最重要的就是 BMC（Baseboard Management Controller），它是主板上的一块芯片，独立于 BIOS 和 OS ，并且可以配置 IP，通过这个 IP 可以对计算机进行远程控制，比如通电，断电，重启，设置引导项，查看计算机部件的物理信息，如 CPU 核数，甚至风扇温度等。BMC 配的这个 IP 我们称为<strong>带外 IP</strong>，看下面示意图。<br><img src="/images/pxe/bmc.png" alt="计算机上的bmc设备"><br>使用方式也很简单，一般服务器厂商都会给 IPMI 配置一个简单的 UI，直接在浏览器里输入带外 IP 即可打开。或者<code>yum install ipmitool</code>，这是 shell 环境下的一个 IPMI 管理工具，自带基本命令。假设机器的带外 IP 是 10.0.0.1，端口为 623，登录账号密码都为 admin，常用命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开机器电源</span></span><br><span class="line">ipmitool -I lanplus -H 10.0.0.1 -p 623 -U admin -P admin power On</span><br><span class="line"><span class="comment"># 关闭电源</span></span><br><span class="line">ipmitool -I lanplus -H 10.0.0.1 -p 623 -U admin -P admin power Off</span><br><span class="line"><span class="comment"># 重启机器</span></span><br><span class="line">ipmitool -I lanplus -H 10.0.0.1 -p 623 -U admin -P admin power reset</span><br><span class="line"><span class="comment"># 设置第一引导方式为 pxe</span></span><br><span class="line">ipmitool -I lanplus -H 10.0.0.1 -p 623 -U admin -P admin chassis bootdev pxe</span><br></pre></td></tr></table></figure></p><p>带外 IP 非常有用，很大程度上避免了需要去机房人肉操作的麻烦，比如线上一台物理机宕机，系统崩溃需要重启，打电话喊人进机房按重启键就太原始了，直接通过带外 IP，发条 reset 命令就可以重启了。</p><p>第三个问题看似不是什么问题，但不要忘了，在一个还没有装系统的机器上，是没有 IP 的，也没地方让你去执行 wget 之类的下载命令。<br>但每台机器上都有网卡设备，网卡有 mac 地址，我们可以在部署服务器上，起一个 DHCP 服务，让本地网卡发 DHCP 广播，部署服务器收到后，给本地机器网卡分配一个 IP。DHCP 工作原理大家可以翻大学的计算机网络，或者自行查看维基百科。这过程就像我们回到家里，手机自动连到家里 WIFI 一样，因为家里的路由器有 DHCP 服务，它帮手机自动分配了 IP，所以就可以上网了。自动分配 IP 的好处就是简单，免去人工配置，而且绝对不会有 IP 冲突。如果是手动配，效率低不说，还必须知道已经分了哪些 IP，避免再分配相同的 IP。但自动分配 IP 的弊端是，它分配的 IP 是临时的，比如今天给你手机分配的 IP 是 192.168.1.3，明天回来，给你分的可能就是 192.168.1.5 了。但只要你一直用，保持 WIFI 不断开，那这个 IP 也就不会变。在 PXE 装机环境中，总是会有个 DHCP 服务，由它给这个网络中的网卡分配 IP，为了节省，直接在部署服务器上起 DHCP 服务即可。</p><blockquote><p>需要注意的是，一个 PXE 装机网络中，只能有一个 DHCP 服务，这是由 DHCP 工作原理决定的。如果有多个 DHCP，会导致 IP 分配失败。</p></blockquote><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>上面的问题都有解答，可以来实际操作了，条件所限，本文使用 VirtualBox 来搭建 PXE 装机环境，所以没有真实的 IPMI 设备，但好在 VirtualBox 可以设置让 VM 从网络启动，因此不影响效果。<br>我们需要至少两个 VM，一个作为 pxe server，一个作为 client 待装系统。先来看下 PXE 装机流程图<br><img src="/images/pxe/pxe-boot.png" alt="PXE 装机流程"><br>可以看到，整个过程大致可分两步</p><ol><li>client 端申请 IP，这是执行后续步骤的先决条件</li><li>client 在指定目录拉取内核和必要的装机文件</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>必须得确保这两个 VM 所在的网络中，只有 pxe server 提供 DHCP 服务，如果你选择桥接模式，即 VM 和宿主机在同一个网络，那么得保证这个网络中没有其他 DHCP 服务，如果你在家里装，需要关掉家里路由器上的 DHCP；如果是在公司办公网装，那就得谨慎了，办公网的网络配置一般不能由自己规划，一不小心，可能导致办公网瘫痪，但可以用 VirtualBox 的内部网络，即 VM 和宿主机网络隔离，VM 之前互通，那么这天然就是一个良好的装机环境，但这种情况下，VM 是没法通外网的，要装一些包就很麻烦，要么让 VM 和宿主机共享一个目录，把包导入到 VM，要么先把 VM 设为桥接模式通外网，把需要的包装好后再设为内部网络模式。为了方便，下文用家庭桥接模式，网络拓扑如下<br><img src="/images/pxe/network-top.png" alt="PXE 装机网络拓扑"></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>准备 CentOS 的 ISO 安装包，创建一个 centOS 的 VM，设置网络为桥接模式，装好系统，作为 pxe server，暂称为 A，假设其 IP 为 192.168.1.5。装完后，将 ISO 安装包从宿主机传到 A 某目录，如 /tmp，后面需要用。</li><li><p>安装 dnsmasq，用来提供 DHCP 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install dnsmasq</span><br></pre></td></tr></table></figure><p> 将原来的 /etc/dnsmasq.conf 备份，重新生成一个配置，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网卡名，这里根据你的网卡填写</span></span><br><span class="line">interface=eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定</span></span><br><span class="line">dhcp-boot=pxelinux.0</span><br><span class="line">port=0</span><br><span class="line"><span class="built_in">enable</span>-tftp</span><br><span class="line">tftp-root=/var/lib/tftpboot/</span><br><span class="line"><span class="built_in">log</span>-facility=/var/<span class="built_in">log</span>/dnsmasq.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># dhcp 分配的 ip 范围</span></span><br><span class="line">dhcp-range=192.168.1.100,192.168.1.110</span><br><span class="line"><span class="comment"># netmask</span></span><br><span class="line">dhcp-option=1,255.255.255.0</span><br><span class="line"><span class="comment"># DNS</span></span><br><span class="line">dhcp-option=6,233.5.5.5,8.8.8.8</span><br></pre></td></tr></table></figure></li><li><p>安装 syslinux，tftp-server，vsftpd 提供内核和镜像下载服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install syslinux, tftp-server, vsftpd</span><br></pre></td></tr></table></figure><p>拷贝相关文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r /usr/share/syslinux/* /var/lib/tftpboot</span><br></pre></td></tr></table></figure></li><li><p>生成必要的目录和文件，上面的 dnsmasq 配置会从这里读取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/tftpboot/pxelinux.cfg</span><br><span class="line">mkdir /var/lib/tftpboot/centos7</span><br><span class="line">touch /var/lib/tftpboot/pxelinux.cfg/default</span><br></pre></td></tr></table></figure><p>default 文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default menu</span><br><span class="line">prompt 0</span><br><span class="line">label pxe</span><br><span class="line">kernel centos7/vmlinuz</span><br><span class="line">append initrd=centos7/initrd.img method=ftp://192.168.1.5/pub</span><br></pre></td></tr></table></figure><p>注意上面的 IP 地址为 pxe server 的 IP</p></li><li><p>挂载 ISO 文件，拷贝内核文件和镜像到指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop /tmp/centos-dvd.iso  /mnt </span><br><span class="line">cp /mnt/images/pxeboot/vmlinuz  /var/lib/tftpboot/centos7</span><br><span class="line">cp /mnt/images/pxeboot/initrd.img  /var/lib/tftpboot/centos7</span><br><span class="line">cp -r /mnt/* /var/ftp/pub/</span><br><span class="line">chmod -R 755 /var/ftp/pub</span><br></pre></td></tr></table></figure></li><li><p>启动所有服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start dnsmasq</span><br><span class="line">systemctl start vsftpd</span><br><span class="line">systemctl <span class="built_in">enable</span> dnsmasq</span><br><span class="line">systemctl <span class="built_in">enable</span> vsftpd</span><br></pre></td></tr></table></figure><p>ps 命令查看进程，确保上述服务都已经启动，并能从浏览器能访问到 ftp 中的文件，如果没法访问，查看是否因为防火墙的原因。到这一步 pxe server 就准备好了。</p></li><li>再创建一个 centOS 的 VM，称为 B，注意 B 的内存必须设置大于 1 G，否则会导致安装失败。设置 B 也为桥接模式，启动时按 F12，设置从网络引导。</li><li>如果一切顺利，可以看到 B 先广播了一个 DHCP 包，被 A 上的 dnsmasq 收到，响应了一个 DHCPOFFER，并给 B 分配了 IP，然后 B 从 A 的 tftp 目录下载内核，最后就进入到熟悉的装机界面了。</li></ul><h2 id="ks-自动安装"><a href="#ks-自动安装" class="headerlink" title="ks 自动安装"></a>ks 自动安装</h2><p>上面的安装流程，实现了从网络装机目的，但有个问题：进入装机界面后，仍然需要我们手动选择一些配置，批量装机的话，一台一台配置，还是很麻烦。我们可以通过 ks（kickstart） 文件，实现自动配置，即在需要选择的步骤时，由 ks 自动帮我们选择。</p><p>ks 文件实际就是个装机模板，它定义了系统装机时的一些配置选项，比如时间，网络，分区，用户名，密码等。一份典型的 ks 文件如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">install </span><br><span class="line">url --url=ftp://192.168.1.5/pub/</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># BASIC CONFIGURATIONS</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># System language</span></span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyboard layout</span></span><br><span class="line">keyboard --vckeymap=us --xlayouts=<span class="string">'us'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># System timezone</span></span><br><span class="line">timezone Asia/Shanghai --isUtc</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELinux configuration</span></span><br><span class="line">selinux --disabled</span><br><span class="line"></span><br><span class="line"><span class="comment"># System services</span></span><br><span class="line">services --enabled=<span class="string">"chronyd"</span></span><br><span class="line">firstboot --<span class="built_in">disable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use graphical install</span></span><br><span class="line">graphical</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reboot after installation</span></span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># System authorization information</span></span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># ROOT PASSWORD</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"></span><br><span class="line">rootpw --iscrypted <span class="variable">$1</span><span class="variable">$TzIdo</span>.bL<span class="variable">$rjBu</span>.XWo38VS0xQ/QWOYI.</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># NETWORK CONFIGURATIONS</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line">network --hostname=localhost</span><br><span class="line"></span><br><span class="line">network --bootproto=dhcp --device=eth0 --onboot=on</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># DISK PARTITIONS</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"></span><br><span class="line">autopart --<span class="built_in">type</span>=lvm</span><br><span class="line">clearpart --all --initlabel</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># POST SCRIPTS</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line">%post</span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br><span class="line"></span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># PACKAGES</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line">%packages</span><br><span class="line">@core</span><br><span class="line">chrony</span><br><span class="line">kexec-tools</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%addon com_redhat_kdump --<span class="built_in">enable</span> --reserve-mb=<span class="string">'auto'</span></span><br></pre></td></tr></table></figure></p><p>将上述内容写入到 /var/ftp/pub/ks/centos.ks 文件中，并修改上面第 4 部的 default 文件，指明 ks 文件的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default menu</span><br><span class="line">prompt 0</span><br><span class="line">label pxe</span><br><span class="line">kernel centos7/vmlinuz</span><br><span class="line">append initrd=centos7/initrd.img devfs=nomount ksdevice=bootif ks=ftp://192.168.1.5/pub/ks/centos.ks</span><br></pre></td></tr></table></figure></p><p>这样，当 client 下载内核后，会从指定路径下载 ks，然后在 ks 的引导下，自动装机，这样就不需要人工做任何操作了。更重要的是，只要共用一份相同的 ks，那么所有的机器装好系统后，设置都是一样的。</p><blockquote><p>CentOS 系统的模板类型叫 kickstart，而 ubuntu 的话，称 preseed，二者的格式有所不同</p></blockquote><h2 id="裸金属服务器"><a href="#裸金属服务器" class="headerlink" title="裸金属服务器"></a>裸金属服务器</h2><p>现在公有云和私有云中，有一类称为裸金属服务器的产品，如阿里云的神龙裸金属服务器，华为的 BMS 等，特点是具备了虚拟机的弹性，又有物理机的性能。实际上它就是一种物理机托管，云平台通过 IPMI 设备将这些物理机管理起来，用户要用服务器时，在云平台上选择好规格，点击创建，后端会根据规格，选择一台实际的物理机，通电，然后 PXE 装系统，装好后交付给用户。更进一步，可以直接把安装好系统的 ghost 或 qcow2 文件放在 pxe server，装机时直接释放到所有机器，就像我们恢复系统样，省去了安装系统的步骤，更加便捷效率更高。甚至本地机器根本不需要硬盘，直接挂载一个云盘，然后将系统释放到云盘即可。当用户使用完后，直接给该物理机断电，相当于归还过程。后面如果又有用户用，重新走通电装系统流程。在 openstack 项目中，有个叫 ironic 的子项目，就是裸机管理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 PXE 装机的基本原理和使用场景，这也是企业 IDC 机房大规模安装系统的方式，运维只要准备一个 pxe server，然后通过 ipmi 批量设置所有机器都从 PXE 引导，这样就不需要拿着光盘 U 盘在机房人肉操作了。实际使用中，可能会有更多的定制化，比如在 ks 里自动安装一些必备软件，比如装机前后，向某个 log server 发请求，表明装机情况等。云厂商的裸金属服务器产品，基本都基于这种原理，或者加入了一些定制化，使之更便捷装机效率更高。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.51cto.com/itwish/2154820" target="_blank" rel="noopener">https://blog.51cto.com/itwish/2154820</a></li><li><a href="https://www.tecmint.com/install-pxe-network-boot-server-in-centos-7/" target="_blank" rel="noopener">https://www.tecmint.com/install-pxe-network-boot-server-in-centos-7/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时我们拿到一台新电脑后，第一件事就是安装操作系统，安装系统常规方式是用光盘或 U 盘，需要提前在 BIOS 里设置引导顺序，让 CDROM 或 U 盘为第一引导项，重启后就可以走安装系统流程了，安装过程中还需要手动设置一些选项，如设置时区，硬盘分区等。等安装完后，再设置 BIOS 从硬盘启动，系统就算安装好了。这是家庭或电脑店里的常规方式。试想下，企业采购一批服务器，100 台甚至上千台，如果仍然采用这种方式，那运维得累死。这时，我们可以采用 PXE 方式，从网络给服务器安装系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="pxe" scheme="http://xujimmy.com/tags/pxe/"/>
    
      <category term="ipmi" scheme="http://xujimmy.com/tags/ipmi/"/>
    
      <category term="dnsmasq" scheme="http://xujimmy.com/tags/dnsmasq/"/>
    
      <category term="dhcp" scheme="http://xujimmy.com/tags/dhcp/"/>
    
  </entry>
  
  <entry>
    <title>什么是 I/O 多路复用</title>
    <link href="http://xujimmy.com//2019/06/27/what-is-io-multiplexing.html"/>
    <id>http://xujimmy.com//2019/06/27/what-is-io-multiplexing.html</id>
    <published>2019-06-27T08:12:40.000Z</published>
    <updated>2019-11-08T08:55:08.649Z</updated>
    
    <content type="html"><![CDATA[<p>在高并发环境下，web 服务器需要处理成千上万的客户端连接，如何最大限度发挥单台机器的性能，使之在处理大量连接时仍保持较低的负载，这是个很重要的课题。本文介绍下解决此类问题的一种很经典的方式：I/O 多路复用。<br><a id="more"></a></p><h2 id="传统-I-O"><a href="#传统-I-O" class="headerlink" title="传统 I/O"></a>传统 I/O</h2><p>为了了解 I/O 多路复用是怎么产生的，我们先看下传统的网络 I/O 模式，也被称为 BIO(Blocking IO)。</p><p>在编写服务端网络程序时，传统的方式是这样的：创建套接字并绑定端口，然后用一个 while 循环，在循环里调用 accept，程序会阻塞，一旦有连接到来，accept 就返回，然后针对该连接做相应的读写处理。形式像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line"><span class="comment">// 绑定套接字</span></span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">2345</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 accept 等待客户端连接，程序阻塞，当有连接到达时才返回</span></span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    <span class="comment">// 对套接字读写</span></span><br><span class="line">    handle(socket);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line">serverSocket.colse();</span><br></pre></td></tr></table></figure></p><p>一般我们在刚学网络编程时，都会用这种的方式，也被称为单线程模式，这种模式的特点就是简单直白，方式固定，写起来较容易。但有个致命问题：同一时间，它只能处理一个客户端请求，因为它直接是在主线程中处理请求的，只有在上一个请求处理完毕，才能接着处理下一个请求，一旦某个请求处理较慢，那后面的请求只能等待。</p><p>把上面的单线程模式改下，对每个连接，新开一个线程单独进行读写处理，这样就可以同时处理多个连接了，形式如下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 创建和绑定步骤不变</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">       Socket socket = serverSocket.accept();</span><br><span class="line">       <span class="comment">// 新开一个线程，对套接字读写</span></span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           handle(socket);</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这种模式就是多线程模式，比上面的那种要高级一点，它可以同时处理多个连接，因为对每个连接的处理都是在一个单独的线程中，和主线程分离开来，主线程可以继续 accept 客户端连接。</p><p>但这种模式仍然存在问题：</p><ol><li>线程的创建和销毁的成本是很高的，创建线程需要消耗内存，1 个线程需要耗费 512K 到 1M 的内存，几十上百个可能看不出来，成千上万的话，内存很快就耗尽。</li><li>线程池能解决部分问题，但当请求过多，线程池仍然处理不过来，导致大量的请求超时，更严重的是，大量的线程会导致大量的线程切换，线程切换，或者说上下文切换是需要 CPU 开销的，线程切换越频繁，真正分配给业务的 CPU 资源就越少。</li></ol><p>上面的两种模式，不管是单线程模式还是多线程模式，我们都称之为阻塞模式(Blocking I/O)，是因为它们对连接的处理，都是以线程为基石，在一个线程中处理一个 socket 的读写，但实际情况是，线程的大部分时间都是在等待数据的到来。当调用 recvfrom 时，线程会等待着客户端的数据到达网卡，然后网卡把数据交给内核，然后内核再把数据拷贝到用户进程空间，这时 recvfrom 才会返回。这个过程<br>中，线程的绝大部分时间都是处于等待数据状态，什么也做不了。而下面要介绍的 I/O 多路复用，就是为解决此问题而生。</p><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h2><p>上面我们分析了由线程直接处理网络 I/O 的低效原因，想象下，当我们调用 recvfrom，发现数据还没准备好，就不傻等了，而是告诉系统：等数据准备好了，你告诉我下，我再来读。这时线程可以先去干点别的，比如去检查下有没有其他的连接。过了一会儿，系统产生了一个可读事件，告诉我们，你要的数据准备好了，可以来读了，这时就可以继续回到刚才的地方读取数据。这样效率不是就好多了吗？因为在等数据的同时，我还可以干其他的事情。这是一种<strong>非阻塞模式</strong>，那么这种“数据好了通知我们”的机制怎么实现呢？</p><p>其实，操作系统已经给我们提供了 <strong>select，poll，epoll，kqueue</strong> 这样的系统调用，来完成我们上面的要求，这些系统调主要干一件事：<strong>监听一个或多个文件描述符上的各类事件，一旦文件描述符上有事件产生，就返回</strong>。文件描述符，是 Unix 系统下的一个叫法，也称为 fd(file descriptor)，下文统称为 fd，fd 对应于 Windows 平台下的句柄（handle），一个文件描述符唯一标识了某进程打开的某个文件，Unix 的设计哲学就是一切皆文件，socket 也是文件，可以作为 fd 被监听。监听哪些事件呢？有：连接事件（acceptable），可读事件（readable），可写事件（writeable），关闭事件（closeable）等。于是通过这类系统调用，监听多个 fd，一旦某个 fd 上有某个事件产生，调用就会返回，于是我们知道“有事发生”，然后根据事件的类型，做不同的处理。因此，有时也把这种模型称为<strong>事件驱动模型</strong>，或者 <strong>Reactor 模式</strong>。</p><p>I/O 多路复用的关键，是它可以让内核监听 fd 的事件，而且可以同时监听多个 fd，和用一个线程处理一个 socket 连接有根本的区别，它只需要一个线程或进程，就管理了多个连接，我们可以用一句话来概括 I/O 多路复用：<strong>在一个线程或一个进程中，监听了多个 fd。这里的复用，指的是多个 fd，或者说多个连接，复用了一个线程或者进程。</strong></p><h3 id="I-O-多路复用的三种方式"><a href="#I-O-多路复用的三种方式" class="headerlink" title="I/O 多路复用的三种方式"></a>I/O 多路复用的三种方式</h3><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>首先来看 select，它的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></p><ol><li>nfds 为需要监听的最大 fd 个数+1。</li><li>中间的三个参数 readfds、writefds 和 exceptfds 指定我们要让内核监听读、写和异常条件的 fd。如果对某一个的条件不感兴趣，就可以把它设为空指针。fd_set 结构体可以理解为集合，存放的是 fd，可以通过下面的宏处理这三种 fd_set:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_CLR(inr fd, fd_set *fdset);   <span class="comment">// 清除 fd set 中相关 fd 的位</span></span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set *fdset); <span class="comment">// 测试 fd set 中相关 fd 的位是否为真</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *fdset);  <span class="comment">//  设置 fd set 中相关 fd 的位</span></span><br><span class="line">FD_ZERO(fd_set *fdset);         <span class="comment">//  清除 fd set 的全部位</span></span><br></pre></td></tr></table></figure></li></ol><p>select 的使用方法，我们看下面的例子，为了简单起见，我们只传入了可读事件的 fd，对其他的字段设置为 NULL，表示我们不感兴趣。在 for 事件循环中，调用 select，一旦 fd 有可读事件，就调用 read 处理读事件。其中判断可读是通过调用 FD_ISSET 来完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> nbytes;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* select call happens here */</span></span><br><span class="line">    <span class="keyword">if</span> (select(FD_SETSIZE, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"select"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(i, &amp;read_fds)) &#123;</span><br><span class="line">            <span class="comment">/* read call happens here */</span></span><br><span class="line">            <span class="keyword">if</span> ((nbytes = read(i, buf, <span class="keyword">sizeof</span>(buf))) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                handle_read(nbytes, buf);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* real version needs to handle EINTR correctly */</span></span><br><span class="line">                perror(<span class="string">"read"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后，程序会阻塞在 select，一旦 fds 中有可读事件，select 即返回，然后就可以遍历，查看到底是那个 fd 可读，并做相应处理。</p><p>I/O 多路复用概念被提出来后，select 是第一个实现它的系统调用，它是一个古老的实现，在 20 世纪 80 年代就诞生了，几乎所有的平台上都支持，良好跨平台支持也是它的一个优点。然而，它的缺点也不可忽视：</p><ul><li>监听的 fd 数量存在最大限制，在 Linux 上这个最大值是 1024，这在 select 诞生的那个年代来说足够了，但对现在互联网信息爆炸时代来说，极大限制了 select 的可用性。</li><li>其次，一旦监听的 fd 上有事件产生，select 仅仅会返回，但并不会告诉我们是哪些 fd 产生了事件，这时需要自己遍历所有的 fdset，依次检查每个 fd 上的事件标志位。显然，遍历的这个过程时间复杂度是 O(n)。因此，即使把上面的最大监听数改大，但带来的问题是效率的降低。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>再来看 poll，它是 select 的改进版，主要改进点有：</p><ul><li>去掉了 1024 这个最大监听数的限制。用户可以自定义监听 fd 数。</li><li>简化了 select 调用方式，它的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>不同于 select 使用三个位图来表示三个 fdset 的方式，poll 使用一个 pollfd 的指针实现，pollfd 结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> fd;                         <span class="comment">// file descriptor</span></span><br><span class="line">        <span class="keyword">short</span> events;                   <span class="comment">// requested events to watch</span></span><br><span class="line">        <span class="keyword">short</span> revents;                  <span class="comment">// returned events witnessed</span></span><br><span class="line">&#125; <span class="keyword">pollfd_t</span>;</span><br></pre></td></tr></table></figure></p><p>pollfd 结构包含了要监听的 event 和发生的 event，不再使用 select “参数-值”传递的方式，使得 poll 支持的 fd 集合限制远大于 select 的 1024。但是，poll 并没有解决 select 最根本的问题：它依然需要遍历所有 fd 来检查事件，遍历的时间复杂度依然是 O(n)。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>再来看看 epoll，epoll 和上面的 select 和 poll 有着本质的区别，除了没有最大监听数限制外，它还有一个最大特点：<strong>只返回有事件发生的 fd，所以不需要遍历所有监听的 fd 来找到哪些 fd 产生了事件。因此，它的时间复杂度为 O(k)，其中 k 为产生事件的 fd 数</strong>。因此，epoll 的效率不会像 select 和 poll 那样，随着监听 fd 的数量的增长而下降，那么它是怎么做的呢？来看下使用 epoll 时需要的三个系统调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>epoll_create： 创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 select 中的第一个参数，给出最大监听的 fd+1 的值，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</li><li>epoll_ctl：对指定 fd 执行 op 操作，epfd 是 epoll_create 的返回值。op 表示操作，用三个宏来表示：添加 EPOLL_CTL_ADD，删除 EPOLL_CTL_DEL，修改 EPOLL_CTL_MOD。分别添加、删除和修改对 fd 的监听事件，epoll_event 告诉内核需要监听什么事。</li><li>epoll_wait：等待 epfd 上的 io 事件，最多返回 maxevents 个事件。</li></ul><p>上面对函数的解释可能比较抽象，简单来讲：当我们调用 epoll_create 时，内核就创建了一棵红黑树和一个就绪（Ready）链表，其中，红黑数用于存储后面 epoll_ctl 传过来的 fd，以支持高效的查找、插入和删除。就绪链表用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个就绪链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。使用 epoll 的方式大概长这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10;</span></span><br><span class="line"><span class="keyword">int</span> event_count;</span><br><span class="line"><span class="comment">// 这里是创建网络程序的一般步骤</span></span><br><span class="line"><span class="comment">// ... socket(), bind(), listen()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建epoll文件描述符，出错返回 -1</span></span><br><span class="line"><span class="comment">// int epoll_create(int size) 从Linux2.6.8开始，size 值被忽略，不过为保持兼容需要设定为一个正整数</span></span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">1024</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events_in</span>[<span class="title">MAX_EVENTS</span>];</span> <span class="comment">// 记录套接字相关信息</span></span><br><span class="line">ev.events = EPOLLIN; <span class="comment">// 监视有数据可读事件</span></span><br><span class="line">ev.data.fd = fd; <span class="comment">// 文件描述符数据，其实这里可以放任何数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入监听列表，当fd上有对应事件产生时，epoll_wait会将epoll_event填充到events_in数组里</span></span><br><span class="line"><span class="comment">// 出错返回 -1</span></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 等待事件，epoll_wait 会将事件填充至 events_in 内</span></span><br><span class="line">    <span class="comment">// 返回获得的事件数量，若超时且没有任何事件返回0，出错返回 -1。timeout 设置为 -1 表示无限等待。</span></span><br><span class="line">    <span class="keyword">int</span> event_count = epoll_wait(epollfd, events_in, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;event_count; i++) &#123; <span class="comment">// 遍历所有事件</span></span><br><span class="line">        <span class="keyword">if</span> (events_in[i].data.fd == fd) &#123; <span class="comment">// 新连接请求</span></span><br><span class="line">            <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ev.events = EPOLLIN; </span><br><span class="line">            setnonblocking(new_fd);  <span class="comment">// 如果要使用Edge Trigger还需将 new_fd 设为非阻塞</span></span><br><span class="line">            ev.data.fd = new_fd;</span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_ADD, new_fd, &amp;ev); <span class="comment">// 将新连接加入监视列表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 其他的事件处理，如读写事件</span></span><br><span class="line">            <span class="keyword">int</span> new_fd = events_in[i].data.fd;</span><br><span class="line">            <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_DEL, new_fd, <span class="literal">NULL</span>); <span class="comment">// 不再监听fd，最后一个参数被忽略</span></span><br><span class="line">            close(new_fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll 有两种工作模式：LT（level trigger）模式和 ET（edge trigger）模式，也叫水平触发和边沿触发，默认的是 LT 模式</p><ul><li>LT 模式：当 epoll_wait 检测到 fd 事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li><li>ET 模式：当 epoll_wait 检测到 fd 事件发生，只有当 fd 事件变化时，即从 unreadable 变为 readable 或从 unwritable 变为 writable 时，它才返回事件 fd，因此应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此 fd 事件。</li></ul><p><strong>一句话：如果 fd 上有事件发生，LT 模式下会一直通知你，ET 模式只会通知一次。</strong></p><p>因此，如果 epoll 工作在 ET 模式，正确的读写方式应该如下所述，具体描述可以参考<a href="http://kimi.it/515.html" target="_blank" rel="noopener">这篇文章</a>，这里只说结论：</p><blockquote><p>读：只要可读，就一直读，直到返回 0，或者 errno = EAGAIN<br>写：只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN</p></blockquote><p>ET 模式也称为高速模式，在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接字模式，以避免由于一个 fd 的阻塞读/阻塞写操作把处理多个 fd 的任务饿死，如上面代码的第 25 行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnonblocking(new_fd);</span><br></pre></td></tr></table></figure></p><p>epoll 的上述特点，使 I/O 多路复用系统的性能提升到一个新的台阶。当管理的连接数不多时，使用 select/poll 和使用 epoll 的差别不大，但是当连接数上十万百万时，就会发现 epoll 的效率远高于 select/poll。因为在互联网大量并发的连接场景下，实际同一时刻，真正活跃（Active）的连接，其实只占少数，其他的都是空闲（idle）状态。epoll 不遍历所有连接，只对活跃的连接做处理。</p><blockquote><p><strong>需要注意的是：epoll 是 Linux 2.6 内核版本引入，只用于 Linux 平台，BSD 或 MacOS 对应的实现就是 kqueue，Windows 下就是 IOCP</strong>。</p></blockquote><h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><p>实际上，当我们使用 I/O 多路复用时，也很少会直接调用 select/poll/epoll，这样开发周期长，对开发者有较高要求，出问题难以调试，直接使用现有的库会大大降低开发难度，如 libevent，netty 等，他们对于不同的平台底层使用不同的方式，比如你是 MacOS，底层就用 kqueue，如果是 Linux 2.6或更新，则用 epoll。这些库提供了一套统一的 API，好处是允许你的代码在不同平台上运行而不需要改变任何代码，用户只需直接使用即可。</p><h2 id="I-O-多路复用的问题"><a href="#I-O-多路复用的问题" class="headerlink" title="I/O 多路复用的问题"></a>I/O 多路复用的问题</h2><p>细心的同学会发现，I/O 多路复用是单线程的，不能充分利用多核；同时，单线程模型事件处理中，不能有阻塞，一旦发生阻塞，会大大降低该模型性能，甚至不如多线程模型的 BIO ，这就对开发者的技术有更高的要求了。<br>另一方面，基于事件驱动的 I/O 多路复用，仍然属于<strong>阻塞型 I/O</strong>，它会阻塞在等待事件发生的系统调用。</p><h2 id="I-O-多路复用案例"><a href="#I-O-多路复用案例" class="headerlink" title="I/O 多路复用案例"></a>I/O 多路复用案例</h2><p>I/O 多路复用技术，已经在很多高性能软件和系统中得到广泛使用，只要弄明白了 I/O 多路复用的底层原理，也就明白那些优秀的软件为何性能很高了。经典的如 Redis，我们知道 Redis 是一个高性能的缓存服务器，它是单线程的，但它的性能并没有因为单线程而降低，反而特别高效，其中一个很重要的原因就是使用的 I/O 多路复用。在 Redis 内部，将客户端的套接字以文件事件进行抽象，客户端的连接，读写等操作，均会在 Redis 产生相应的文件事件，然后由相应的事件处理器进行处理，而 Redis 的单线程，可以监听成千上万个套接字，从而保证了高效的网络通信。同时，Redis 有良好的跨平台特性，由此我们可以断定，Redis 底层并没有写死使用 epoll 方式，因为那样会限制它只能运行于 Linux 平台，实际上，在我们编译 Redis 时，Redis 会根据平台情况，选择使用最合适的方式。</p><p>再如 Nginx，Nginx 是一款优秀的，抗并发能力很强的 web 服务器，在它的 Worker 进程中，也是通过 kqueue、epoll 等事件通知机制循环处理连接请求，可以使 Nginx 在高并发的情况下，仍然保持较低的 CPU 使用率，同时它也有良好的跨平台特性。nginx 的架构模型可以参考<a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener">这篇文章</a></p><p>再如 Netty，Netty 是 Java 写的高性能网络编程框架，它是 Java NIO 库的进一步封装，大大简化了 NIO 的使用方式，Netty 的网络部分使用了经典的 Reactor 模式，其中的 IO 线程 NioEventLoop 聚合了多路复用器，称为 Selector，根据平台选择不同的 I/O 多路复用，如 kqueue、epoll。同时，它可以搭配线程池使用，每个线程都是一个 Selector，成为多线程的 Reactor 模型。因此它的性能也非常强劲。Netty 的线程模型可以看<a href="https://www.infoq.cn/article/netty-threading-model" target="_blank" rel="noopener">这篇文章</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面，我们讨论了传统的 BIO 模式的弊端，以及 I/O 多路复用的原理和经典使用案例，那么我们以后写网络程序，是不是无脑用 I/O 多路复用呢？得看场景：</p><ul><li>如果你的应用并发量不大，用户的请求连接少，连接不是瓶颈，那么请直接使用 BIO+多线程方式，简单易调试，完全用不着 I/O 多路复用，这样只会增加代码的复杂度，出问题难以调试。</li><li>如果你的应用并发量高，需要同时处理海量的连接，那么请使用 I/O 多路复用方式。但是记住，你必须始终保持异步思想，事件处理中不要有任何阻塞操作。至于是用 select/poll 还是 epoll，请看<a href="http://cxd2014.github.io/2018/01/10/epoll/" target="_blank" rel="noopener">这篇文章</a></li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></li><li><a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll" target="_blank" rel="noopener">https://eklitzke.org/blocking-io-nonblocking-io-and-epoll</a></li><li><a href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html</a></li><li><a href="https://www.zhihu.com/question/20122137" target="_blank" rel="noopener">https://www.zhihu.com/question/20122137</a></li><li><a href="http://kimi.it/515.html" target="_blank" rel="noopener">http://kimi.it/515.html</a></li><li><a href="https://segmentfault.com/a/1190000016875057" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016875057</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在高并发环境下，web 服务器需要处理成千上万的客户端连接，如何最大限度发挥单台机器的性能，使之在处理大量连接时仍保持较低的负载，这是个很重要的课题。本文介绍下解决此类问题的一种很经典的方式：I/O 多路复用。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="select" scheme="http://xujimmy.com/tags/select/"/>
    
      <category term="epoll" scheme="http://xujimmy.com/tags/epoll/"/>
    
      <category term="BIO" scheme="http://xujimmy.com/tags/BIO/"/>
    
      <category term="NIO" scheme="http://xujimmy.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java 中 Future 和异步任务</title>
    <link href="http://xujimmy.com//2019/05/29/java-Future-and-Executor.html"/>
    <id>http://xujimmy.com//2019/05/29/java-Future-and-Executor.html</id>
    <published>2019-05-29T08:12:40.000Z</published>
    <updated>2019-11-08T08:55:08.648Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中的多线程技术一直是个热门话题，而线程池、异步任务是多线程编程中绕不开的一个技术要点，本文介绍下 java 中的 Future 相关使用方法以及任务执行框架 ExecutorService。</p><a id="more"></a><h2 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h2><p>先看一个案例：用多线程输出 1 亿内的所有质数，并要求输出的质数顺序是排好序的。</p><p>如果单纯要完成质数输出，有很多方式，比如将 1 亿数字平均分为 100 份，每份 100 万个，用 100 个线程分别求解质数，每个线程的 run 函数里，打印质数。我们写下这样的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end   = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i += <span class="number">1000000</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                subList.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建线程打印质数</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrimeThread(subList)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span> || num % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= Math.sqrt(num); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们发现，Runnable 中的 run 返回是 void，也就是说，每个线程只能输出结果，而没办法返回结果，因此最终的输出是无序的。有没有办法把这个结果返回呢？答案是肯定的，我们可以用 Callable</p><p>Callable 和 Runnable 的功能类似，但有 3 个不同点：<br>1、Callable 中的 call 是泛型方法，并且有返回值，也会抛出异常，需要对异常进行处理<br>2、Callable 不像 Runnable 可以直接用来 new Thread(new Runnable) 开一个线程，Callable 一般配合线程池使用<br>3、向线程池提交一个 Callable 任务后， 线程池并不是直接给我们返回任务的结果，而是返回一个 Future，通过这个 Future，我们才可以拿到执行结果。</p><h2 id="Future-是什么"><a href="#Future-是什么" class="headerlink" title="Future 是什么"></a>Future 是什么</h2><p>看了上面的描述，可能有同学还是不太理解 Future 是什么，从字面意来看，它是”将来”，但这太抽象了，事实确实如此，从 Future 的源码来看，它是一个接口，接口就是抽象的，它表示的是一个任务的执行情况。为了帮助理解，我们可以把它和<strong>句柄</strong>，或者文件描述符（fd）做类比，假如我们要对文件或者网络设备进行读写，通常会拿到一个句柄，文件的话，通常是文件句柄，网络的话，通常是 socket，调用句柄的 read 和 write 方法即可对文件或 socket 进行读写，类比过来，Future 就是一个表示<strong>任务的句柄</strong>，通过这个“句柄”，我们可以获得任务的执行情况，以及给任务发送一些指令。用一个简单例子来体会下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        String name = <span class="string">"jimmy"</span>;</span><br><span class="line">        <span class="comment">// 用 submit 方法，向线程池提交一个 Callable 任务，submit 返回一个 Future，也就是标识该任务的"句柄"</span></span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> UpperStringTask(name));</span><br><span class="line">        <span class="comment">// get 方法，获取任务的执行结果，如果任务执行过程中出错，会抛出 ExecutionException 异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperStringTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 call 方法，并返回 String</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子是一个很简单的示例，Callable 里执行的也是很简单的任务：将一个字符串转为大写，并返回。返回的结果，可以通过 future.get() 方法获得。可以看到，Callable 的使用方式和 Runnable 基本类似：Runnable 重写 run 方法，Callable 重写 call 方法。这里关键的地方在于，我们不是通过 new 一个 Thread 来启动任务，而是用 ExecutorService 的 submit 方法提交任务，submit 方法返回的也只是 Future，即一个任务的“句柄”，而不是任务结果本身。需要通过 Future 的 get 方法来获得任务结果。如果执行失败或者上面例子，就是将字符串 “jimmy” 转为大写的结果。由于任务的 call 方法返回的是 String 类型，因此 future 也应该是 String，即 <code>Future&lt;String&gt;</code> 。需要提醒的是，get 方法是个阻塞方法，这意味着，如果任务比较耗时，则 get 会一直等待任务执行完成才返回。</p><h3 id="Future-中的方法"><a href="#Future-中的方法" class="headerlink" title="Future 中的方法"></a>Future 中的方法</h3><p>除了 get 方法获得任务执行结果，Future 还有其他方法，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断操作是否已经完成，包括了正常完成、异常抛出、取消</span></span><br><span class="line">future.isDone()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消操作，方式是中断。参数 true 说的是，即使这个任务正在执行，也会进行中断</span></span><br><span class="line">future.cancel(<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否被取消，只有在任务正常结束之前被取消，这个方法才会返回 true</span></span><br><span class="line">future.isCancelled()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面不带参数的 get 方法是阻塞的，会一直等待任务执行完成，也可以给 get 传一个参数，设置超时时间</span></span><br><span class="line">future.get(timeout, TimeUnit)</span><br></pre></td></tr></table></figure></p><p>可以看到，确实可以把 Futuere 想象成任务的句柄，通过这个句柄，获得任务的状态，以及对任务做一些操作。这一点上，Callable 要比 Runnable 灵活许多。</p><p>弄明白了上面简单例子，我们就可以尝试解决文章开头的那个案例了，注释已经说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 表示一批任务执行情况的 future 集合，每个任务的结果是 List&lt;Integer&gt;</span></span><br><span class="line">        List&lt;Future&lt;List&lt;Integer&gt;&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;PrimeTask&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end   = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 1 到 1 亿 分为 100 个区间，每个区间 1000000 个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i += <span class="number">1000000</span>) &#123;</span><br><span class="line">        List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        subList.add(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交一个 PrimeTask 类型的任务，返回的 future 类型是 List&lt;Integer&gt;</span></span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; future = executor.submit(<span class="keyword">new</span> PrimeTask(subList));</span><br><span class="line">        <span class="comment">// 然后将 future 添加到结果集</span></span><br><span class="line">        futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代 future 集合，获取每个任务的执行结果，集合中的 future 顺序和上面提交任务的顺序是一致的，</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Integer&gt;&gt; f : futures) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shtdown();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeTask</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span> || num % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= Math.sqrt(num); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="执行-Runnable-任务"><a href="#执行-Runnable-任务" class="headerlink" title="执行 Runnable 任务"></a>执行 Runnable 任务</h3><p>那么有没有可以执行 Runnable 类型任务的类呢？其实 submit 方法也可以接收一个 Runnable 类型参数，也会返回一个 Future，只不过由于 Runnable 任务没有返回值，因此你用返回的 Future 并调用 Future.get，任务完成后只能得到一个 null。所以，这里的 Future 只能用来查看任务状态，如 Future.isDone，或者取消任务，如 Future.cancel。此外，ExecutorService 继承于 Executor 接口，Executor 有个 execute 方法，这个方法就是用于接收 Runnable 类型的任务，因此我们也可以在 ExecutorService 中使用 execute 方法提交 Runnable，即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际是将 Runnable 任务委托给了父类 Executor 中的 execute</span></span><br><span class="line"><span class="keyword">void</span> ExecutorService.execute(Runnable task);</span><br></pre></td></tr></table></figure></p><p>由于本文主要侧重点在 Future，因此执行 Runnable 的例子不打算介绍了，简单总结下：</p><ul><li>ExecutorService 可以接收 Callable 和 Runnable 类型的任务，使用 submit 方法提交任务，该方法返回任务句柄 Future</li><li>Callable 任务执行完毕后，通过 Future.get 获取任务结果，Runnable 任务执行完后无结果</li></ul><h2 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h2><p>在绝大部分场景下，ExecutorService 都可以满足我们的需要。假设现在有这样一个场景：我们向 ExecutorService 依次提交了 4 个任务 A，B，C，D，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">futures.add(executorService.submit(A));</span><br><span class="line">futures.add(executorService.submit(B));</span><br><span class="line">futures.add(executorService.submit(C));</span><br><span class="line">futures.add(executorService.submit(D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代 futures 获取结果</span></span><br><span class="line"><span class="keyword">for</span> (Future future:futures) &#123;</span><br><span class="line">    Integer result = future.get();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，A 任务特别耗时，而 B，C，D 任务很快就完成了，由于<code>future.get()</code>是阻塞的，因此上面在迭代 future 时，我们不得不等待 A 完成后，即第一个 future.get() 返回后，才能继续拿 B，C，D的结果。这里的主要问题是，当我们提交一个任务集合时，我们事先是不知道集合中哪个任务会先执行完，因此只能拿到一个 future 集合，这个集合的顺序和我们提交任务的顺序一致，然后依次迭代 future 取结果。因此，上面我们求质数，迭代 future 集合时，可能出现这种情况：<strong>后面某个区间的质数已经求解完毕，但前面的区间还没求解完</strong>。由于上面案例需要顺序输出质数，因此我们对 future 顺序迭代取结果。</p><p>再假设一个情况，如果我们提交的是下载任务：从不同的镜像源下载某个安装包。如 ubuntu.iso 文件，A 任务从国外官方官网下，B 任务从 163 镜像站下，C 任务从 ali 镜像站下，哪个任务先下载完就用哪个，并终止其他任务，这时用上述迭代方式就不合适了。</p><p>此时我们可以使用 <strong>ExecutorCompletionService</strong>。相比于 ExecutorService，ExecutorCompletionService 这个类提供了 take 方法，这个方法也会阻塞的等待任务集合执行，一旦集合中有完成的任务，take 就返回，注意，take 返回的是 future，也即已经完成的任务的“句柄”，这时调用 get 方法，即可拿到结果了。从描述来看，take 方法似乎跟 BlockingQueue 里的 take 方法类似，事实也确实如此，ExecutorCompletionService 是在 ExecutorService 的基础上，用一个 LinkedBlockingQueue 队列存 future。一旦有任务完成，就把该任务的 future 放入到 LinkedBlockingQueue 中，<strong>如果说<br>ExecutorService = incoming queue + worker threads，那么<br>ExecutorCompletionService = incoming queue + worker threads + output queue</strong></p><p>使用上，ExecutorCompletionService 也非常容易，ExecutorCompletionService 提供了一个构造方法，可以直接把 ExecutorService 包装成 ExecutorCompletionService，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletionService executorCompletionService= <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executorService);</span><br></pre></td></tr></table></figure></p><p>上面的例子用 executorCompletionService 来改写下，注释说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">CompletionService executorCompletionService= <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executorService);</span><br><span class="line">List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">futures.add(executorCompletionService.submit(A));</span><br><span class="line">futures.add(executorCompletionService.submit(B));</span><br><span class="line">futures.add(executorCompletionService.submit(C));</span><br><span class="line">futures.add(executorCompletionService.submit(D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里就不是迭代 futures 了，而是调用 executorCompletionService 的 take 方法，然后再 get</span></span><br><span class="line"><span class="comment">// 结果的顺序和提交任务的顺序可能不一致，取决于谁先执行完，就先获取谁的结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;futures.size(); i++) &#123;</span><br><span class="line">    Integer result = executorCompletionService.take().get();</span><br><span class="line">    <span class="comment">// 拿到结果，做其他处理</span></span><br><span class="line">    <span class="comment">// doSomeThing()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在再来考虑下上述那个从不同镜像源下载安装包的场景，注释已经说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Executor e, Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 初始化一个 ExecutorCompletionService</span></span><br><span class="line">    CompletionService&lt;Result&gt; ecs = <span class="keyword">new</span> ExecutorCompletionService&lt;Result&gt;(e);</span><br><span class="line">    <span class="comment">// 获得任务总数</span></span><br><span class="line">    <span class="keyword">int</span> n = solvers.size();</span><br><span class="line">    List&lt;Future&lt;Result&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Result&gt;&gt;(n);</span><br><span class="line">    Result result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;Result&gt; s : solvers) &#123;</span><br><span class="line">            futures.add(ecs.submit(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依照任务完成顺序获取结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Result r = ecs.take().get();</span><br><span class="line">                <span class="comment">// 一旦某个任务执行完，终止循环</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = r;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(ExecutionException ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后取消所有任务，对已经完成的任务，执行 cancel 无影响</span></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Result&gt; f : futures)</span><br><span class="line">            f.cancel(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        use(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，上面的两个案例，我们不是迭代 Future 来拿结果，而是用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;task.size; i++)</span><br></pre></td></tr></table></figure></p><p>来迭代的，由于我们对结果的顺序不关心，而且 take 方法是 ExecutorCompletionService 类的，因此不能迭代 Future，而只能迭代个数，Future 个数或者任务个数，所以这里就得小心的处理 take 方法了。如果个数弄错，可能导致队列已经没有任务，但 仍然调用 take，导致一直阻塞。我们可以继承 ExecutorCompletionService，增加一个原子变量属性，每次提交一个任务，变量加 1，最终用这个变量表示任务的个数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Runnable 执行一个不返回结果的任务，Callable 执行一个有返回结果的任务</li><li>可以使用 Executors 的静态方法创建线程池，由线程池来执行任务</li><li>submit 方法用于提交任务，并返回 Future，可以把它当成任务的句柄</li><li>Future 的 get 是阻塞方法，向 ExecutorService 提交多个任务，最终迭代 Future 时，结果的顺序和任务提交的顺序一致</li><li>ExecutorCompletionService 的 take 方法可以获取已完成的任务的 Future，是通过将任务结果放入 BlockingQueue 实现</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://dzone.com/articles/executorservice-vs" target="_blank" rel="noopener">https://dzone.com/articles/executorservice-vs</a></li><li><a href="https://www.javaspecialists.eu/archive/Issue214.html" target="_blank" rel="noopener">https://www.javaspecialists.eu/archive/Issue214.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中的多线程技术一直是个热门话题，而线程池、异步任务是多线程编程中绕不开的一个技术要点，本文介绍下 java 中的 Future 相关使用方法以及任务执行框架 ExecutorService。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="java" scheme="http://xujimmy.com/tags/java/"/>
    
      <category term="异步任务" scheme="http://xujimmy.com/tags/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>git pull 和 git rebase</title>
    <link href="http://xujimmy.com//2019/04/23/git-pull-and-git-rebase.html"/>
    <id>http://xujimmy.com//2019/04/23/git-pull-and-git-rebase.html</id>
    <published>2019-04-23T08:13:18.000Z</published>
    <updated>2019-11-08T08:55:08.648Z</updated>
    
    <content type="html"><![CDATA[<p>git 是团队开发中常用的代码版本管理工具，我们经常会遇到这样一个场景：在 feature 分支上开发完一个新功能后，通常会做这样的操作：<code>git pull</code>，然后<code>git push</code>。但也有人喜欢在<code>git pull</code>后面再上<code>--rebase</code>参数，即<code>git pull --rebase</code>，这是什么意思呢？<br><a id="more"></a></p><p>我们知道，<strong>git pull = git fetch + git merge</strong>，即首先将本地的分支信息更新以和远程保持同步，然后将再将远程分支合并到本分支。而 <strong>git pull –rebase = git fetch + git rebase</strong>。可以看到，<code>git pull</code>和<code>git pull --rebase</code>的区别，就是<code>git merge</code>和<code>git rebase</code> 的区别，跟<code>git merge</code>相比，<code>rebase</code>主要有下面几点不同：</p><ul><li>让多个人在一个分支开发的提交点形成一条线，而不是多条线，从而保持分支的整洁</li><li><code>rebase</code>参数，让你的 commit 在该分支最前面，</li><li>分支上不会有合并的提交记录</li></ul><p>可能有同学对上面的解释还是不明白，那我们看看下面的提交树来直观感受下（提交图形化工具为 <a href="https://github.com/jonas/tig" target="_blank" rel="noopener">tig</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-04-22 20:12 +0800 jimmy M─┐ [master] Merge branch &apos;feature_dev&apos;</span><br><span class="line">2019-04-22 20:07 +0800 jimmy │ o [feature_dev] commit on feature_dev 2</span><br><span class="line">2019-04-22 20:07 +0800 jimmy │ o commit on feature_dev 1</span><br><span class="line">2019-04-22 20:08 +0800 jimmy o │ commit on master 4</span><br><span class="line">2019-04-22 20:08 +0800 jimmy o │ commit on master 3</span><br><span class="line">2019-04-22 20:06 +0800 jimmy o─┘ commit on master 2</span><br><span class="line">2019-04-22 20:06 +0800 jimmy I   commit on master 1</span><br></pre></td></tr></table></figure></p><p>上面展示的是一个 git 项目的提交记录数，该项目有两个分支：master 和 feature_dev，从下往上看，master 分支上有 4 次提交记录，分别是 commit on master 1-4，feature_dev 分支上有两次提交，分别是 commit on feature_dev 1-2，最上面的那次提交，是在 master 上执行<code>git merge feature_dev</code>产生的一次提交，从<code>M</code>标识也可以看出这是一次合并操作，可以看到，现在总共有 7 次提交记录，同时我们也注意到，虽然 master 上的第 3 次提交和第 4 次提交时间比 feature_dev 上的两次提交要晚，但合并后，feature_dev 上的提交却在上面。</p><p>如果我们使用<code>git rebase feature_dev</code>呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-04-22 20:08 +0800 jimmy o [master] commit on master 4</span><br><span class="line">2019-04-22 20:08 +0800 jimmy o commit on master 3</span><br><span class="line">2019-04-22 20:07 +0800 jimmy o [feature_dev] commit on feature_dev 2</span><br><span class="line">2019-04-22 20:07 +0800 jimmy o commit on feature_dev 1</span><br><span class="line">2019-04-22 20:06 +0800 jimmy o commit on master 2</span><br><span class="line">2019-04-22 20:06 +0800 jimmy I commit on master 1</span><br></pre></td></tr></table></figure></p><p>上面就是在 master 上执行了<code>git rebase feature_dev</code>后的提交记录，可以看到，此时的提交记录都在一条线上了，就像是直接把 feature_dev 上的那两次提交插入到 master 上一样，更有意思的是，现在只有 6 次提交记录了，没有因为合并而产生的提交记录，事实上，合并的提交记录通常是无意义的。再回过头来，看看上面说的 3 点区别，是不是更加明朗呢？</p><p>需要注意的是，上面的演示，并没有展示代码冲突的场景，这在实际开发过程中是很常见的，不过，即使遇到了也不要慌，git 一个很好的优点是，如果你哪一步操作有问题，都会给出友好的提示，如上面你执行<code>git pull --rebase</code>后遇到冲突，会给出类似如下提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict in &lt;some-file&gt;</span><br></pre></td></tr></table></figure></p><p>跟之前套路一样，把冲突的文件解决下，然后执行<code>git add &lt;some-file&gt;</code>和 <code>git rebase --continue</code>即可，跟使用<code>git pull</code>基本一致。</p><p>总结下，<code>git pull</code>和<code>git pull --rebase</code>二者的最终目的一致，主要区别在于提交记录上，或者说执行<code>git log --oneline --decorate --graph --all</code>后，二者看到的提交树不一样，加上<code>--rebase</code>参数后，项目分支整洁了，即使有多个人在该分支上开发，最终看到的提交记录也只有一条线， 而且每个提交都是有意义的。反过来，也简化了哪里引入 Bug 的分析，如果有必要，回滚修改也可以做到对项目影响最小。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md" target="_blank" rel="noopener">https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md</a></li><li><a href="https://www.cnblogs.com/xueweihan/p/5743327.html" target="_blank" rel="noopener">https://www.cnblogs.com/xueweihan/p/5743327.html</a></li><li><a href="https://my.oschina.net/gef/blog/2978848" target="_blank" rel="noopener">https://my.oschina.net/gef/blog/2978848</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 是团队开发中常用的代码版本管理工具，我们经常会遇到这样一个场景：在 feature 分支上开发完一个新功能后，通常会做这样的操作：&lt;code&gt;git pull&lt;/code&gt;，然后&lt;code&gt;git push&lt;/code&gt;。但也有人喜欢在&lt;code&gt;git pull&lt;/code&gt;后面再上&lt;code&gt;--rebase&lt;/code&gt;参数，即&lt;code&gt;git pull --rebase&lt;/code&gt;，这是什么意思呢？&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="git" scheme="http://xujimmy.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Docker 和 KVM 虚拟机</title>
    <link href="http://xujimmy.com//2019/04/04/docker-and-vm.html"/>
    <id>http://xujimmy.com//2019/04/04/docker-and-vm.html</id>
    <published>2019-04-04T08:13:18.000Z</published>
    <updated>2019-11-08T08:55:08.648Z</updated>
    
    <content type="html"><![CDATA[<p>近几年，随着微服务概念和容器化思想的风(chao)靡(zuo)，Docker 技术成了各大厂和各种吹牛大会上的香饽饽，一提到 Docker，就是各种优势，大有在云计算领域一统江湖的趋势。但是 Docker 真的是万精油吗？本文简单介绍下 Docker 的一些底层技术，以及和传统虚拟机的一些差异。</p><h2 id="开局一张图"><a href="#开局一张图" class="headerlink" title="开局一张图"></a>开局一张图</h2><p>我们先来看一张图<br><img src="/images/vm/vm-vs-docker.png" alt="图1"></p><p>这里先不解释上图的含义，等介绍完下面内容，再回过头看。</p><h2 id="为什么需要-Docker-这类技术"><a href="#为什么需要-Docker-这类技术" class="headerlink" title="为什么需要 Docker 这类技术"></a>为什么需要 Docker 这类技术</h2><p>对于应用程序开发和测试工作者来说，经常会遇到这样的场景：在开发环境下运行得好好的应用，部署到测试环境时就出问题，一会儿缺个目录，一会儿少个包，比如运行 Java，得装对应版本的 JDK，设置环境变量等。而有了 Docker，一切就简单了，首先开发机和测试机都安装好 Docker，开发把要测试的 App 和需要的库、依赖等，打成一个 Docker image，交付给测试，测试拿到这个 image，只需一个命令<code>docker run</code>，一个容器就运行起来，应用也就在测试环境跑起来了，如果测得没有问题，就可以拿这个 image 部署到生产环境了。整个过程中，不管有多少测试环境，只要大家拿的是相同的 image，就不会出现因为环境不同而导致应用无法运行。而升级也非常简单，停掉老容器，运行新容器。这就是 Docker 最大的优点，<strong>你只需要关注应用本身，而不需要关注应用之外的依赖和环境。</strong> 将应用程序打包成一个镜像，然后以容器的方式运行，Docker 的这个思想，大大提高了应用的开发效率，降低了运维成本。</p><h2 id="运行-Docker-需要的内核技术"><a href="#运行-Docker-需要的内核技术" class="headerlink" title="运行 Docker 需要的内核技术"></a>运行 Docker 需要的内核技术</h2><p>上面我们说，使用 Docker 后，就不需要关心执行环境的问题了，也就是表明，容器中的 Java 程序，用的是打包在容器中的 JDK1.8，而不会是宿主机上装的 JDK1.5，容器的执行环境和宿主机是隔离开的。那么，Docker 是怎么实现宿主机和容器的环境隔离呢？又有哪些东西是需要隔离的呢？</p><p><strong>Docker 通过命名空间(namespace) 机制来实现隔离，而 Linux 内核提供了 6 种 namespace 隔离的系统调用</strong>，我们知道，通过<code>fork()</code>系统调用可以创建新进程，而<code>clone()</code>则是创建新进程的一种更通用的方式，其原形如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure></p><p>注意到其中有个 flags 的参数，调用<code>clone()</code>在创建新进程时，flags 支持传入类似型如 CLONE_* 的参数，使创建的进程有不同的独立的 namespace，达到隔离的目的。有 6 种 namespace 的名称、使用的参数、以及隔离效果如下：</p><table><thead><tr><th>命名空间</th><th>系统调用参数</th><th>隔离内容</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>隔离主机名和域名，传入这个参数，新进程有自己的主机名了</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>隔离信号量，消息队列和共享内容，新进程无法通过信号量的方式感知命名空间外的进程</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>隔离进程编号，新进程的 pid 和 宿主机 pid 是独立开了</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>隔离网络设备，网络栈，端口等，进程有了自己的网络资源、端口</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>挂载点，进程可以有自己的文件系统</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>隔离用户和用户组</td></tr></tbody></table><p>上表中的多个参数支持<code>与</code>操作，这样我们创建出的新进程就可以隔离多项内容。<br>上述这 6 种命名空间，将 Linux 命名空间中的进程和命名空间外的进程区分开来，位于同一个命名空间中的进程可以感知各自存在，而且会认为这个命名空间就是整个世界环境，对命名空间外的一切是一无所知的，这样就达到了隔离目的。Docker 本质上就是一个使用 Linux 命名空间技术，来达到“虚拟化”的效果。</p><p>既然 Docker 大法这么好，那为何还要有 KVM 这一类虚拟机呢？</p><h2 id="KVM-虚拟机"><a href="#KVM-虚拟机" class="headerlink" title="KVM 虚拟机"></a>KVM 虚拟机</h2><p>大多数朋友可能都有过在自己 Windows 电脑上装 VMWare 或者 VirtualBox 跑虚拟机的经历，运行虚拟机前，需要准备一个 ISO 镜像，然后让你选择给虚拟机分配多大内存，多大磁盘等，一切准备好后，启动虚拟机，就可以看到熟悉的装机界面了，接下来就和在物理机上装系统一样。</p><p>在 Linux 环境下，我们也有相应的虚拟化解决方案——QEMU/KVM，同样，我们创建虚拟机前，也要准备好镜像，以及定义好虚拟机的各种规格等。注意，这里说的镜像和上文 Docker 中的镜像是两个完全不同的概念，这里的镜像就是我们平时装操作系统用的镜像，里面只包括了引导程序和操作系统，而且装好后，这个镜像就不用了；而上文说的 Docker 镜像，是一个运行 App 和依赖库的最小包，或者把它理解成一个 zip 包。每次运行容器，都需要这个镜像。从创建 KVM 虚拟机的过程来看，显然它对虚拟机的各种资源有更详细的描述，基本等同于创建了一个“物理机”了，毕竟物理机有的它都有。</p><p>这里不打算讨论 Win 平台下的虚拟化，我们着重看下 Linux 下的虚拟化。最常见的虚拟化组合就是 QEMU/KVM 了。QEMU 是一款开源的模拟器和虚拟机监视器（Virtual Machine Monitor, VMM）。QEMU 主要提供两个功能给用户使用：</p><ul><li>作为用户态模拟器：通过动态代码翻译机制来执行不同架构的代码，例如在 X86 平台上模拟 ARM 平台下执行环境。</li><li>作为虚拟机监视器：模拟全系统，利用其它 VMM（如 Xen，KVM等等）来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。</li></ul><p><strong>从上面描述我们可以看到，QEMU 其实是一个纯软件实现的虚拟机模拟器，但虚拟化效率很低，因此配合 KVM 等一类 VMM，利用 KVM 提供的硬件加速，使得在 QEMU 中运行的 CPU 指令，直接在宿主机的物理 CPU 上执行，使虚拟机的性能更高。</strong>KVM 已经是 Linux 平台下的一个内核模块了，它本身不实现任何模拟，运行于内核空间，仅仅是暴露了一个 /dev/kvm 接口，由运行于用户空间的 QEMU 与之交互。当虚拟机有 CPU 操作时，QEMU 将指令转交给 KVM 模块，而 IO 仍然由 QEMU 来完成。因此，由 QEMU/KVM 组合创建的虚拟机，被称为 KVM 虚拟机。</p><p>KVM 的基本架构可以用下图来表示<br><img src="/images/vm/kvm.png" alt="图2"></p><p>运行一个 KVM 虚拟机不像运行一个 Docker 那么简单，除了要安装好一系列包，还得检查你机器的 CPU 是否在硬件上支持虚拟化扩展特性参数，具体的可以参考 <a href="https://opengers.github.io/virtualization/kvm-libvirt-qemu-1/" target="_blank" rel="noopener">这篇文章</a>。</p><p>一个 KVM 虚拟机运行起来后，从宿主机的角度来看，它就是一个标准的 Linux 进程，具体来讲，是 QEMU 进程。可以通过命令行虚拟机管理工具 virsh 来对虚拟机进行开机关机等操作。</p><h2 id="二者的比较"><a href="#二者的比较" class="headerlink" title="二者的比较"></a>二者的比较</h2><p>从图1和上面的讨论，我们看到，Docker 只是一种 Linux 容器(LXC，Linux Container)，容器是什么？和虚拟机一样，本质上都是 Linux 系统中的一个进程。Docker 和虚拟机的生命周期，都是在宿主机上完成，但二者也有显著的差别。</p><p>首先是二者的实现方式，上面我们说 Docker 是 Linux 容器，这决定了，Docker 只能运行于 Linux 系统，看到这里，可能有人会说，我的 Windows 上，Mac 上现在也跑着 Docker 呢，但是请注意，这都是通过软件技术做的一些障眼法，如 Boot2Docker，它使 Docker 客户端运行在用户的操作系统，但仍然起了一个 Linux 虚拟机，上面跑着 Docker deamon 服务，还是脱离不了 Linux，这种方式比直接在 Linux 上运行 Docker, 无疑更加复杂，也丧失了 Docker 的方便性和灵活性。此外，LXC 决定了我们起一个容器，容器中只能是 Linux 平台的应用，不可能运行 Windows 平台下的程序，而 KVM 虚拟机是一种硬件全虚拟化的解决方案，不受此限制，在 Linux 机器上，我们仍然可以虚拟化出一个 Windows 系统，并运行对应平台的程序。</p><p>其次，从图1我们看到，一个宿主机上的所有的容器，都是共享宿主机的操作系统内核，这决定了，Docker 的隔离性要比 KVM 类的虚拟机弱。如果宿主机内核出了问题，这将影响其上的所有 Docker 容器。</p><p>在大规模部署和资源调度方面，Docker 和虚拟机都有成熟的方案，Docker 领域有比较流行的 K8S，Mesos 等框架，开源社区活跃；虚拟机领域著名的有 openstack，以及一些企业自研的调度平台，从热门话题来看，显然 Docker 要更胜一筹。</p><h2 id="二者的定位"><a href="#二者的定位" class="headerlink" title="二者的定位"></a>二者的定位</h2><p>站在云计算的视角来看，KVM 虚拟机，属于 IaaS 层面产品，它给用户提供的是一套完整的基础设施，用户可以拿虚拟机做任何用途，跑运算，做 Web 服务等；而 Docker，更像是 PaaS 层的产品，它提供了一个特定的软件运行的环境，用户拿到一个 Redis 的 Docker image，那么只能跑数据库服务，而不可能跑 Web 服务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每个新技术的出现，都是为了解决特定的问题，Docker 和 KVM 虚拟机，在大的方面上，都是为了提高效率，最大化的利用物理资源。Docker 在构建、部署方面，有着虚拟机无法比拟的优势，虚拟机在云计算领域，有更广的发挥空间。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/" target="_blank" rel="noopener">https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/</a></li><li><a href="https://woshijpf.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96/2018/11/21/QEMU-KVM-%E5%8E%9F%E7%90%86%E7%BB%BC%E8%BF%B0.html" target="_blank" rel="noopener">https://woshijpf.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96/2018/11/21/QEMU-KVM-%E5%8E%9F%E7%90%86%E7%BB%BC%E8%BF%B0.html</a></li><li><a href="https://www.jianshu.com/p/03d3afff3b5f" target="_blank" rel="noopener">https://www.jianshu.com/p/03d3afff3b5f</a></li><li><a href="https://blog.opskumu.com/kvm-notes.html" target="_blank" rel="noopener">https://blog.opskumu.com/kvm-notes.html</a></li><li><a href="https://opengers.github.io/virtualization/kvm-libvirt-qemu-1/" target="_blank" rel="noopener">https://opengers.github.io/virtualization/kvm-libvirt-qemu-1/</a></li><li>《容器与容器云》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近几年，随着微服务概念和容器化思想的风(chao)靡(zuo)，Docker 技术成了各大厂和各种吹牛大会上的香饽饽，一提到 Docker，就是各种优势，大有在云计算领域一统江湖的趋势。但是 Docker 真的是万精油吗？本文简单介绍下 Docker 的一些底层技术，以及和
      
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="docker" scheme="http://xujimmy.com/tags/docker/"/>
    
      <category term="虚拟机" scheme="http://xujimmy.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="KVM" scheme="http://xujimmy.com/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 中常用的监控和故障处理命令行工具</title>
    <link href="http://xujimmy.com//2019/02/24/java-analyzer-tools.html"/>
    <id>http://xujimmy.com//2019/02/24/java-analyzer-tools.html</id>
    <published>2019-02-24T08:13:18.000Z</published>
    <updated>2019-11-08T08:55:08.648Z</updated>
    
    <content type="html"><![CDATA[<p>我们常常需要获取 Java 程序运行过程中的一些执行情况，如执行路径，GC 情况，堆栈信息等。JDK 给我们提供了一些简单但却很有用的命令行工具，本文介绍下这些工具的使用和参数说明，用于备忘。<br><a id="more"></a></p><h3 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps: 虚拟机进程状况工具"></a>jps: 虚拟机进程状况工具</h3><p>这个命令和 Linux 下 ps 命令类似，可以理解为 Java 中的进程查看命令，这条命令最主要的功能就是看虚拟机的 ID 号，而这个 ID 号和操作系统中的 PID 是一致的，很多工具，都需要提供 PID 才能做进一步分析，因此，这个命令一般是查问题时第一个会用到的命令。jps 命令有以下这些参数可用：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出虚拟机 ID 号，不看其他东西</td></tr><tr><td>-m</td><td>输出虚拟机启动时传给主类 main() 函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果是 jar 包，输出 jar 路径</td></tr><tr><td>-v</td><td>输出虚拟机启动时的 JVM 参数</td></tr></tbody></table><p>某次 jps 执行样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~ # jps -mlv</span><br><span class="line">3155 sun.tools.jps.Jps -mlv -Denv.class.path=/root/apache-jmeter-5.0/lib/ext/ApacheJMeter_core.jar:/root/apache-jmeter-5.0/lib/jorphan.jar:/root/apache-jmeter-5.0/lib/logkit-2.0.jar: -Dapplication.home=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64 -Xms8m</span><br><span class="line">25054 org.apache.catalina.startup.Bootstrap start -Djava.util.logging.config.file=/usr/local/zstack/apache-tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.net.preferIPv4Stack=true -Dcom.sun.management.jmxremote=true -Djava.security.egd=file:/dev/./urandom -Xms512M -Xmx4096M -agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n -Djava.endorsed.dirs=/usr/local/zstack/apache-tomcat/endorsed -Dcatalina.base=/usr/local/zstack/apache-tomcat -Dcatalina.home=/usr/local/zstack/apache-tomcat -Djava.io.tmpdir=/usr/local/zstack/apache-tomcat/temp</span><br></pre></td></tr></table></figure></p><h3 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat: 虚拟机统计信息监视工具"></a>jstat: 虚拟机统计信息监视工具</h3><p>这个命令用于监视虚拟机各种运行状态信息，在无 GUI，只有纯命令行的服务器上，它是运行期定位虚拟机性能问题的首选工具，jstat 命令格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat option vmid interval count</span><br></pre></td></tr></table></figure></p><p>其中 interval 和 count 表示查询间隔和次数，如果省略，则只查询一次，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 9527 250 20</span><br></pre></td></tr></table></figure></p><p>表示每250ms 查询一次进程为 9527 的垃圾收集情况，共查询 20 次。选项 option 可以有下面这些</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类装载，卸载数量，总空间以及类装载所耗费时间</td></tr><tr><td>-gc</td><td>监视 Java 堆情况，包括 Eden 区，两个 survivor 区，老年区，永久代的容量，已用空间，GC 时间合计等信息</td></tr><tr><td>-gcnew</td><td>监视新生代 GC 状况</td></tr><tr><td>-gcold</td><td>监视老年代 GC 状况</td></tr><tr><td>-gcpermcapacity</td><td>监视永久代使用的最大、最小空间</td></tr></tbody></table><p>如某次 jstat 执行样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~ # jstat -gcutil 25054 1000 10</span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">4.03   0.00  86.89  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br><span class="line">4.03   0.00  86.89  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br><span class="line">4.03   0.00  86.89  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br><span class="line">4.03   0.00  86.89  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br><span class="line">4.03   0.00  87.08  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br></pre></td></tr></table></figure></p><p>上面结果表明：新生代 Eden 区（E，表示 Eden）使用了 86.89% 的空间，Survivor0 区（S0）使用了 4.03%，Survivor1 区（S1）是空的，老年代（O）使用了 52.67%。元空间（M，表示 Metaspace，可以理解为 Java 8 以前的 P，永久代）使用了 98.03%。压缩使用比例（CCS）为 96.14%。从启动到采集时，共发生 Minor GC（YGC，表示 Young GC）42 次，总耗时（YGCT） 82.191 秒，发生 Full GC（FGC）3 次，总耗时（FGCT） 6.057 秒，所有 GC 总耗时（GCT）88.247 秒。</p><h3 id="jmap-内存映像工具"><a href="#jmap-内存映像工具" class="headerlink" title="jmap: 内存映像工具"></a>jmap: 内存映像工具</h3><p>这个命令用于生成堆转储快照，也称为 heapdump 或 dump 文件，当然还可以通过 -XX:+HeapDumpOnOutOfMemoryError 参数，让虚拟机在 OOM 异常时自动生成 dump 文件。jmap 命令使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap option vmid</span><br></pre></td></tr></table></figure></p><p>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapfile.bin 9527</span><br></pre></td></tr></table></figure></p><p>表示以二进制格式，生成名为 heapfile 的 dump 文件，9527 为 JVM 的 ID，也即 PID。有了这个 dump 文件，就可以使用下面的 jhat 工具来分析了。</p><h3 id="jhat：堆转储快照分析工具"><a href="#jhat：堆转储快照分析工具" class="headerlink" title="jhat：堆转储快照分析工具"></a>jhat：堆转储快照分析工具</h3><p>这个命令和上面的 jmap 配合使用，使用方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat heapfile.bin</span><br></pre></td></tr></table></figure></p><p>jhat 会起一个 server，通过浏览器就可以访问分析结果。不过，一般也很少用 jhat 来分析 dump 文件，首先是 jhat 提供的功能还相对简陋，现在有更多先进的工具，如<a href="https://visualvm.github.io/" target="_blank" rel="noopener">VisualVM</a> 来分析；其次分析 dump 文件是一个耗时又耗硬件资源的工作，一般会把 dump 文件从生产服务器拷贝到其他机器来分析。</p><h3 id="jstack：堆栈跟踪工具"><a href="#jstack：堆栈跟踪工具" class="headerlink" title="jstack：堆栈跟踪工具"></a>jstack：堆栈跟踪工具</h3><p>这个命令用来生成虚拟机当前时刻的线程快照，也称为 threaddump 或 javacore 文件，除了 jstack 命令，还有很多其他方式也可以获取线程快照，如<a href="https://community.oracle.com/blogs/ramlakshmanan/" target="_blank" rel="noopener">这里</a>介绍的方法。线程快照就是当前虚拟机内每条线程正在执行的方法堆栈集合，有了线程快照，就可以定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源长时间等待等，都是造成线程长时间停顿的常见原因。线程出现停顿时，通过 jstack 来查看各个线程调用堆栈，就可以知道没有响应的线程到底在后台做什么，或者等待什么。<br>使用方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack option vmid</span><br></pre></td></tr></table></figure></p><p>其中 option 可以有如下选项</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当 jstack vmid 无响应是，-F 强制生成thread dump</td></tr><tr><td>-l</td><td>除堆栈信息，还打印出锁的附加信息</td></tr><tr><td>-m</td><td>打印除 java 堆栈外，还打印本地方法的帧</td></tr></tbody></table><p>jstack 命令会将堆栈信息直接返回，不会生成文件，因此一般也会把 jstack 打印的堆栈信息重定向到文件，然后直接用其他工具分析，如上文提到的 VisualVM，或一些<a href="https://fastthread.io/" target="_blank" rel="noopener">在线分析网站</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是一些常见分析 JVM 和故障处理的工具，这些工具看似简单，但真正用好却非易事，事实上，一个线上 OOM 问题，除了熟练使用好这些工具外，还需要大量的实战经验，这些不是一朝一夕能获得的，需要日常工作中总结和锻炼。</p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li>《深入理解 Java 虚拟机》</li><li><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">https://www.cnblogs.com/paddix/p/5309550.html</a></li><li><a href="http://www.importnew.com/29891.html" target="_blank" rel="noopener">http://www.importnew.com/29891.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常常需要获取 Java 程序运行过程中的一些执行情况，如执行路径，GC 情况，堆栈信息等。JDK 给我们提供了一些简单但却很有用的命令行工具，本文介绍下这些工具的使用和参数说明，用于备忘。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="Java" scheme="http://xujimmy.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://xujimmy.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的同步方法</title>
    <link href="http://xujimmy.com//2018/10/22/java-concurrent.html"/>
    <id>http://xujimmy.com//2018/10/22/java-concurrent.html</id>
    <published>2018-10-22T08:12:40.000Z</published>
    <updated>2019-11-08T08:55:08.647Z</updated>
    
    <content type="html"><![CDATA[<p>说到 java 中的同步，必然少不了耳熟能详的<code>synchronized</code>，<code>ReentrantLock</code>，以及可能用过但不怎么常见的<code>Atomic</code>，<code>volatile</code>，本篇即简单介绍下他们的区别和使用场景。</p><a id="more"></a><h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><p>首先要明确一个事实：同步是为了解决多线程的并发问题，但并不是说只要有多线程，就一定会有并发问题。多线程环境下，如果你只是调用了一些方法，但没有访问共享的变量或内存，就不存在并发问题，注意：一定是<strong>共享的变量或内存</strong>。在 java 里，这样的变量一般是在堆和方法区中存在，他们可以被多个线程同时访问到。<strong>换句话说，堆和方法区中的变量，需要考虑并发问题，比如并发访问某个对象的实例属性，静态属性，还有数组的元素等，就是典型的需要考虑并发问题场景。而方法的参数，方法体中定义的局部变量是放在栈上的，属于线程私有，可以不用考虑并发问题。</strong>举个例子，看下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variables</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> c)</span>:</span></span><br><span class="line"><span class="function">       <span class="keyword">int</span> d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面定义的类，其中，a 变量是类的静态变量，属于类变量，存放在方法区，b 是成员变量，存放在堆中，而 c 和 d 是局部变量，存放在栈中，因此多线程环境下，对 a 和 b 的操作需要考虑并发问题，而 c 和 d 的操作，则不需要考虑。</p><p>那么并发问题需要解决什么呢？通常，解决的问题有三个：<strong>原子性</strong>，<strong>可见性</strong>，<strong>有序性</strong></p><ol><li><p>原子性：<br> 即一个操作或者多个操作，是一个不可分割的部分，要么全部执行成功并且执行的过程不会被任何因素打断，要么就都不执行。这个很好理解，一般教科书上，都会引用银行转账的例子，来说明原子性。即扣钱操作和加钱操作应该是不可分割的，不能出现钱扣了，但对方没收到钱，或者收到钱了，但钱没扣。在数据库事务中，也会看到原子性的影子。</p></li><li><p>可见性：<br>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。一般计算机 CPU 都会有高速缓存，当某个线程对一个变量进行修改，修改后的值不会马上写入到主存，而是会放入到执行该线程的 CPU 高速缓存中。这样可能导致其他 CPU 上的线程看不到这个变量的修改，因为它读的仍然是自己 CPU 上的高速缓存里的值。</p></li><li><p>有序性：<br> 即程序执行的顺序按照代码的先后顺序执行。我们在写一段代码，当 JVM 执行该代码时，并不一定会按照我们代码写的先后顺序去执行，可能会发生指令重排序。什么是指令重排序？一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p></li></ol><p><strong>要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong>那么怎么保证这三点呢？</p><h2 id="同步的方法"><a href="#同步的方法" class="headerlink" title="同步的方法"></a>同步的方法</h2><p>我们看看下面几段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count.getAndIncrement();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上的三个 increment 方法，均是对 count 字段做加 1 操作，哪些可以在并发场景下正确运行？看完这篇文章，相信大家能回答这个问题。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code>属于 java 中的关键字，是最常用的锁，也是一种独占锁，或者称为互斥，这意味着，<strong>当你使用<code>synchronized</code>关键字对代码进行同步后，如果有多个线程想执行这段代码，这些线程会变成串行</strong>，即如果当前有线程在执行这段代码，其他的线程只能等待。<code>synchronized</code>可以保证并发编程中要求的原子性，可见性和有序性。</p><p>对于同步代码块，<code>synchronized</code>是通过获取对象的监视锁，即<code>monitor</code>来实现同步，java 中，每个对象都有一个<code>monitor</code>，或者称为监视器，被<code>synchronized</code>包裹的代码编译成字节码后，会在代码块前后，引入<code>monitorenter</code>和<code>monitorexit</code>的字节码来实现的，JVM 规定，当<code>monitor</code>被占用时，代码块即会处于锁定状态，其他线程无法访问。像<code>wait/notify</code>等方法也依赖于<code>monitor</code>。对于同步方法，JVM 是采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步的，即一个线程想调用某方法，会检查是否有<code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后才能执行方法。</p><p>在类的任意位置都可以使用<code>synchronized</code>对想要同步的代码进行同步，如类的实例方法，静态方法，实例对象，Class 对象，代码块等。在上例中，我们对 Sample 类的静态方法 increment() 做了同步，锁住的是当前的 Sample 类对应的 class 对象，再来看看<code>synchronized</code>在代码中不同位置的使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCounter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  Object syncObj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步静态方法，锁住的是 SyncCounter.class对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticIncrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (syncObj) &#123;</span><br><span class="line"><span class="comment">// doSomething();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，分别在不同的地方使用了<code>synchronized</code>。为了执行 doSomething，必须获得对象 syncObj 的锁，syncObj 可以是类实例或者是类，典型的如 this，当两个并发线程访问同一个对象 object 中的这个 synchronized(this)同步代码块时，同一时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。但仍然可以访问该 object 中的非synchronized(this)同步代码块。 </p><p>同时，<code>synchronized</code>也是一个可重入锁，即如果一个线程持有了对象锁，那么当它再次想访问锁住的临界资源时，将可以成功。</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>提到<code>volatile</code>，一般都会提到可见性，所以在处理同步问题上它大显作用，那么<code>volatile</code>是如何保证可见性的呢？ 当对<code>volatile</code>变量做写入操作时，在 JVM 字节码中，你会看到一条 lock 前缀的指令，这是告诉 CPU，请立即将这个变量写入到主内存，以保证其他 CPU 重新从内存中读取这个新值，然后放入自己的缓存，这样就保证了可见性。 </p><p><code>volatile</code>的开销比 <code>synchronized</code>小、使用成本更低。但<code>volatile</code>只能用来修饰变量，而不能修饰方法或者代码块，可以把<code>volatile</code>看做是一个轻量级的<code>synchronized</code>，但仅此而已，<code>synchronized</code>不仅保证可见性，还能保证原子性，而<code>volatile</code>是不能保证原子性的。它不适合在对该变量的写操作依赖于变量本身自己。举个最简单的栗子：在进行计数操作时，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count++</span><br></pre></td></tr></table></figure></p><p>实际是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count= count + 1;</span><br></pre></td></tr></table></figure></p><p>count 最终的值依赖于它本身的值。所以使用<code>volatile</code>修饰的变量在进行这么一系列的操作的时候，仍然会有并发的问题。而像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag = true;</span><br></pre></td></tr></table></figure></p><p>这样的语句，由于 flag 的值不会依赖自身，因此这种情况下，<code>volatile</code>可以代替<code>synchronized</code>。通常来说，如果一个变量被声明为<code>volatile</code>，仅仅是表明：</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了这个变量的值，这新值对其他线程来说是立即可见的</li><li>禁止进行指令重排序</li></ol><p>而要使用<code>volatile</code>，必须具备以下2个条件：</p><ol><li>对变量的写操作不依赖于当前值，如像上面那样，给一个标志变量 flag 赋值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li></ol><p>其他情况下，仍然是需要用<code>synchronized</code>的。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>上面说的<code>synchronized</code>，是一个严格的排它锁，一方面，没有抢到锁的线程，会一直等待锁的释放；另一方面，当锁释放时，所有的线程都会参与争抢。如果我们需要一种遵守“先来后到”规则的公平锁，或者想给那些等待锁的线程一个超时时间，<code>synchronized</code>就无法满足需求了，这时可以使用<code>ReentrantLock</code>，在基本用法上，<code>ReentrantLock</code>和<code>synchronized</code>很相似，前者是一个实现了<code>Lock</code>接口的可重入锁，因此需要调用 lock() 和 unlock() 来完成锁的申请和释放，重要的是，<code>ReentrantLock</code>具备几个<code>synchronized</code>没有的高级功能：<strong>等待可中断</strong>，<strong>公平锁</strong>，<strong>绑定多个条件</strong>。而在性能上，二者却基本没有什么差别，<code>ReentrantLock</code>甚至比<code>synchronized</code>更优一点。</p><p>那么是不是说可以抛弃<code>synchronized</code>，而只用<code>ReentrantLock</code>呢？不然，首先，在使用方式上，<code>synchronized</code>更简洁紧凑，用户几乎不用关心锁的释放，即使是被同步的代码中抛出了异常，也可以自动释放锁。而<code>ReentrantLock</code>在同步结束后，需要显示的调用 unlock()，通常会在 finally 块中调用。其次，<code>synchronized</code>为许多开发者所熟悉，并且许多程序框架已经使用了它，如果将两种机制混合，既容易使人迷惑，也容易发生错误。因此，除非你有特别的理由，而<code>synchronized</code>无法满足，比如上述说的那三点。否则，还是应该优先考虑使用<code>synchronized</code>。</p><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><p>上面提的<code>synchronized</code>和<code>ReentrantLock</code>，可以认为是阻塞型同步方式，或者说悲观锁。在锁的申请，线程调度和恢复过程中，存在着很大开销。<code>volatile</code>虽然是一种更轻量级的同步机制，但如上面所说，它无法保证原子性。有没有一种类似于<code>volatile</code>，又能保证原子性的机制呢？<strong>Atomic</strong>类型登场了。从字面意思来讲，就知道这是一种原子类型，可以实现同步。在说<code>Atomic</code>之前，有必要复习下<strong>CAS</strong>的概念，CAS(compare and swap)，即<strong>比较并交换</strong>，这是计算机领域中很典型而又很重要的无锁思想，乐观锁通常用的就是 CAS 思想，如 MySQL 中的 MVCC，redis 中的 Watch ，都是用的 CAS 方式实现乐观锁。CAS 操作是通过将内存中的值与指定数据进行比较，当数值一样时，将内存中的数据替换为新值，它是大多数 CPU 架构直接支持的原子指令。因此，我们说 CAS 操作是原子性的，是因为 CPU 指令来保证它是原子的，它是由硬件来提供。</p><p><code>Atomic</code>类型就是 JVM 中支持 CAS 的一种实现。如<code>AtomicInteger</code>,<code>AtomicLong</code>等。具体在 <code>java.util.concurrent.atomic</code>这个包下</p><p>在上述代码中，我们看下 <code>getAndIncrement()</code>方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看看 getAndAddInt 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中，compareAndSawpInt 方法原型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一和第二个参数代表对象的实例以及地址，第三个参数代表期望值，第四个参数代表更新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure></p><p>注意到上面有个 unsafe，这是 sun.misc.Unsafe 类的实例，在 JDK 的并发包中，很多地方都用到了它，它提供了一些底层操作的能力，它设计出来是给 JDK 中的源码使用的，比如 AQS、ConcurrentHashMap 等，这个 Unsafe 类不是给我们的代码使用的，是给 JDK 源码使用的，最后它调用的是一个 native 方法，底层跟硬件相关，生成的指令可以保证原子性。</p><blockquote><p>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好(减少乐观锁的重试次数)。</p></blockquote><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>最后我们来说说<code>ThreadLocal</code>，其实这个类的出现并不是用来解决在多线程并发环境下资源的共享问题的，它和上面几个同步方式不一样，上面的关键字都是从线程外来保证变量的一致性，这样使得多个线程访问的变量具有一致性，可以更好的体现出资源的共享。</p><p>而<code>ThreadLocal</code>的设计，并不是解决资源共享的问题，而是用来提供线程内的局部变量，这样每个线程都自己管理自己的局部变量，别的线程操作的数据不会对我产生影响，互不影响，所以不存在解决资源共享这么一说，如果是解决资源共享，那么其它线程操作的结果必然我需要获取到，而<code>ThreadLocal</code>则是自己管理自己的，相当于封装在<code>Thread</code>内部了，供线程自己管理。来看个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;string&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;string&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            threadLocal.set(String.valueOf(num));</span><br><span class="line">            System.out.println(<span class="string">"threadLocalValue:"</span>+threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">1</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">2</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadLocalValue:1</span><br><span class="line">threadLocalValue:3</span><br><span class="line">threadLocalValue:2</span><br></pre></td></tr></table></figure></p><p><strong>值得注意的一点</strong>：<code>ThreadLocal</code>在线程使用完毕后，我们应该手动调用<code>remove</code>方法，移除它内部的值，这样可以防止内存泄露，当然还有就是将<code>ThreadLocal</code>设为<code>static</code>。</p><p><code>ThreadLocal</code>内部有一个静态类<code>ThreadLocalMap</code>，使用到<code>ThreadLocal</code>的线程会与<code>ThreadLocalMap</code>绑定，维护着这个<code>Map</code>对象，而这个<code>ThreadLocalMap</code>的作用是映射当前<code>ThreadLocal</code>对应的值，<code>key</code>为当前<code>ThreadLocal</code>的弱引用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>java 多线程需要考虑并发问题，只要是原子性，可见性，有序性没有同时得到保证，就会产生并发问题，需要做同步。</li><li>做同步时，优先考虑使用<code>synchronized</code>，如有特殊情况，再做优化，如考虑使用<code>ReentrantLock</code>。</li><li>当满足<code>volatile</code>的使用条件时，可以用<code>volatile</code>，来实现轻量级锁。</li><li>由于 <code>Atomic</code> 是通过 CAS 来实现同步，是一种非阻塞解决并发的方式，不会锁住当前线程，效率会更高，当然它也会存在 CAS 所带来的 ABA 问题，另一方面，由于存在重试机制，并发越高，失败重试的次数越多，极大增加 CPU 开销，不适合于竞争非常频繁的场景。</li><li>ThreadLocal 并不解决线程间共享数据的问题，它适用于变量在线程间隔离且在方法间共享的场景。</li></ul><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></li><li><a href="https://www.2cto.com/kf/201601/486898.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201601/486898.html</a></li><li><a href="https://emacsist.github.io/2017/07/04/java-%E4%B8%AD-%E7%9A%84-synchronized-%E4%B8%8E-atomic/" target="_blank" rel="noopener">https://emacsist.github.io/2017/07/04/java-%E4%B8%AD-%E7%9A%84-synchronized-%E4%B8%8E-atomic/</a></li><li><a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1883</a></li><li><a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">http://www.jasongj.com/java/threadlocal/</a></li><li>《java并发编程实战》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到 java 中的同步，必然少不了耳熟能详的&lt;code&gt;synchronized&lt;/code&gt;，&lt;code&gt;ReentrantLock&lt;/code&gt;，以及可能用过但不怎么常见的&lt;code&gt;Atomic&lt;/code&gt;，&lt;code&gt;volatile&lt;/code&gt;，本篇即简单介绍下他们的区别和使用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="java" scheme="http://xujimmy.com/tags/java/"/>
    
      <category term="同步" scheme="http://xujimmy.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java 中集合和泛型最佳实践</title>
    <link href="http://xujimmy.com//2018/06/20/java-collections-generics-best-practices.html"/>
    <id>http://xujimmy.com//2018/06/20/java-collections-generics-best-practices.html</id>
    <published>2018-06-20T09:08:33.000Z</published>
    <updated>2019-11-08T08:55:08.647Z</updated>
    
    <content type="html"><![CDATA[<p>最近看 Java，读到一篇比较好的英文文章，特翻译了下记录下来。原文链接在<a href="http://www.codejava.net/java-core/collections/18-java-collections-and-generics-best-practices" target="_blank" rel="noopener">这里</a></p><p>集合类和泛型是 Java 中比较常用的技术，也是面试时经常问到的点。本篇文章向大家分享的，是一个资深 Java 开发者多年的实战经验。通过本篇文章，你会了解怎么高效而优雅的使用集合、泛型，而不是仅仅停留在 “just work”。</p><a id="more"></a><h2 id="选择正确的集合"><a href="#选择正确的集合" class="headerlink" title="选择正确的集合"></a>选择正确的集合</h2><p>这是使用集合之前的第一个也是最重要的步骤。根据要解决的问题，选择最合适的集合。如果你选错了，你的程序可能仍然有效，但效率不高。如果你选择一个合适的集合，那么程序可能会简单得多，运行也快得多。</p><p>选择合适的集合就像选择一辆从东京到纽约的汽车。如果选择一条船，也许你会在几个月后到达目的地。如果你选择一架飞机，你会在一天之内到达时代广场。如果你选择一列火车，那你都到不了目的地。</p><p>要知道哪种集合（List，Set，Map，Queue等）适合于解决问题，您应该弄清楚每个集合的特点和行为以及它们之间的差异。您还需要了解每个具体实现（ArrayList，LinkedList，HashSet，TreeSet等）的优缺点。</p><p>基本上，您决定通过回答以下问题来选择一个系列：</p><ul><li><p>它是否允许重复元素？</p></li><li><p>它接受null吗？</p></li><li><p>它允许按索引访问元素吗？</p></li><li><p>它提供快速添加和快速移除元素吗？</p></li><li><p>它支持并发吗？</p></li><li><p>等等</p></li></ul><p>每当你不确定某个特定集合的相关信息时，也请参阅他们的 Javadocs</p><h2 id="声明集合时始终使用接口类型"><a href="#声明集合时始终使用接口类型" class="headerlink" title="声明集合时始终使用接口类型"></a>声明集合时始终使用接口类型</h2><p>看看下面两条声明语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();   <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; listNames = <span class="keyword">new</span> ArrayList &lt;String&gt;（）; <span class="comment">//（2）</span></span><br></pre></td></tr></table></figure></p><p>（1）和（2）之间有什么区别？<br>在（1）中，变量 listNames 的类型是 List，在（2）中 listNames 具有 ArrayList 的类型。通过使用接口类型声明集合，代码将更加灵活，因为您可以在需要时轻松更改具体实现，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listNames = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p><p>当您的代码设计为依赖于 List 接口时，您可以轻松地在 List 的实现之间进行交换，而无需修改使用它的代码。在方法参数的情况下，对集合使用接口类型的灵活性更加明显。考虑以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Set&lt;Integer&gt; numbers)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，通过声明参数编号为 Set 类型，客户端代码可以传递 Set 的任何实现，例如 HashSet 或 TreeSet：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(TreeSet);</span><br><span class="line">foo(HashSet);</span><br></pre></td></tr></table></figure></p><p>这使您的代码更灵活，更抽象。相比之下，如果您声明参数编号为 HashSet 类型，则该方法不能接受除 HashSet（及其子类型）之外的任何内容，这样代码就少了灵活性。另外还推荐将接口用作返回集合的方法的返回类型，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection <span class="title">listStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; listStudents = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// add students to the list</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> listStudents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这无疑会增加代码的灵活性，因为您可以更改方法中的实际实现而不影响其客户端代码。所以这第二个最佳实践鼓励你使用抽象类型而不是具体类型。</p><h2 id="使用通用类型和钻石操作符"><a href="#使用通用类型和钻石操作符" class="headerlink" title="使用通用类型和钻石操作符"></a>使用通用类型和钻石操作符</h2><p>当然可以像下面这样声明一个泛型类型的集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; listStudents = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br></pre></td></tr></table></figure></p><p>自Java 7 以来，编译器可以从左侧声明的泛型类型推断右侧的泛型类型，因此您可以编写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; listStudents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>&lt;&gt; 非正式地称为钻石操作符。这个操作符非常有用。想象一下，如果有以下集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;String, Student&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Map&lt;String, Student&gt;&gt;();</span><br></pre></td></tr></table></figure></p><p>没有钻石操作符，你必须重复相同的声明两次，这使得代码冗长，所以尽量使用钻石操作符声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;String, Student&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><h2 id="初始化集合时，尽可能指定容量"><a href="#初始化集合时，尽可能指定容量" class="headerlink" title="初始化集合时，尽可能指定容量"></a>初始化集合时，尽可能指定容量</h2><p>具体的集合类几乎都具有重载构造函数，该构造函数指定集合的​​初始容量（集合在创建时可以保持的元素数量）。这意味着，如果您非常确定将向集合中添加多少元素，请在创建该集合的新实例时指定初始容量。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure></p><p>这会创建一个最初可容纳5000个元素的数组列表。如果不指定此数字，则每次超出当前容量时，数组列表本身将不得不增大其内部数组，这是低效的。因此，请查阅每个集合的Javadocs以了解其默认初始容量，以便您知道是否应明确指定初始容量。</p><h2 id="使用-isEmpty-而不是-size"><a href="#使用-isEmpty-而不是-size" class="headerlink" title="使用 isEmpty() 而不是 size()"></a>使用 isEmpty() 而不是 size()</h2><p>如果要检查一个集合是否为空，最好不要这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (listStudents.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// dos something if the list is not empty  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相反，你应该使用 isEmpty() 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!listStudents.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// dos something if the list is not empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>isEmpty() 和size() 之间并没有性能差异，使用 isEmpty() 的原因是代码的可读性。</p><h2 id="不要在返回集合的方法中返回-null"><a href="#不要在返回集合的方法中返回-null" class="headerlink" title="不要在返回集合的方法中返回 null"></a>不要在返回集合的方法中返回 null</h2><p>如果一个方法被设计为返回一个集合，那么在集合中没有元素的情况下它不应该返回null。考虑以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findStudents</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; listStudents = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">//students are found//) &#123;</span></span><br><span class="line">        <span class="comment">// add students to the lsit</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> listStudents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，如果找不到学生，该方法返回 null。这里的关键是，不应该使用空值来表示没有结果。最好的做法是，返回一个空集合来表示没有结果。上述代码可以通过初始化集合来轻松更正:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; listStudents = <span class="keyword">new</span> ArrayList&lt;&gt;;</span><br></pre></td></tr></table></figure></p><p>因此，请始终检查代码的逻辑以避免返回 null 而不是空集合。</p><h2 id="不要使用经典-for-循环"><a href="#不要使用经典-for-循环" class="headerlink" title="不要使用经典 for 循环"></a>不要使用经典 for 循环</h2><p>如果您编写代码来迭代像下面这样的列表集合，没有什么不妥:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listStudents.size(); i++) &#123;</span><br><span class="line">    Student aStudent = listStudents.get(i);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do something with aStudent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，这种做法不太好，因为使用计数器变量 i ，如果它在循环内部的某处被更改，那么可能会导致潜在的错误。这种循环也不是面向对象的，因为每个集合都有自己的迭代器。所以建议使用如下代码的迭代器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Student&gt; iterator = listStudents.iterator();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Student nextStudent = iterator.next();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do something with nextStudent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，如果迭代器创建后，有另一个线程修改了集合，则该迭代器可能会抛出 ConcurrentModificationException，导致潜在错误。因此最好使用下面的增强 for 循环：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Student aStudent : listStudents) &#123;</span><br><span class="line">    <span class="comment">// do something with aStudent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正如你所看到的，虽然增强型for循环在后台使用迭代器，但它更简洁易读。</p><h2 id="优先使用-forEach-和-Lambda-表达式"><a href="#优先使用-forEach-和-Lambda-表达式" class="headerlink" title="优先使用 forEach() 和 Lambda 表达式"></a>优先使用 forEach() 和 Lambda 表达式</h2><p>从Java 8开始，每个集合都提供了将迭代代码封装在集合本身内部的 forEach() 方法（内部迭代），并且您只需将 Lambda 表达式传递给此方法即可。这使得迭代代码更加紧凑，更灵活，更强大。如下一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; fruits = Arrays.asList(<span class="string">"Banana"</span>, <span class="string">"Lemon"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>);</span><br><span class="line"> </span><br><span class="line">fruits.forEach(fruit -&gt; System.out.println(fruit));</span><br></pre></td></tr></table></figure></p><p>这相当于以下增强的 for 循环：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String fruit : fruits) &#123;</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以我鼓励你使用 forEach() 方法迭代集合，这样可以帮助你专注于代码而不是迭代。</p><h2 id="正确覆盖-equals-和-hashCode-方法"><a href="#正确覆盖-equals-和-hashCode-方法" class="headerlink" title="正确覆盖 equals() 和 hashCode() 方法"></a>正确覆盖 equals() 和 hashCode() 方法</h2><p>当您使用自定义类型的集合时，如一个 Student 对象的列表，记得要正确地覆盖自定义类型中的 equals() 和 hashCode() 方法，以便允许集合有效且正确地管理元素，尤其是在基于它们的哈希代码值组织元素的 Set 集合中。</p><h2 id="正确实现-Comparable-接口"><a href="#正确实现-Comparable-接口" class="headerlink" title="正确实现 Comparable 接口"></a>正确实现 Comparable 接口</h2><p>请记住，当您的自定义类型的元素被添加到通过自然排序（例如 TreeSet 和 TreeMap ）对元素进行排序的集合中时，您的自定义类型会正确实现 Comparable 接口，它还有助于根据元素的自然排序对列表集合中的元素进行排序。</p><h2 id="使用-Arrays-和-Collections-实用程序类"><a href="#使用-Arrays-和-Collections-实用程序类" class="headerlink" title="使用 Arrays 和 Collections 实用程序类"></a>使用 Arrays 和 Collections 实用程序类</h2><p>请注意，Java 集合框架提供了两个名为 Arrays 和 Collections 的实用程序类，它们为我们提供了许多有用的功能。例如，Arrays.asList() 方法返回一个包含给定元素的列表集合，如您所见，我在很多示例中使用了此方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listFruits = Arrays.asList(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</span><br><span class="line">List&lt;Integer&gt; listIntegers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">List&lt;Double&gt; listDoubles = Arrays.asList(<span class="number">0.1</span>, <span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>);</span><br></pre></td></tr></table></figure></p><p>Collections 类提供了各种有用的方法来搜索，排序，修改集合中的元素（几乎都在 lists 中）。因此，在查找其他库或编写自己的代码之前，请记住查看这两个实用程序类的可重用方法。</p><h2 id="在集合上使用-Stream-API"><a href="#在集合上使用-Stream-API" class="headerlink" title="在集合上使用 Stream API"></a>在集合上使用 Stream API</h2><p>从Java 8开始，每个集合现在都有返回元素流的 stream() 方法，因此您可以利用 Stream API 轻松执行聚合函数。例如，以下代码使用 Stream API 来计算整数列表的总和:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">System.out.println(<span class="string">"sum = "</span> + sum);</span><br></pre></td></tr></table></figure></p><p>这里的关键是，总是利用集合上的 Stream API 来编写代码，以便快速方便地执行集合函数。</p><h2 id="优先使用-concurrent-包代替-synchronized"><a href="#优先使用-concurrent-包代替-synchronized" class="headerlink" title="优先使用 concurrent 包代替 synchronized"></a>优先使用 concurrent 包代替 synchronized</h2><p>当您必须在多线程应用程序中使用集合时，请考虑在 <code>java.util.concurrent</code>包中使用并发集合，而不要使用由<code>Collections.synchronizedXXX()</code>方法生成的同步集合。这是因为<code>concurrent</code>集合旨在通过实现像写时复制(CopyOnWrite)，比较和交换，以及特殊锁等不同的同步机制，在并发应用程序中提供最高性能。以下列表显示了如何选择一些并发集合（右侧），它们与正常集合（左侧）相同</p><ul><li><p>HashMap -&gt; ConcurrentHashMap</p></li><li><p>ArrayList -&gt; CopyOnWriteArrayList</p></li><li><p>TreeMap -&gt; ConcurrentSkipListMap</p></li><li><p>PriorityQueue -&gt; PriorityBlockingQueue</p></li></ul><h2 id="使用第三方集合库"><a href="#使用第三方集合库" class="headerlink" title="使用第三方集合库"></a>使用第三方集合库</h2><p>Java 集合框架并不总是满足所有需求，所以第三方集合库出现以满足我们的需求。有很多优质的第三方库，这里列举4个值得收藏的库：</p><ul><li><p>Fastutil：对于像 int 或 long 这样的原始类型集合，Fastutil 是绝佳选择。它甚至能够处理超过21亿（2 ^ 31）个元素的大型集合。</p></li><li><p>Guava：这是用于Java 6+的 Google 核心库。它包含了很多方便的创建集合的方法，如 fluent builders，以及高级集合类型，如 HashBiMap，ArrayListMultimap 等。</p></li><li><p>Eclipse集合：这个库包括几乎所有你可能需要的集合：原始类型集合，multimaps，bidirectional maps 等等。</p></li><li><p>JCTools：这个库为 JVM 提供 Java 并发工具。它提供了 JDK 当前缺少的一些并发数据结构，例如高级 concurrent queues。</p></li></ul><p>不要将自己锁定在JDK提供的Java Collections Framework上，并始终利用第三方集合库。</p><h2 id="消除-unchecked-警告"><a href="#消除-unchecked-警告" class="headerlink" title="消除 unchecked 警告"></a>消除 unchecked 警告</h2><p>当编译器发出未经检查的警告时，请不要忽略它们。最好的做法是，你应该消除未经检查的警告。考虑下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(list1);</span><br></pre></td></tr></table></figure></p><p>尽管上面代码仍可编译，但编译器会发出如下警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note: ClassNam.java uses unchecked or unsafe operations</span><br></pre></td></tr></table></figure></p><p>未经检查的警告很重要，所以不要忽视它们。这是因为每个未经检查的警告都表示运行时可能出现 ClassCastException。在上面的代码中，如果 list1 包含 Integer 元素而不是 String，那么使用 list2 的代码将在运行时抛出 ClassCastException。<br>尽最大努力消除这些警告。上面的代码可以这样纠正：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(list1);</span><br></pre></td></tr></table></figure></p><p>但是，并不是每一个警告都可以像这样轻易消除。如果您无法消除未检查的警告，请证明该代码是类型安全的，然后在尽可能最窄的范围内使用 <code>@SuppressWarnings(“unchecked”)</code>注释来禁止警告。也写注释解释为什么你压制警告。</p><h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><p>尽可能的把已有的类型泛型化，因为泛型更安全，更易于使用。当你设计新的类型时，也要考虑它们是否可以被泛型化。同样的，Java 也鼓励您使用泛型参数编写新方法，并将现有方法转换为使用类型参数，因为泛型方法比非泛型方法更安全，更易于使用。泛型方法还可以帮助您编写更通用且可重用的 API。</p><h2 id="使用有界通配符来增加-API-灵活性"><a href="#使用有界通配符来增加-API-灵活性" class="headerlink" title="使用有界通配符来增加 API 灵活性"></a>使用有界通配符来增加 API 灵活性</h2><p>在编写新的泛型方法时，请考虑在输入参数上使用通配符类型以获得最大灵活性。考虑以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(Collection&lt;Number&gt; col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (Number num : col) &#123;</span><br><span class="line">        sum += num.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此方法的局限性是它只能接受 List<number>，Set<number>，但不接受 List<integer>，List<long> 或 Set<double>。为了最大限度地提高灵活性，请更新方法以使用有界通配符，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(Collection&lt;? extends Number&gt; col)</span></span></span><br></pre></td></tr></table></figure></double></long></integer></number></number></p><p>现在，该方法可以接受任何类型的集合，这些类型是整数，双精度，长精度等数字的子类型。</p><p>以上就是使用 Java 中集合和泛型的最佳实践，或许有些你已经知道，但关键是，你要尽快在日常编码中，有意识的使用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看 Java，读到一篇比较好的英文文章，特翻译了下记录下来。原文链接在&lt;a href=&quot;http://www.codejava.net/java-core/collections/18-java-collections-and-generics-best-practices&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;集合类和泛型是 Java 中比较常用的技术，也是面试时经常问到的点。本篇文章向大家分享的，是一个资深 Java 开发者多年的实战经验。通过本篇文章，你会了解怎么高效而优雅的使用集合、泛型，而不是仅仅停留在 “just work”。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="Java" scheme="http://xujimmy.com/tags/Java/"/>
    
      <category term="collection" scheme="http://xujimmy.com/tags/collection/"/>
    
  </entry>
  
  <entry>
    <title>我的这 10 年</title>
    <link href="http://xujimmy.com//2018/06/07/my-10-years.html"/>
    <id>http://xujimmy.com//2018/06/07/my-10-years.html</id>
    <published>2018-06-07T14:10:10.000Z</published>
    <updated>2019-11-12T08:04:37.232Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文字在草稿箱里已经存了几个月了，趁着周末加班改完 bug，还是做个了结吧。</p><p>现在是2018年6月，新闻前两天还一直在报道今年高考的消息，今年全国高考人970万。回想起我第一次参加高考，已经过去整整 10 年了，现在看到视频里那些进入考场的莘莘学子，感慨万分，他们才是早上八九点的太阳啊。。。看了下历年的高考人数变化，没想到，我高考的那两年，居然是高考人数的最高峰。像是过关游戏中，小手一抖，选择了 hard 模式。高考的人数变化，也一定程度上，反应了我们国家人口的变化。越来越多的人相信，在未来半个世纪，中国劳动力人口在呈逐年下降趋势。目前，国家全面开放二胎政策，鼓励多生。想想当年父母生我弟时，由于“计划生育”，村中大队的人过来要求罚款，但家里实在一贫如洗，那些人就如强盗样，把家唯一的家电：一台收音机给抱走了。这才多少年啊？！而现在孩子如同碎钞机，巨大抚养压力，反而大多数家庭都打消了二胎的想法，不可谓不讽刺。<br><a id="more"></a></p><p>我第一次参加高考是 2007 年，可是那年天不如愿，发挥失常，没考出理想成绩。尤其是语文，写完作文我就基本知道要凉，结果出来后，无意外，肯定上不了一本线，又不想去二本，于是咬牙复读了一年，第二年终于如愿以偿。想起复读那年，国内发生了太多大事，年初的雪灾，汶川地震，北京奥运。雪灾的那几个月，记得每天晚上放学回家，地面都是一层厚厚的冰，走路骑车都很危险。虽然每年我们那都会下雪，但地面长时间结冰，还是头一次见。快过年时，老师说，外面县市的同学如果没车回不去，本地的同学每人捎一个回家过年吧。。。</p><p>雪灾过后，然后就是5.12 地震了。记得那天，我们在拍毕业照吧，在操场上，没怎么感觉，第二天，从新闻报纸得之消息后，才发现四川的灾情是多么严重。当电视里的温总理前往灾区，安慰无家可归的孩子说不要哭，当老师说着捐款时，当从报纸看到那惨白的死亡数字，唯一的颜色就是五星红旗时，大家都异常难受。当时，整个国家都陷入了一片悲恸。各种捐款各种物资，如雪花一样运往灾区，5.12地震，对于中国来说，是一次沉重的苦难，也让我第一次真真切切看到了民族的凝聚力，什么叫做一方有难八方支援。</p><p>地震过后，就是第二次高考了。依稀记得进考场前，老师问我们，有没有信心，大家异口同声喊：有！洪亮的声音仿佛整栋楼都在震动，人生难得机会博？那种斗志，只有后来大学时军训才再次重现，此后再也没有了。回首那些年的读书生涯，以及在外面的这么多年，给我的感受是，高考，是人生中的第一道坎，怎么强调它的重要性都不过分。尽管时不时会听到有抨击高考政策的声音，但不可否认，高考是现阶段国内最公平的一次人才选拔，也许是整个社会最公平的一次竞争。不看脸，不拼爹，全凭个人的实力，对于个人来说，这是改变命运最有效，也是最保险的途径了。祝愿今年的考生们，好好把握机会，考出好成绩。</p><p>高考完就是北京奥运，那一年，一首北京欢迎你的歌声传遍海内外，中国夺金的数量一举夺得头魁。十年过去，现在再听听这首歌，联想起去年末北京西红门的那场“赶人”运动，真是一种讽刺。</p><p>那年的暑假没事做，去琴社学了下吉他，两个月的时间，基本入门，从小白到能弹唱基本的歌曲，忽悠外行人还是没问题的。和我一起学的，还有好多小孩，看着他们弹的水平，有的真让我自愧不如。学艺要趁早啊，真和年龄无关。也难怪现在的父母，大把大把的给小孩砸钱报各种班，你没报班都不好意思出去遛娃。兴趣班一节课几百块，报两三个班，每个月都是不小的开支，可怕！</p><p>可是我到大学后，没找个好组织，也苦于那时生活拮据，没钱买个好点的吉他，技能最终荒废。</p><p>我的大学是在山城重庆，这个城市给我的感觉就是潮湿，非常潮湿，学校又是在山上，更加潮湿，绵绵细雨一年四季下个不停，空气湿度高，路面常年湿漉漉的，学校有个著名的“夺命天梯”，从下面往上看，食堂和宿舍楼云雾缭绕，犹如仙境。阳台晒的衣服，几天都干不了，床上的被子，冬天都感觉是湿的。在重庆的那 4 年平平淡淡，感情上，没正经耍过朋友（重庆话里，谈恋爱叫耍朋友，毫无贬义）；学习上，一直处于“中庸状态”，班里的学霸多如牛毛，也跟自己确实没怎么用心有关，虽然四年里都没挂过科，但也没拿过奖学金。大一下学期配了电脑后，游戏和电影成了主要的娱乐方式，玩各种端游，看各种大片。有时会想，大学也不过如此，跟高中时读的书《草样年华》，听的广播剧《让青春继续》里完全不一样啊。</p><p>我学的专业是通信工程，虽然是这学校最好的专业，但一直不知道自己以后想干嘛。选这个专业，也是当时高考完后，在父母，和当时在联通工作的舅舅安排下选的，那时的运营商，日子过得还很滋润，是就业选择的香饽饽，因此他们希望我毕业也就联通工作。但那时的运营商，已处在智能手机爆发的前夜，后来运营商的情况大家都知道了。</p><p>到了大三下，基本到了该决定是考研还是工作的时候，一方面被导师的话蛊惑：考研吧，就算现在不考，以后还是要考（这可能跟导师一直在学校做科研有关）。另一方面，当时确实是不知道自己能干啥，于是没怎么参加校招，加入了班上的考研大军。</p><p>现在看来，考研，可以说是我大学最下功夫最投入的一件事了。记得大学时，每次要到期末考试前才去上自习，一度感慨：现在为了期末考试，就这么累，真不知道以后如果考研，那不是要废掉。没想到最后两眼一黑一路走到底，考研时真的坚持下来了。备考的那半年，每天保持高强度学习，大三暑假回家呆了两周，效率明显不行，果断又回到了学校继续学习。重庆的夏天如火炉，40 度的高温，暑假学校里都没什么人，我每天早上去四教自习，晚上 10 点回宿舍睡觉，有时走在学校空旷的路上，会问自己：这么辛苦，是为了什么呢？</p><p>备考的日子从那年夏天一直持续到冬天，考研如期进行，考完后觉得要凉，结果分数出来后发现并没有。考研过程确实摧残人，尤其是英语，考完后，一部分人会弃考，同宿舍的一个小伙伴，考完数学后直接弃考，我们怎么劝都没用，后来他参加了二战。对于他的弃考，虽然我没问，但我觉得他后来肯定是后悔的。</p><p>成绩出来后，就是准备复试了，当时班上和我考一个学校的还有几个小伙伴，成绩出来的当天我们就坐动车去成都的学校找导师，为了省钱，4 人在学校外面租了个单间住了一周，有两个小伙伴还打地铺，我们约着两天互换睡地铺。。。复试的过程，也是充满了跌宕起伏，由于我过线分数并不高，第一批复试完感觉自己没人要，准备第二批，结果第一批录取名单出来后，跑到网吧查，赫然发现自己居然在列，喜出望外，终于成功了！考研也告一段落。</p><p>考研完，整个人就轻松多了，大学剩下的几个月就轻松多了，尝试找了个兼职：送外卖。。。那会儿还是 2012 年，外卖行业基本还处于萌芽阶段，服务群体就是在校学生，流程也非常原始：首先给各宿舍发小传单，留电话，学生下单方式就是打电话，然后我去店里拿餐，开始时，连电动车都没有，全靠脚力，非常辛苦。做了一个月，拿了 600 块，本来说好的报销电话费，后来老板说亏损 1000 多，我也就没要了。</p><p>现在的外卖业已经相当成熟了，走在外面路上，随时可以看到黄的蓝的骑手在你身边穿梭，而我当年兼职送外卖的那一个月，也可以算是最早的一批骑手吧。外卖送完，就到了大学毕业季，没啥新奇，就是各种聚餐喝酒拍照。</p><p>大学毕业后，和妈妈去新疆的叔叔家玩，他家在哈密，一听这名字，是不是想到了香甜的哈密瓜？没错，那里的瓜真是个大又甜。然而那次旅行真是一次生死的经历，叔叔开车带我们去玩，在天山路上发生了严重车祸，车毁了，万幸的是，车上 5 人都没啥大事，除了我眼睑上被划了一道口子，缝了几针，如果受伤的部位再下去一点，我可能就要成残疾人了。缝好针后，眼皮上留下了一道疤，不过带上眼镜后，没那么明显。车祸后，我感觉像是经过了一次重生，但一段时间坐车都心有余悸，会不由自主想象车祸的场景。</p><p>然后就是在成都读研的三年了，读研的生活就如同成都这个城市一样，不紧不慢，研一需要正常上课，上课的那年，一度让我觉得，这 tm 跟大学有啥区别？所幸的是，这边学霸没那么多，于是这三年都拿了一等奖学金，学费全免，也没怎么跟家里要过钱了。但教研室的老板却是相当的抠，说是老板，其实他是我们的导师，身上各种光环头衔。国家规定给研究生每月发的 270 元补助，他都要扣 70，只给我们发 200。每次项目学校打给我们卡上的劳务费，都要让我们取出来交上去。一直到研三，国家将补助调到了 500，直接打到个人卡上，才没有扣钱。</p><p>在成都，我开始踏上骑行之路，其实本来是玩轮滑的，研一时报了轮滑社，但轮滑有个弊端，对路况要求高，路得平，而且出了学校，外面的马路车多太危险，轮滑速度也慢，种种因素注定轮滑使用的半径还是太小，只能在学校里小打小闹，刷马路就有点吃力，于是改骑行了。成都的骑行氛围很好，有很多骑川藏线的朋友，因为这是川藏线的起点，每年都有很多骑行爱好者，从成都出发，一路骑车去西藏，2000 多公里，要骑 20 多天，需要翻越上 10 座大山，这绝对是一个充满挑战和风险的经历。</p><p>学校有很多玩车的伙伴，其中不缺乏土豪，公路、碳架、上万的豪车也能看到。当然我自己是没钱买好车的，花了 1700，买了个二手的捷安特 ATX750，自从有了山地车，整个世界仿佛大了许多，以前那些觉得好远，交通不方便，坐车好麻烦的地方，也因为有了车而变成可能，周末会约上几个骑友，去温江西财吃鱼香茄子，去都江堰看看水，去龙泉驿爬爬山，去阿坝州看看羌寨。这个车陪伴了我 2 年多，一直到毕业。也许这是一辆自带幸运光环的车，两年多的时间，它没有坏过没有修过，连胎都没爆过，就算是当时去映秀，去卧龙，在那种完全没法骑的石头路上摧残，车身都是泥，都看不清它原来的颜色，它也依然坚固。到毕业时，车上的码表显示已经骑行超过 5000 公里。最终，我把它卖给了一个准备骑川藏的同学，希望幸运也一直伴随着他吧。</p><p>学校的硕士研究生是三年制，实验室的研究方向是光纤传感，这三年，在学术上，做了实验，发了文章，写了专利。除此之外，似乎也没啥了。有时在想，读研的意义又是什么呢？如果一上大学，就知道自己想要什么，兴趣点在哪里，然后定个方向，努力朝着这个方向走，到毕业时也许就不会那么彷徨了。工作，会让你更早进入职场和社会，更早获得锻炼，让你知道企业需要什么；读研，可以再给你一次塑造自己的机会，会给你一个更高的起点，让你找工作时，能比本科有更好的第一印象，至少，在我面试他人时，看到研究生的简历，会比本科生要更加耐心。</p><p>研究生 3 年很快过去，又到了要找工作的季节，这个时候，不能再拿读博来逃避了，都一把年纪了。最终觉得以自己的情况和性格，没法做改变世界的大事，还是老实去写代码吧，于是拿起面试宝典，剑指 offer 看起来。经过一顿恶补，校招时，也骗到了几个 offer，最开始签的是武汉的一家通信类的国企，想着离家近点。到后来还是想搏一搏，遂毁约又签了北京的互联网公司。</p><p>2015 年 6 月，拿完毕业证，学位证，吃完散伙饭，正式结束了读书生涯。7 月，我拖着箱子，踏上了北上的火车，开始了北漂。刚来北京那会儿，既兴奋又孤独，兴奋的是，这是中国的首都，可以看天安门，看鸟巢，以及传说中的“京霾”。孤独的是，班上来北京的只有我一个，在这边没一个认识的人，来的第一天找房子时，没地方放行李箱，就拖着箱子到处找，第一天没找到合适的，就联系了还在北京读研的一个大学同学，正好他在外地实习，于是就在他宿舍借宿了一晚，第二天幸运之光降临，意外联系上了一个在北京已经工作 2 年其他学院的师兄，他那正好空出一个次卧，还没有隔断，价格 1600，贵了点，但房子条件不错，于是果断租下了，住宿问题终于解决。期间问了下在成都上班的小伙伴，有三个同学合租了个大三居，价格1500，平均每人500。。。T_T，WTF！为什么要让我知道！！</p><p>刚来北京的那会儿，特别喜欢出去逛，自己一个人去了天安门，去了北海，去了天坛，去了鸟巢，一切都如电视上看到的那样，如小时候课本说的那样，如歌曲里唱的那样，一切都是那么新奇。公司的氛围也好，有舒适的办公环境，有免费好吃的食堂，身边有厉害的同事，工作上也学到了好多新技术新知识，周末没事会去公司加个班，蹭个免费的饭吃。一切似乎都表明，来北京，值！</p><p>到今年6月，毕业整整三年。这三年，我从一个学生变成一个职场人士(职场人士很正式，给人的印象是一手提公文包，一手打电话，西装革履的人，确切的说，我这属于互联网从业者），从一个单身狗，经过某次偶然机会脱单，又变成一个已婚人士，从对房子毫无概念，到可以接受低工资拿武汉户口只为了买房。曾经一些老江湖说过，毕业 3 年，同学之间就会有一定的差距了，5 年后，差距会很明显。如今，我也站到了这个 3 年的坎上，心态似乎也缓慢发生了变化。没事周末肯定不去公司，逛景点？我住在五环外面呢，进城很麻烦的，别忘了自己低端人口的身份。以前对那些住天通苑，住通州的同事不能理解，上班得一个小时，为嘛住那么远，现在看看自己的通勤时间，似乎没啥不能理解的了。</p><p>其实自己的职业路比较奇特，本科时学的通信，学《信号与系统》，《通信原理》，《数字电路》，研究生时学的光学，学《激光原理》，《非线性光学》，结果找工作机缘巧合，进入到了互联网行业，成了一个码农，基本都是不相干的学科，居然被我给串上了。</p><p>人生总是充满变数，高考时，说想离家近点，要报武汉的大学，结果去了重庆；等考研时，说想考回武汉，结果去了四川；等找工作时，又说想离家近点，找个武汉的工作吧，结果来到了北京。2008 到 2018，离家整整十年。这十年的变化实在太大，十年前，我没有出过省，没有离过家，不知道“从此故乡，只有春夏，再无秋冬”；十年前，我没有银行卡，没有支付宝，更没有存款；十年前，大家都拿着诺基亚手机发短信，比彩铃，比彩屏，没有见过智能机，更不知道 iPhone；十年前，我上网得去网吧，和爸妈视频也只能去网吧，玩游戏也只能在 PC 上玩；十年前，我没有网购，甚至都没听过网购；这十年的变化太大，很多事情，放在十年前不可想象，大到让我对故乡有了一丝陌生感，让我变得经常回忆过去。未来的十年，又会有哪些变化呢？Time will tell</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文字在草稿箱里已经存了几个月了，趁着周末加班改完 bug，还是做个了结吧。&lt;/p&gt;
&lt;p&gt;现在是2018年6月，新闻前两天还一直在报道今年高考的消息，今年全国高考人970万。回想起我第一次参加高考，已经过去整整 10 年了，现在看到视频里那些进入考场的莘莘学子，感慨万分，他们才是早上八九点的太阳啊。。。看了下历年的高考人数变化，没想到，我高考的那两年，居然是高考人数的最高峰。像是过关游戏中，小手一抖，选择了 hard 模式。高考的人数变化，也一定程度上，反应了我们国家人口的变化。越来越多的人相信，在未来半个世纪，中国劳动力人口在呈逐年下降趋势。目前，国家全面开放二胎政策，鼓励多生。想想当年父母生我弟时，由于“计划生育”，村中大队的人过来要求罚款，但家里实在一贫如洗，那些人就如强盗样，把家唯一的家电：一台收音机给抱走了。这才多少年啊？！而现在孩子如同碎钞机，巨大抚养压力，反而大多数家庭都打消了二胎的想法，不可谓不讽刺。&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="http://xujimmy.com/categories/Life/"/>
    
    
      <category term="随想" scheme="http://xujimmy.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>关于 zookeeper 的一些原理</title>
    <link href="http://xujimmy.com//2018/04/08/zookeeper.html"/>
    <id>http://xujimmy.com//2018/04/08/zookeeper.html</id>
    <published>2018-04-08T08:17:26.000Z</published>
    <updated>2019-11-08T08:55:08.646Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统中，协调和管理服务是一个复杂的过程，数据的一致性也是一个不可避免的问题，而 zookeeper 是一个解决分布式集群应用中数据一致性问题的有效工具，它提供基于类似于文件系统的目录节点树方式的数据存储，<strong>但是 zookeeper 并不是用来专门存储数据，它的主要作用是用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。</strong></p><h2 id="zookeeper-的数据模型"><a href="#zookeeper-的数据模型" class="headerlink" title="zookeeper 的数据模型"></a>zookeeper 的数据模型</h2><p>zookeeper 的设计，借鉴了 Linux 中的文件系统，我们知道，在 Linux 中，用 <code>/</code> 来区分目录，如<code>/</code> 表示根目录，<code>/home</code> 表示在根目录下有个 home 目录， 同样，在 zookeeper 中，<code>/</code> 表示根节点， <code>/master</code> 表示根节点下的 master 节点，zookeeper 中的这种节点，被称为 <strong>znode</strong>。我们可以像创建目录一样，在 zookeeper 中创建任意一个节点。如图一。<br><img src="/images/zookeeper/znode.png" alt="图一"></p><p>与 Linux 目录不同的是， znode 节点还有自己独特的一些属性。</p><ul><li>访问一个 znode 只能使用绝对路径，而不能使用相对路径，例如 <code>../</code> 和 <code>./</code> 这种表示在 zookeeper 中是不被允许的。</li><li>znode 节点中，也可以存放数据，但并不适合存放大量数据，znode 节点存储数据大小不能超过 1M。</li><li>节点有持久节点 (persistent) 和临时节点 (ephemeral)，在创建 znode 时指定，且后续不可修改。持久节点创建后，除非主动删除，否则会一直存在。临时节点创建后，一旦客户端与 zookeeper 会话断开，临时节点就会被删除。当然临时节点也可以被显示删除。节点的这种特定，很适合用来做分布式系统中节点的健康检查。</li><li>节点可以有子节点，就像 Linux 某目录可以有子目录一样，但临时节点不可以有子节点</li><li>节点可以被监控（watch），当某个节点被客户端监控，那么当该节点中存储的数据，或者该节点的子节点发送变化，zookeeper 会通知设置监控的客户端，那么客户端可以根据通知，做相应的变化。这是 zookeeper 的核心特性，许多应用场景，均是使用了该特性。</li></ul><p>有了znode 的概念，应运而生，就有了操作 znode 的 API，zookeeper 提供了 Restful 的 API，可以很方便的对节点进行 CRUD 操作。</p><ul><li>create 创建一个 znode</li><li>delete 删除一个 znode</li><li>getData 获取一个 znode 中的数据</li><li>exists 判断一个 znode 是否存在</li><li>getChildren 获取一个 znode 的所有子节点</li></ul><h2 id="zookeeper-部署模式"><a href="#zookeeper-部署模式" class="headerlink" title="zookeeper 部署模式"></a>zookeeper 部署模式</h2><p>zookeeper 既可以以单节点模式运行，即只在一台机器上部署 zookeeper 服务，也可以以集群方式运行。事实上，为了发挥 zookeeper 的高可用特性，最佳实践应该以集群方式运行。幸运的是，在个人测试或者资源紧张时，在单台机器上，zookeeper 仍然可以模拟集群模式，即在一台机器上起多个 zookeeper 实例，只需要在配置文件中，修改指定配置项即可。</p><p>当 zookeeper 以集群方式运行时，会有一些独特的特性。</p><p>首先，并不是所有的节点都是一样的，zookeeper 集群中，会自主产生一个 leader 节点，其他都是 follower 节点，或者 observer 节点。所有对 zookeeper 的写操作，都会由 leader 节点来完成。读操作，可以由 follower 或者 leader 节点完成。事实上，当客户端连接到 zookeeper 时，它根本就不知道连接的是 leader 还是 follower。因此，当客户端有写操作，而它有恰恰连接到的是 follower 节点，那么该写操作仍然是转发给 leader 节点来完成。当 leader 节点挂掉时，zookeeper 会自动重新从剩余的节点中，再选一个 leader 出来。至于 leader 是怎么选出来的，这个涉及到 zookeeper 的选主算法，本文不做深入讨论。</p><p>其次，zookeeper 通过复制保证高可用性，每个 follower 节点的数据，都是 leader 节点数据的副本。集群中，只要有半数以上的节点处于可用状态，那么 zookeeper 就可以正常对外提供服务。如 5 个节点的 zookeeper 集群，就算有 2 个节点挂了，也可以保证服务继续，因为剩余的 3 个节点超过了半数。</p><p>再者，由于集群模式下的 zookeeper 服务有多个节点，同一时间，不同的客户端连接到 zookeeper，看到的数据应该是一样的，即 zookeeper 必须要保证数据一致性。zookeeper 从以下几点，保证了数据一致性</p><ul><li><strong>顺序一致性</strong><br>  来自任意特定客户端的更新都会按其发送顺序被提交。也就是说，如果一个客户端将 znode z 的值更新为 a，在之后的操作中，它又将 z 的值更新为 b，则没有客户端能够在看到 z 的值是 b 之后再看到值 a（如果没有其他对z的更新）</li><li><strong>原子性</strong><br>  每个更新要么成功，要么失败。这意味着如果一个更新失败，则不会有客户端会看到这个更新的结果</li><li><strong>单一系统镜像</strong><br>  一个客户端无论连接到哪个节点，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的节点，它所看到的系统状态不会比在之前节点上所看到的更老。当一个节点出现故障，导致它的一个客户端需要尝试连接集合体中其他节点时，所有滞后于故障节点的节点都不会接受该连接请求，直到节点的状态赶上之前故障的节点为止。</li><li><strong>持久性</strong><br>  一个更新一旦成功，其结果就会持久存在并且不会被撤销。这表明更新不会受到服务器故障的影响。</li></ul><h2 id="zookeeper-的使用场景"><a href="#zookeeper-的使用场景" class="headerlink" title="zookeeper 的使用场景"></a>zookeeper 的使用场景</h2><p>了解了 zookeeper 的一些基本概念，我们对 zookeeper 有了宏观上的认识，<strong>zookeeper 的这种设计，类似于设计模式中的观察者模式，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应，从而实现集群中类似 Master/Slave 管理模式。</strong> </p><p>下面看看使用 zookeeper 的几个场景。</p><h3 id="统一命名-Name-Service"><a href="#统一命名-Name-Service" class="headerlink" title="统一命名 (Name Service)"></a>统一命名 (Name Service)</h3><p>分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，就像数据库中产生一个唯一的数字主键一样，通常情况下用树形的名称结构是一个理想的选择。这里的名称是很宽泛的，可以是指集群的机器名，也可以是提供的服务地址，进程对象等。我们都可以称他们为名字。较为常见的就是一些分布式服务框架中的服务地址列表。通过调用 zookeeper 提供的创建节点 API，能够很容易创建一个全局唯一的 path，这个 path 就可以作为一个名称。Name Service 已经是 zookeeper 内置的功能，你只要调用 zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。</p><h3 id="配置管理-Configuration-Management"><a href="#配置管理-Configuration-Management" class="headerlink" title="配置管理 (Configuration Management)"></a>配置管理 (Configuration Management)</h3><p>配置管理在分布式应用环境中非常常见，例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。</p><p>像这样的配置信息完全可以交给 zookeeper 来管理，将配置信息保存在 zookeeper 的某个节点中，所有用到该配置信息的节点都监控配置信息的状态，一旦配置信息发生变化，每个节点就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p><h3 id="集群管理-Cluster-Management"><a href="#集群管理-Cluster-Management" class="headerlink" title="集群管理 (Cluster Management)"></a>集群管理 (Cluster Management)</h3><p>有多台机器组成一个集群，必须有一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它机器必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台机器，同样也必须让“总管”知道。</p><p>zookeeper 可以帮我们在集群中选出这样的“总管”，同时，当这个总管挂掉，zookeeper 可以在剩余的机器上，选择另一个替代的总管。避免总管挂掉导致整个集群不可用。这就是 zookeeper 的<strong>选主功能</strong>。选主是 zookeeper 最重要的功能之一。</p><h3 id="分布式锁-Distribute-Lock"><a href="#分布式锁-Distribute-Lock" class="headerlink" title="分布式锁 (Distribute Lock)"></a>分布式锁 (Distribute Lock)</h3><p>我们知道，单个节点上的多进程同步，可以使用互斥锁。进程要进入临界代码，先获得锁，然后才能操作临界区中的代码，没有获得锁的进程，必须等待锁。而在分布式系统中，情况就不同了。没有这么一个可以供多个节点上多个进程共享的锁。zookeeper 提供了一个解决方案，我们可以使用可排序的 znode 来实现。</p><p>原理很容易理解，我们可以先创建一个 <code>/leader</code> 的节点，然后让所有进程都尝试在 <code>/leader</code> 下创建 <code>lock</code> 临时节点，由上文得之，有且只有一个进程能创建成功。其他进程均创建失败。那么创建 <code>lock</code> 节点成功的进程，即表示获得了锁，可以做临界操作。以后，除非该进程主动释放锁，或者该进程崩溃，由于 <code>lock</code> 是临时节点，因此进程崩溃后，会自动删除，那么其他进程就又可以去竞争创建锁了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>zookeeper 作为 Hadoop 项目中的一个子项目，在分布式系统中，承担着重要的角色，它解决的是分布式系统中遇到的一类典型问题，很多分布式系统中，都会用到 zookeeper 来保证系统运行。 如在 hadoop 集群管理中，它主要用来控制集群中的数据，如管理 hadoop 集群中的 NameNode，还有 Hbase 中 Master Election、Server 之间状态同步等。</p><p>本文介绍的 zookeeper 的基本知识，以及介绍了几个典型的应用场景。这些都是 zookeeper 的基本功能，最重要的是 zoopkeeper 提供了一套很好的分布式集群管理的机制，就是它这种基于层次型的目录树的数据结构，并对树中的节点进行有效管理，从而可以设计出多种多样的分布式的数据管理模型，而不仅仅局限于上面提到的几个常用应用场景。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></li><li><a href="https://www.cnblogs.com/sunddenly/p/4138580.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunddenly/p/4138580.html</a></li><li>《ZooKeeper分布式过程协同技术详解》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式系统中，协调和管理服务是一个复杂的过程，数据的一致性也是一个不可避免的问题，而 zookeeper 是一个解决分布式集群应用中数据一致性问题的有效工具，它提供基于类似于文件系统的目录节点树方式的数据存储，&lt;strong&gt;但是 zookeeper 并不是用来专门存储数据
      
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="zookeeper" scheme="http://xujimmy.com/tags/zookeeper/"/>
    
      <category term="分布式系统" scheme="http://xujimmy.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>数学上的一些经典片段</title>
    <link href="http://xujimmy.com//2018/03/22/about-mathematical-formula.html"/>
    <id>http://xujimmy.com//2018/03/22/about-mathematical-formula.html</id>
    <published>2018-03-22T01:56:40.000Z</published>
    <updated>2019-11-08T08:55:08.646Z</updated>
    
    <content type="html"><![CDATA[<p>最近看的几本书里，都有提到一些数学方面的知识，有些符号和公式，放在现在，可能觉得没什么，一个小学生都能看懂，但却鲜有人知道，普及这些理论，需要几代人的不懈努力和探索。有些公式和推导，都堪称数学史上的经典，这里摘取一些片段，体会下数学的美妙，也让我们看看人类的智慧是无穷的<br><a id="more"></a></p><h2 id="质数是有限个吗？"><a href="#质数是有限个吗？" class="headerlink" title="质数是有限个吗？"></a>质数是有限个吗？</h2><p>质数是一个很古老的的概念，是数论中一个很重要的研究对象，大家在小学都学过。所谓质数，就是不能用两个或两个以上较小整数的乘积来表示的数，如2，3，5，7，11，13，17，等等。而 12 可以写成 2×2×3，所以就不是质数，我们称 12 这样的数为合数。显而易见，一个自然数，要么是质数，要么是合数。</p><p>关于质数，最初产生的一个问题就是：质数的个数是否是无限的呢？还是说存在一个最大的质数，即凡是比这个最大质数还大的数都可以表为几个质数的乘积呢？这个问题最初是由欧几里得提出的，同时他也给出了此问题的回答。现在我们知道，问题的答案是：<strong>有无穷多个质数。</strong></p><p>欧几里得关于质数有无限多个的证明，至今仍然是数学推理的一个典范。他用的方法，就是现在所熟知的<strong>反证法</strong>。我们从一个尝试下的假设出发，即认为质数是有限多个，比如有 $n$ 个。即，其他任何一个数都是合数，且在 $p_1$, $p_2$ 中至少有一个能整除它。现在构造一个数 $A$ $$A={p_1} \ast {p_2} \ast \cdots  \ast {p_n} + 1$$ 现在这个 $A$ ，比任何一个质数都大，因而是合数，但是我们用 $p_1$ , $p_2$ 等去除 $A$ 总是又余 1，因此这些 $p$ 不是 $A$ 的因子。这是由我们当初的假设（仅有有限个质数）而导致的矛盾，因而这个假设是不成立的，从而它的反面必然是正确的，即质数有无限多个。</p><p>以上证明说明，想找一个最大的质数是不现实的。<strong>事实表明，即使找一个很大的质数，也是相当困难，现在计算机领域中广泛使用的非对称加密RSA的数学原理，就是基于这个事实。</strong>迄今为止，我们找到的最大的质数是 $2^{74207281}-1$，这个数字已经很大了，长达 2233 万位！</p><p>以上即是反证法的一个经典案例，至今该方法仍然是数学家们手中论证命题的一个强有力武器。</p><h2 id="质数的分布"><a href="#质数的分布" class="headerlink" title="质数的分布"></a>质数的分布</h2><p>质数这么多，有没有一个产生质数的通用公式呢？遗憾的是，人们做了很多次尝试，但都失败了。并没有一个公式可以做到这一点。那么，质数的分布有什么规律呢？我们用 $A_n$ 表示自然数 $1,2,3,…,n$ 中的质数个数，比如 8 以内的质数为 2，3，5，7，因此$A_8=4$, 我们查出，在 1 000 之内有 168 个质数，在 1 000 000 之内有 78 498 个，在 1 000 000 000 之内有 50 847 478 个。 我们令比值 ${A_n \over n}$ 表示前 $n$ 个自然数中质数的<strong>“密度”</strong>，可以得出如下表:</p><table><thead><tr><th>数值范围 1~n</th><th>质数个数</th><th>质数密度</th><th>1/${\ln{n}}$</th><th>偏差(%)</th></tr></thead><tbody><tr><td>1 ~ 100</td><td>26</td><td>0.260</td><td>0.217</td><td>20</td></tr><tr><td>1 ~ 1000</td><td>168</td><td>0.168</td><td>0.145</td><td>16</td></tr><tr><td>1 ~ ${10^6}$</td><td>78498</td><td>0.078498</td><td>0.072382</td><td>8</td></tr><tr><td>1 ~ ${10^9}$</td><td>50847478</td><td>0.050847478</td><td>0.048254942</td><td>5</td></tr></tbody></table><p>在自然数中，单个质数的分布式不规则的，但如果把注意力集中到由比值${A_n \over n}$给出质数的分布时，会发现这种不规则消失了，这个比值所服从的简单规律，是整个数学中最著名也最值得称道的发现之一。该规律表述为：<strong>从 1 到任何自然数 $n$ 之间，所含质数的百分比，近似由 $n$ 的自然对数的倒数表示</strong>，写成数学语言，可以有以下描述:</p><p><center>当 $n$ 足够大时，${A_n \over n} \sim {1 \over \ln{n}}$</center><br>白话一点，就是当 $n$ 增加时，$A_n/n \over 1/{\ln{n}}$ 趋近与 1。</p><p>质数分布的平均状态，可以用对数来描述，这是一个很引人注目的发现，两个似乎完全无关的数学概念，在事实上竟有如此紧密的联系！不得不说很令人奇怪。</p><p>这个发现，最初是由伟大的数学家高斯发现的，他当时也只是猜想，而要给出证明，他那个时代的数学是远远不够的，这个定理虽然只涉及最基本的概念，但其证明，必须用到近代数学中最有力的方法。从高斯猜想后的 100 多年，到 19 世纪末，该定理才得以完整证明。由于证明太繁琐，这里就不介绍了。</p><h2 id="勾股定理和无理数"><a href="#勾股定理和无理数" class="headerlink" title="勾股定理和无理数"></a>勾股定理和无理数</h2><p>勾股定理，是数学中一个老少皆知的定理，在西方也叫毕达哥拉斯定理，这是一个很古老的定理，说的是在一个直角三角形中，两条直角边的平方之和，与斜边的平方相等。根据这一定理，毕达哥拉斯的一个弟子——希帕索斯，在求正方形的对角线长度时，却发现无法用一个数，或者说无法用一个等价的分数来表示它。而按照毕达哥拉斯的理论来说，世间万物的关系都可以用整数或者正数之比来表达。现在却发现，无法找到一个可以表达正方形对角线长度的数。同时，希帕索斯还用上面提到的反证法，证明了边长为 1 的正方形对角线无法用两个整数之比表示，这里给出用现代算数的一个证明。</p><p>选定正方形的边长为1，而对角线的长为$x$，根据勾股定理，有$$x^2=1^2+1^2=2$$如果现在假设可以找到两个整数 $p$ 和 $q$，使 $x={p \over q}$，则<br>$$p^2=2q^2$$我们假设 ${p \over q}$ 已经是不可约的，因为分子和分母的任意公因子在一开始就可约去。由于2是上式等号右边的一个因子，所以左边的 $p^2$ 是偶数，故 $p$ 本身是偶数，因为奇数的平方只能是奇数，于是我们可以写出 $p=2r$，其中 $r$ 为整数。这时上式变为<br>$$4r^2=2q^2，或 2r^2=q^2$$由于 2 是左边的因子，则 $q$ 必须为偶数，这样一来 $p$ 和 $q$ 同时可以被 2 整除，和 $p$, $q$ 没有公因子的假设矛盾，因此 $p^2=2q^2$ 不成立，且 $x$ 不能是有理数。</p><p>无理数的发现，是数学史上最惊人的发现之一，现在任何一个中学生都会用根号表示无理数，这个看似很普通的记法，直到近代 16 世纪才被引入!</p><p>另外一个关于无理数的有趣的结论：<strong>无理数比有理数多得多，在数轴上随便选一个点，几乎不可能选到有理数！</strong></p><h2 id="神秘的圆周率"><a href="#神秘的圆周率" class="headerlink" title="神秘的圆周率"></a>神秘的圆周率</h2><p>第一次看到圆周率这个名词，还是读小学三年级时，教室外面的墙上，挂着各种名人照片，其中就有祖冲之，有这么一段话，大致内容就是他把圆周率精确到了小数点后面第7位，当时还不太懂什么是圆周率。这里不说 π 是什么，我们从另外一个问题，来看看这个神奇的 π。</p><p>18 世纪，数学领域开始出现一个新的分支，概率。有个法国科学家，提了一个概率问题，为了实验这个概率问题，需要有一面美国国旗，即红白条相 间的旗子。如果没有这种旗子，在一大张纸上画上若干道等距的 平行线也可以。再要一盒火柴——什么火柴都成，只要短于平行线间的距离就可以。现在把旗子铺在桌子上，扔出一根火柴，让它落在旗子上，如下图 1。它可能完全落在一条带子里，也可能压在两条带子上。 这两种情况发生的机会各为多大呢?<br><img src="/images/about-math/pic-1.png" alt="图 1 "><br>初一看，这是求概率问题，因此无非就是讨论下两种情况下的可能性，然后给个比值就行了。直觉上看，一般的概率应该都是一个确定的数，或者说有理数。然而事实真的是这样吗？</p><p>仔细考虑一下，火柴落在条带上的情况， 可由火柴中心点到最近条带边界的距离以及火柴与条带走向所成 的角度来决定，如图 2。图中给出了三种基本类型。为了简便起见，把火柴长度与条带宽度取相同数值，就说都为 2 英寸吧。如果火柴中点离边界很近，角度又较大(如例 a)，火柴便与边界相交。 如果情况相反，或者角度小(如例 b)，或者距离大(如例 c)，火柴就全部落在一条带子里。说精确些，如果火柴的一半长度在竖直方向的投影大于从火柴中点到最近边界的距离，则火柴与边界相交(如 a)，反之则不相交(如 b 和 c)。这句话可用图 2 下半部的图形表示出来。横轴以弧度为单位表示火柴落下的角度，纵轴是火柴的半长在竖直方向上的投影长度，在三角学中，这个长度叫做给定角度的正弦。显然，当角度为零时，正弦值也为零，因为这时火柴呈水平方向。当角度为 ${π \over 2}$ 即直角时，火柴取直立位置，与其投影重合，正弦值就是 1。对于处于两者之间的角度，其正弦的值由大家所熟悉的正弦曲线给出。<br><img src="/images/about-math/pic-2.png" alt="图 2 "></p><p>有了这条曲线，要计算火柴与边界相交或不相交的两种机会 就很方便了。事实上，我们已经看到(再看图 2 上部的三个例 子 )， 火柴中点离边界的距离如果小于半根火柴的竖直投影，即小于此时的正弦值，火柴就会与边界相交。这时，代表这个距离和角 度的点在正弦曲线之下。与此相反，火柴完全落在一个条带内时， 相应的点在曲线之上。</p><p>按照计算概率的规则，相交机会与不相交机会的比值等于曲 线下的面积与曲线上的面积的比值。也就是说，两个事件的概率， 各等于自己的那一块面积除以整个矩形的面积。可以由数学上证明，图中正弦曲线下的面积恰好等于 1。而整个矩形的面积为 ${\pi \over 2}$$\times 1$= ${\pi \over 2}$。我们得出结论：<strong>火柴与边界相交的概率为 ${1 \over {π/2}}={2 \over π}$ </strong></p><p>最后，一个勤劳的意大利数学家，做了这件无聊的事，他扔掷了 3407 根火柴，数一数有 2169 根与边界相交。以这个真实数据代入布丰公式，π 就变成了 ${2 * 3407 \over 2169}$，即 3.1415929，与精确值比，一直到第七位才开始不同！</p><p>这个例子对概率定律的实用性无疑是一个极有趣的明证。一个概率实验，居然能和 π 撤上关系！一方面证明了概率理论是正确的，因为由概率推出的数据和事实相符，另一方面，如果我们的祖先知道还能这么玩，根本不用掌握什么高深的技巧，直接扔针或者扔火柴，扔个十天半月的，只要扔的次数足够多，即可精确的估算出 π 的大小！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文仅仅摘取了几个很小的关于数学的片段，让大家体会下数学的魅力和美妙。也许有些理论或定理，我们在小学都学过，有的证明，我们也都能一看就懂，这里面都包含着严密的逻辑和推理过程，任何一条公式，理论，绝不是某个人上帝附体，或者灵光一闪而提出的，都是一个不断探索和积累的过程。人类的这种推理和思考过程，使我们和一般的动物有着本质的区别。这种能动性，让我们了解世界，进而改变世界。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>《什么是数学》</li><li>《从一到无穷大》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看的几本书里，都有提到一些数学方面的知识，有些符号和公式，放在现在，可能觉得没什么，一个小学生都能看懂，但却鲜有人知道，普及这些理论，需要几代人的不懈努力和探索。有些公式和推导，都堪称数学史上的经典，这里摘取一些片段，体会下数学的美妙，也让我们看看人类的智慧是无穷的&lt;br&gt;
    
    </summary>
    
      <category term="Math" scheme="http://xujimmy.com/categories/Math/"/>
    
    
      <category term="math" scheme="http://xujimmy.com/tags/math/"/>
    
      <category term="公式" scheme="http://xujimmy.com/tags/%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 的简单使用</title>
    <link href="http://xujimmy.com//2018/03/16/start-rabbitmq.html"/>
    <id>http://xujimmy.com//2018/03/16/start-rabbitmq.html</id>
    <published>2018-03-16T08:13:18.000Z</published>
    <updated>2019-11-08T08:55:08.646Z</updated>
    
    <content type="html"><![CDATA[<p>在高性能，高可用，解耦的系统中，消息队列 ( Message Queue) 组件是少不了的。现在市面是有各种流行的 MQ 框架，比如 kafka，rabbitmq，roketmq，zeromq等。各个公司为了适应自己业务的发展，有的会自己造轮子，而有的则在开源消息队里的基础上，做了进一步的改造和优化。本文使用 rabbitmq，作为消息队列的入门使用。<br><a id="more"></a></p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>使用 rabbitmq 之前，先说说什么是消息队列。我们为什么要用消息队列呢？可以用日常网购的场景来做对比。如我们在网上下了个单，我们不会坐着等商品到达。而商家发货后，也不会坐着等我们收到商品的消息。商家会把你的商品，发给快递公司，然后继续接收其他用户的订单。对于商家来说，他的工作已经做完了。而快递公司，则会把我们的商品准确发给我们。这样的方式，使商家和我们买家之间解耦，对于商家来说，他能处理更多的订单请求，而我们消费者，则可以在收到快递到达的通知时才去取。</p><h2 id="rabbitmq-中的几个概念"><a href="#rabbitmq-中的几个概念" class="headerlink" title="rabbitmq 中的几个概念"></a>rabbitmq 中的几个概念</h2><p>rabbitmq 也是类似的原理，在 rabbitmq 中，有几个重要的组件，<code>publisher</code>，即生产者，是产生消息的一方，类似于商家，<code>exchange</code>，交换器，生产者会把消息发往<code>exchange</code>，作用相当于快递公司，<code>queue</code>，队列，接收<code>exchange</code>发过来的消息，相当于运输快递的交通工具，<code>consumer</code>，消费者，消息的接收方，也就是我们买家。在这个里面可以看到，生成者并不是直接将消息投到队列中的，需要经过一个交换器，交换器负责把消息路由到某个或者多个队列。</p><p>另一个比较重要的概念就是交换器类型，可以这么理解，中通快递公司，只会把商品放到中通快递的运输车上传递，而不能放到其他公司的运输车上。各个快递公司，也都只能把商品放到各自公司的车上。rabbitmq 中的交换器做的也是类似的事，它定义了一些规则，根据规则，rabbitmq就会把消息投递到指定的队列。这些规则称为路由键。交换器有四种类型：<code>direct</code>, <code>topic</code>, <code>fanout</code>，<code>headers</code>，每种类型实现了不通的路由算法。</p><ul><li><code>direct</code>: 这种交换器比较简单，它的路由规则是一个完全匹配模式，当它绑定了A队列，那么以后这个交换器中的消息，都会投递到A队列中。</li><li><code>topic</code>: 这种交换器的路由规则，可以使来自不同源头的消息到达同一个队列。比如不同级别的日志消息(info-log, warn-log, error-log) 都投递到 log 队列。</li><li><code>fanout</code>: 这种交换器类似广播模式，它会把收到的信息，广播到绑定到它身上的所有队列中。</li><li><code>header</code>: 匹配 AMQP 消息的 header 而非路由键，不太实用，或者基本不使用。</li></ul><p>有了以上概念，我们就可以搞一些事了。</p><h2 id="rabbitmq-的安装"><a href="#rabbitmq-的安装" class="headerlink" title="rabbitmq 的安装"></a>rabbitmq 的安装</h2><p>首先是安装，在 CentOS 上安装 rabbitmq 非常简单，一行命令搞定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install rabbitmq-server</span><br></pre></td></tr></table></figure></p><p>安装完毕后，直接启动服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure></p><p>启动完毕，就可以使用<code>rabbitmqctl</code>命令，对 rabbitmq 进行一系列操作，如查看 rabbitmq 的状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>考虑下有这样一个应用：它允许用户上传图片，当用户上传图片后，可以获得一定的积分，同时用户的好友，可以收到收到通知。你可以把这样的功能写成一个流程<br>upload_img -&gt; add_user_point -&gt; notify_others -&gt; success<br>形如<br><img src="/images/rabbitmq/p1.png" alt="方式1"></p><p>但这样带来的坏处是，当需求变更，不得不直接修改你的业务逻辑。如 pm 认为上传原始图片太占带宽，让你在上传图片前，先做压缩处理。或者在后面，添加记录日志的操作。每次修改，都不得不修改原来的代码。最终变得不可维护。另一方面就是性能问题，当有大量用户上传图片时，你的系统可能就不堪承受，最终服务不可用。问题就出在，这样的设计是强耦合的，增加积分，通知好友这些操作，不应该依赖于上传图片。需要把上传图片、增加积分、通知好友当做三个独立的服务，然后用一个桥梁，把三者再结合起来，达到解耦的目的，如下图所示。<br><img src="/images/rabbitmq/p2.png" alt="方式2"><br>这样，首先可以把工作量拆分，一个人写上传图片服务，一个人写增加用户积分服务，当有其他新增服务时，简单的接入即可。另一方面，当你的某个服务压力过大时，粗暴的继续加机器部署服务即可解决。下面通过一个简单的例子，来看看如何使用 rabbitmq 来拆分完成上述上传图片的需求。</p><ol><li><p>首先写上传图片服务，注释已经说明了问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//命令行参数，模拟用户上传图片的请求</span></span><br><span class="line">$image_id = $argv[<span class="number">1</span>];</span><br><span class="line">$user_id = $argv[<span class="number">2</span>];</span><br><span class="line">$image_path = $argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接到rabbit</span></span><br><span class="line">$conn = <span class="keyword">new</span> AMQPConnection(HOST, PORT, USER, PASS, VHOST);</span><br><span class="line"><span class="comment">//指定一个信道</span></span><br><span class="line">$channel = $conn-&gt;channel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个名为 upload-pictures 的交换器，类型是 fanout 模式, 后面的参数请参考api</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'upload-pictures'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将用户请求组装成一个消息</span></span><br><span class="line">$metadata = json_encode(<span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'image_id'</span> =&gt; $image_id,</span><br><span class="line">        <span class="string">'user_id'</span> =&gt; $user_id,</span><br><span class="line">        <span class="string">'image_path'</span> =&gt; $image_path</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage($metadata,</span><br><span class="line">                <span class="keyword">array</span>(<span class="string">'content_type'</span> =&gt; <span class="string">'application/json'</span>,</span><br><span class="line">                        <span class="string">'delivery_mode'</span> =&gt; <span class="number">2</span>));</span><br><span class="line"><span class="comment">//投递消息到 upload-pictures 交换器</span></span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">'upload-pictures'</span>);</span><br><span class="line"></span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>增加用户积分的服务，注释已经说明了问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="comment">//获得rabbit连接和信道</span></span><br><span class="line">$conn = <span class="keyword">new</span> AMQPConnection(HOST, PORT, USER, PASS, VHOST);</span><br><span class="line">$channel = $conn-&gt;channel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟增加用户积分的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_points_to_user</span><span class="params">($user_id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> sprintf(<span class="string">"Adding points to user: %s\n"</span>, $user_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明交换器</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'upload-pictures'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//声明了一个 add-user-point 的队列</span></span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'add-user-point'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//绑定队列到交换器</span></span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'add-user-point'</span>, <span class="string">'upload-pictures'</span>);</span><br><span class="line"><span class="comment">//创建回调函数</span></span><br><span class="line">$consumer = <span class="function"><span class="keyword">function</span><span class="params">($msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($msg-&gt;body == <span class="string">'quit'</span>)&#123;</span><br><span class="line">        $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;</span><br><span class="line">            basic_cancel($msg-&gt;delivery_info[<span class="string">'consumer_tag'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $meta = json_decode($msg-&gt;body, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    add_points_to_user($meta[<span class="string">'user_id'</span>]);</span><br><span class="line"></span><br><span class="line">    $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;</span><br><span class="line">        basic_ack($msg-&gt;delivery_info[<span class="string">'delivery_tag'</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//准备消费者</span></span><br><span class="line">$channel-&gt;basic_consume($queue,</span><br><span class="line">    $consumer_tag,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    $consumer);</span><br><span class="line"><span class="comment">//等待消息到达</span></span><br><span class="line"><span class="keyword">while</span>(count($channel-&gt;callbacks)) &#123;</span><br><span class="line">    $channel-&gt;wait();</span><br><span class="line">&#125;</span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建通知朋友的服务，类比于增加用户积分</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$conn = <span class="keyword">new</span> AMQPConnection(HOST, PORT, USER, PASS, VHOST);</span><br><span class="line">$channel = $conn-&gt;channel();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notify_friend</span><span class="params">($user_id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> sprintf(<span class="string">"notified user's %s friend: %s\n"</span>,</span><br><span class="line">        $user_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'upload-pictures'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'notify-user'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'notify-user'</span>, <span class="string">'upload-pictures'</span>);</span><br><span class="line"></span><br><span class="line">$consumer = <span class="function"><span class="keyword">function</span><span class="params">($msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($msg-&gt;body == <span class="string">'quit'</span>)&#123;</span><br><span class="line">        $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;</span><br><span class="line">            basic_cancel($msg-&gt;delivery_info[<span class="string">'consumer_tag'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    $meta = json_decode($msg-&gt;body, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    notify_friend($meta[<span class="string">'user_id'</span>]);</span><br><span class="line">    $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;</span><br><span class="line">        basic_ack($msg-&gt;delivery_info[<span class="string">'delivery_tag'</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">$channel-&gt;basic_consume($queue,</span><br><span class="line">    $consumer_tag,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    $consumer);</span><br><span class="line"><span class="keyword">while</span>(count($channel-&gt;callbacks)) &#123;</span><br><span class="line">    $channel-&gt;wait();</span><br><span class="line">&#125;</span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>很明显，上述中，上传图片服务是生产者，增加用户积分，通知消息两个是消费者。当后续有更多的服务需要加入时，只需要依葫芦画瓢，继续添加到 rabbitmq 中消费即可。而假如某个服务负载较高，需要更多的计算能力，也不必修改代码，只需要启动更多的消费者进程即可，而 rabbitmq 会负责对消息进行分发。</p><h2 id="组建-rabbitmq-集群和镜像队列"><a href="#组建-rabbitmq-集群和镜像队列" class="headerlink" title="组建 rabbitmq 集群和镜像队列"></a>组建 rabbitmq 集群和镜像队列</h2><p>加入了 rabbitmq 的系统架构，系统的稳定性也同样依赖消息队列。如果消息系统挂了，整个系统也不可用，组建集群是解决方法之一。rabbitmq 组建集群也非常容易，假如有两台机器：srv01（192.168.1.10），srv02（192.168.1.11）。</p><ul><li>分别在两台机器上安装 rabbitmq 并成功启动</li><li><p>为了让两台机器的 rabbitmq 正常通信，拷贝 srv01 的 erlang cookie 到 srv02，一般在<code>/var/lib/rabbitmq/.erlang.cookie</code>，重启 srv02 上的 rabbitmq 进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service rabbitmq-server restart</span><br></pre></td></tr></table></figure></li><li><p>停止 srv02 上的 rabbitmq 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure></li><li><p>重设 srv02 上的元数据和状态为清空状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl reset</span><br></pre></td></tr></table></figure></li><li><p>将 srv02 节点加入到第一个节点，<strong>这里需要注意，@ 后面写的是节点的 hostname，但实际 rabbit 是通过 IP 和节点通信的，因此，需要将 hostname 和 IP 做映射，在 srv02 机器上的 /etc/hosts 文件中，追加 192.168.1.10 srv01。 如果直接在 @ 后面写 srv01 的 IP 是无效的</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl join_cluster rabbit@srv01</span><br></pre></td></tr></table></figure></li><li><p>重新启动 srv02 节点的 rabbit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li><li><p>查看 rabbitmq 集群状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li></ul><p>如果在 nodes 节点信息中，看到有 rabbit@srv01, rabbit@srv02 字样，说明两个节点的集群已经配置完毕。</p><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>有了 rabbitmq 集群后，消息系统就高可用了吗？并不是，rabbitmq 集群只是一种伪高可用，实际上，集群中的多个节点之间，只会同步元数据，比如 exchange 元数据，queue 元数据等，但并不会同步队列的内容，一般情况下，很少单纯的使用集群模式，而是用镜像队列。这种方式下，每个节点都保存有所有的队列，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 rabbitmq 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据。写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上，生产环境下，都会用镜像队列模式。</p><p>配置镜像队列也不困难，接着上面集群模式，执行一条命令即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy mirror_queue <span class="string">"^"</span> <span class="string">'&#123;"ha-mode":"all","ha-sync-mode":"automatic"&#125;'</span></span><br></pre></td></tr></table></figure></p><p>这是给 rabbitmq 增加了一条策略，其中，mirror_queue 是起的名字，可任意，<code>^</code>是匹配规则，表示对匹配这些规则的 queue 做操作，操作就是后面的字符串，字符串是 k-v 形式，详细含义，可以参考 rabbitmq <a href="https://www.rabbitmq.com/ha.html" target="_blank" rel="noopener">官方链接</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上的简单例子可以看出，使用消息队列，可以很方便的将系统解耦，使系统有良好的扩展性。rabbitmq 是一个高性能的消息队列组件，使用和搭建集群也是非常方便的。<br>本文完整的实例代码，可以在<a href="https://github.com/hbxjw119/learnbylearn/tree/master/rabbitmq/php/img-upload" target="_blank" rel="noopener">这里</a>找到。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>《RabbitMQ 实战》</li><li><a href="https://www.rabbitmq.com/ha.html" target="_blank" rel="noopener">https://www.rabbitmq.com/ha.html</a></li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在高性能，高可用，解耦的系统中，消息队列 ( Message Queue) 组件是少不了的。现在市面是有各种流行的 MQ 框架，比如 kafka，rabbitmq，roketmq，zeromq等。各个公司为了适应自己业务的发展，有的会自己造轮子，而有的则在开源消息队里的基础上，做了进一步的改造和优化。本文使用 rabbitmq，作为消息队列的入门使用。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="消息队列" scheme="http://xujimmy.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="MQ" scheme="http://xujimmy.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>CSDN 的困境</title>
    <link href="http://xujimmy.com//2018/01/22/about-csdn.html"/>
    <id>http://xujimmy.com//2018/01/22/about-csdn.html</id>
    <published>2018-01-22T03:03:50.000Z</published>
    <updated>2019-11-08T08:55:08.645Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在微博上，看到CSDN的创始人发了这样一条微博，内容如下<br><a id="more"></a></p><p><img src="/images/csdn/csdn1.png" alt="蒋涛博客"></p><p>在他的微博里，他把目前CSDN的现状和困境，都罗列了出来。看得触目惊心<br><img src="/images/csdn/csdn.png" alt="csdn的困境"></p><p>这些问题，可以说大公司基本多多少少都有，具体到我们个人开发者，也是需要深刻反思的，毕竟</p><blockquote><p>当雪崩发生时，没有一片雪花认为自己有责任</p></blockquote><p>这里，我不打算谈软件架构之道，因为我经验尚欠，也只是一个小螺丝钉，达不到高屋建瓴的视角，这里只是想说下我看这几年 CSDN 的兴衰，以及用 CSDN 给我带来的感受。</p><p>记得之前还在学校时，CSDN 还是程序员讨论技术和写博客的圣地，调试代码时，遇到问题，都习惯在 CSDN 上寻找答案，因为那上面代码清晰，高亮设计，而且感觉答案的质量也高，基本都解决了我学习 C/C++ 时的问题。各路技术大牛纷纷在 CSDN 写博客，我记得印象较深的有 <a href="http://my.csdn.net/v_JULY_v" target="_blank" rel="noopener">JULY</a>， <a href="http://blog.csdn.net/MoreWindows" target="_blank" rel="noopener">MoreWindows</a>， <a href="http://blog.csdn.net/hackbuteer1" target="_blank" rel="noopener">buteer1</a>, 当时找工作时，没少看这几个牛人的博客。</p><p>JULY 在 CSDN 上算是一位很知名的博主了，写的程序员面试题系列，阅读量破千万，帮助不少小白入了码农的坑，现在他在北京已经创业三年，开了公司，当了 CEO。</p><p>MoreWindows 和我一样，都是成电毕业，是我的学长，当时在计算机学院，在学校论坛上，也小有名气，毕业去了微软亚洲研究院，他在 CSDN 上写的排序算法系列，多线程系列堪称经典，找工作时没少看。现在时常感慨，都是一个学校毕业的，人与人的差别，咋就这么大捏~</p><p>另外一个 butter1，也是一个大牛，博客上各种算法题，编程题，代码写得详细规范，记得当时太原出差，在城中村，住出租屋，条件艰苦，异常孤独，经常大半夜里，用 ipad 看他写的博客，受益匪浅，于是毕业进了互联网，而他毕业去了谷歌。。。</p><p>随着移动互联网带来的变革，以及各种自媒体创业，segmentdfault、简书、公众号、知乎专栏等纷纷崛起，从流量、定位、以及用户体验上，现在 CSDN 上的博客质量，已经明显不如从前，那些大牛们的 CSDN 博客，也鲜有更新。从百度里搜一个程序问题，排名靠前的几个链接，虽然大概率都是 CSDN，然而得到的内容，要么是大同小异，要么是抄袭、转载成风，一个错误的，或者没有说明原理的答案，一传十，十传百，根本不 work。博客几经改版，而体验却是越来越差。写博客的作者，偏低龄化，感觉是在校学生偏多，没有技术沉淀，在写每一篇文章时，对问题本质的分析较少，没有严谨态度，格式、文字等随意发挥，看起来比较费劲。而反观github，简书等，作者明显要更耐心，书写更仔细，该格式化的格式化，该高亮的高亮，读者看着也赏心悦目。CSDN的定位和风格，在这些兴起的高逼格产品面前，显得有些力不从心。</p><p>而另一方面，随着github pages，code pages兴起，建站变得越来越容易，个人的文章博客，有更好的托管平台，和更好的自定义方式，也不必受第三方平台的格式约束。CSDN、博客园这类产品也进一步失去空间和用户。</p><p>感觉 CSDN，已经不是从前的 CSDN 了，再也找不到我想要的答案了。也许，CSDN 博客没有变，变的只是我自己吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在微博上，看到CSDN的创始人发了这样一条微博，内容如下&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="http://xujimmy.com/categories/Life/"/>
    
    
      <category term="csdn" scheme="http://xujimmy.com/tags/csdn/"/>
    
  </entry>
  
  <entry>
    <title>关于 vps 和 shadowsocks 梯子</title>
    <link href="http://xujimmy.com//2018/01/20/about-vps.html"/>
    <id>http://xujimmy.com//2018/01/20/about-vps.html</id>
    <published>2018-01-20T03:20:00.000Z</published>
    <updated>2019-11-08T08:55:08.645Z</updated>
    
    <content type="html"><![CDATA[<p>近几年国内互联网“整风运动”愈演愈烈，各种翻墙服务都相继倒下，走丢的国外网站和服务也一个接一个，好在公司可以随意访问 Google，而回到家里，就没法用了，因此，为了科学上网，迫切需要有新的梯子，去看看外面的世界。俗话说，授人以鱼不如授人以渔，与其找梯子，不如自己建梯子。国外的 vps 给我们提供了一个理想的建梯子环境。本文使用亚马逊的 EC2 vps，使用著名的 shadowsocks 来自建一个梯子。<br><a id="more"></a></p><h2 id="申请亚马逊-EC2"><a href="#申请亚马逊-EC2" class="headerlink" title="申请亚马逊 EC2"></a>申请亚马逊 EC2</h2><p>之前用的是阿里云，但机房在国内，还是受到监管，没法搭建梯子，最近在亚马逊 <a href="https://amazonaws-china.com/cn/" target="_blank" rel="noopener">AWS</a> 上，开了一台云主机，新用户，免费使用1年，想着不用白不用。申请过程还是比较容易的，跟着步骤来，中间有两个地方可能稍微有点麻烦，一个是绑定信用卡，要准确填写信用卡的到期时间，不然验证会失败，然后就是在验证过程中，会给你打电话，让你按照电话提示，在手机上输入屏幕上的验证码，我接到电话时，电话里悄无声息，啥都没听到，不过还是把屏幕上的验证码输入了，然后就通过了，神奇。。。</p><p>申请成功后，就可以像阿里云那样使用了，需要注意的是，阿里云和亚马逊对于云主机的安全非常看重，因此有安全组的概念，防止用户的云主机被不法分子利用，沦为肉鸡。初始状态下，云主机除了 22 端口开放供 SSH 登录，其他端口都是不开的，当时在阿里云主机上 <a href="https://xujimmy.com/2017/12/01/https-blog.html">启用HTTPS</a> 服务时，就因为没开放指定端口，导致不成功。所以在亚马逊云的安全组配置中，我有了提防，然并卵，还是躺枪了。刚开始配置时，在安全组的页面上配置，死活没生效，后来看一篇文章，才知道，需要在实例面板，拖到最右边，有个安全组选择，只有这个安全组才是生效的，如下图，坑爹啊。。。根据选择的安全组配置下端口，比如下面要用的8388，保持，然后就OK了。在本地电脑上，尝试可否通过<code>telnet your_ip port</code>连到vps的指定端口。<br><img src="/images/vps/anquanzu.jpg" alt="安全组配置"></p><h2 id="使用-shadowsocks"><a href="#使用-shadowsocks" class="headerlink" title="使用 shadowsocks"></a>使用 shadowsocks</h2><p>vps 准备工作做好后，就可以用 shadowsocks 搭建梯子工具了。首先要明白 shadowsocks 的工作原理，简单的说，shadowsocks 分为客户端和服务端，客户端装在你的电脑或手机上，服务端装在 vps 上。shadowsocks 客户端会把你发出去的敏感的数据包，做一个加密，然后发到你国外的 vps 上，由于已经加密，墙不知道你发出去的是什么数据，也就没法封了，国外的 vps 装有 shadowsocks 服务端程序，它接收到你发的数据，解密，然后去请求指定网站，拿到响应，再加密，传给你的客户端，解密后，你就能看到想要的内容了。</p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>首先在 vps 上装服务端程序，有 Python 基础的话，很简单，先装好Python的<code>pip</code>包管理器，如果是 ubuntu，可以使用下面命令安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure></p><p>装好<code>pip</code>后，再来安装 shadowsocks，很简单，也一条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>没报错的话，说明安装成功，然后可以开始准备配置文件了，用任意编辑器，写一个名为 config.json 文件，文件内容如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,  </span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">8388</span>, </span><br><span class="line">    <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>, </span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,  </span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"password"</span>, </span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">600</span>,   </span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>, </span><br><span class="line">    <span class="attr">"fast_open"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>退出保存，然后就可以启动 shadowsocks 服务了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -c /path/to/config.json -d start</span><br></pre></td></tr></table></figure></p><p>其中，<code>-c</code> 参数后面接的是你的配置文件所在路径。启动完后，查看对应的进程是否存在<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep ssserver</span><br></pre></td></tr></table></figure></p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>服务端准备好后，再准备客户端，在 <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">github</a> 上下载对应的 shadowsocks 安装，win，mac，andriod都有，iOS在app store 下wingy+，8块钱，各平台配置大同小异，如在 mac 下，配置服务器如下图所示<br><img src="/images/vps/shadowsocks-client.jpg" alt="shadowsocks配置"></p><p>模式选择自动代理模式，配置好后，客户端的工作也基本做完了，但还别急着打开浏览器访问墙外的网站，因为浏览器出去的流量，还没有经过客户端的 shadowsocks 加密，需要下个chrome插件 : switchyOmega，填写代理规则，具体配置，可以<a href="https://glorystar.me/archives/chrome-use-switchyomega-autoproxy.html" target="_blank" rel="noopener">看这篇文章</a>，非常详细。打不开的朋友也没关系，我导出了一份配置，一键导入，非常方便，具体操作步骤：在下载完插件后，浏览器启用插件，然后点插件图标，进入设置菜单，在插件的设置页，选择导入导出子菜单，在在线恢复输入框中，输入我的备份地址：<a href="https://xujimmy.com/OmegaOptions.bak">https://xujimmy.com/OmegaOptions.bak</a> ,如下图<br><img src="/images/vps/switchomega.png" alt="恢复设置"><br>恢复完后，点击插件图标，选择自动切换模式，插件图标会变绿，完成以上步骤，应该就可以愉快科学上网了~</p><p>如果发现还是不行，就需要查原因，首先，确认 vps 上 ssserver 服务的端口是否可达，检查安全组，其次，确认请求是否到达 vps，检查 ssserver 访问日志，在 /var/log/shadowsocks.log，再然后，检查客户端配置。确认按上述方式配置正确。</p><h3 id="开启BBR，让网速更快"><a href="#开启BBR，让网速更快" class="headerlink" title="开启BBR，让网速更快"></a>开启BBR，让网速更快</h3><p>虽然上面可以正常上网，但速度还是让人捉急，我试过在 youtube 上看视频，卡成 ppt，下面开启 BBR，优化下网速，该方法适用范围：</p><ul><li>系统：CentOS 6+，Debian 7+，Ubuntu 12+</li><li>vps虚拟架构： KVM、Xen、VMware</li><li>内存：&gt;128M</li></ul><p>BBR是<a href="https://github.com/google/bbr" target="_blank" rel="noopener">Google开源的一个TCP网络拥塞控制算法</a>，其主要解决两个问题：</p><ol><li>充分利用宽带</li><li>降低网络延迟</li></ol><p>根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。这里不打算说该算法的原理，有兴趣的可以看知乎上这个<a href="https://www.zhihu.com/question/53559433" target="_blank" rel="noopener">回答</a>。这里主要记录下，怎么使用这个黑魔法。其实很简单，已经有大神给我们写了一键开启脚本，以root用户，运行命令如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure></p><p>这个命令先升级你的内核版本，然后开启BBR。运行完后，会提示重启机器，重启完后，登录，看看是否开启BBR，运行以下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>如果以上几个命令返回的结果里，都有bbr，则说明开启成功，再访问下youtube，看看网速是不是像施了魔法样，一点都不卡呢？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>自Google提出云计算以来，该领域已经得到长足发展，云计算，从一个概念，到现在各大厂商开始涉足，并出现丰富的产品线，让广大的用户，不用自己购买昂贵的物理主机服务器，通过按需付费的方式购买虚拟主机(vps)，即可快速使用，确实是一种重大创新。作为一个今年才开始使用云主机的码农来说，确实太晚了，目前从事的工作，也是和云计算相关。从使用云主机到现在，我已经深深喜欢上了这种产品，一度到处找便宜的 vps。目前国内比较著名，有口碑的就是阿里云和腾讯云。国外比较知名的 vps 厂商有vultr，bandwagon，linode，aws等。作为学计算机码农和学生，都建议尝试使用下 vps。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://teddysun.com/489.html" target="_blank" rel="noopener">https://teddysun.com/489.html</a></li><li><a href="https://glorystar.me/archives/Speed-up-shadowsocks.html" target="_blank" rel="noopener">https://glorystar.me/archives/Speed-up-shadowsocks.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近几年国内互联网“整风运动”愈演愈烈，各种翻墙服务都相继倒下，走丢的国外网站和服务也一个接一个，好在公司可以随意访问 Google，而回到家里，就没法用了，因此，为了科学上网，迫切需要有新的梯子，去看看外面的世界。俗话说，授人以鱼不如授人以渔，与其找梯子，不如自己建梯子。国外的 vps 给我们提供了一个理想的建梯子环境。本文使用亚马逊的 EC2 vps，使用著名的 shadowsocks 来自建一个梯子。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://xujimmy.com/categories/Tech/"/>
    
    
      <category term="vps" scheme="http://xujimmy.com/tags/vps/"/>
    
      <category term="shadowsocks" scheme="http://xujimmy.com/tags/shadowsocks/"/>
    
      <category term="bbr" scheme="http://xujimmy.com/tags/bbr/"/>
    
      <category term="云计算" scheme="http://xujimmy.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>本博客的一些插件和使用方法</title>
    <link href="http://xujimmy.com//2018/01/06/blog-update.html"/>
    <id>http://xujimmy.com//2018/01/06/blog-update.html</id>
    <published>2018-01-06T01:14:00.000Z</published>
    <updated>2019-11-08T08:55:08.645Z</updated>
    
    <content type="html"><![CDATA[<p>用hexo写博客已经有一段时间了，这里把本博客的一些觉得有意思的插件和优化整理出来，方便新手配置和学习。<br><a id="more"></a></p><p>本博客使用的hexo主题为<a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">maupassant</a>，符合宣传所说，<strong>大道至简</strong>的定位。在此基础上，我做了一些插件补充，主要有：</p><ul><li>本地搜索</li><li>文章字数统计，年度文章数量统计</li><li>leadcloud增加pv统计</li><li>文章版权</li></ul><p>下面分别介绍下，这几个插件的使用方法。</p><h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><p>本地搜索是主题自带的功能，如本博客右侧栏所示，输入关键词，即可在站内搜索博文信息。要使用此功能，首先需要在主题的<code>_config.yml</code>文件中，设置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self_search:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>然后，安装搜索插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p><p>这样，当你每次<code>hexo g</code>时，此插件都会在你博客的根目录，生成一个<code>search.xml</code>的文件，该插件就是根据此文件来做全文检索的。</p><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>如你所见，本博客的每篇文章，都有字数统计，以及阅读时长。也是通过插件方式实现，估计此插件作者应该是受简书启发而开发的。安装插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>安装好后，在主题的配置文件<code>_config.yml</code>中开启该功能<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>然后就可以在文章中使用了，使用方法是在主题的文章模板文件：<code>themes/maupassant/layout/_widget/post.pug</code>，在该文件适当位置，加入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if theme.wordcount == true</span><br><span class="line">    span= &apos; | &apos;</span><br><span class="line">    span</span><br><span class="line">      i.fa.fa-file-word-o</span><br><span class="line">    span.post-count=&apos; &apos; + wordcount(page.content) + &apos; 字&apos;</span><br><span class="line">    span= &apos; | &apos;</span><br><span class="line">    span</span><br><span class="line">      i.fa.fa-clock-o</span><br><span class="line">    span.post-count=&apos; 阅读约需 &apos; + min2read(page.content) + &apos; 分钟&apos;</span><br></pre></td></tr></table></figure></p><p>然后再部署时，就可以看到效果。此外，你还可以使用该插件的<code>totalcount</code>方法，来统计所有博文的总字数，比如：<code>totalcount(site, &#39;0,0&#39;)</code>。</p><h2 id="leadcloud-PV统计"><a href="#leadcloud-PV统计" class="headerlink" title="leadcloud PV统计"></a>leadcloud PV统计</h2><p>对于统计功能，其实可以使用更轻量级的工具，不蒜子。我抱着不折腾就手痒的心态，自己搞的，用的是<a href="https://leancloud.cn/" target="_blank" rel="noopener">leadcloud</a>。leadcloud的存储产品是一个云存储的解决方案，相比于自己维护一个数据库，用云存储的好处就是省心，但缺点也显而易见：数据的安全与隐私性。不过对于博客这样的统计功能，用云存储还是比较合适，只是希望厂家不要跑路。。。<br>要在博客中开启统计功能，需要以下几个步骤：</p><ol><li>在leadcloud官网申请一个账号，并建立一个新应用，主要是存储产品，然后新建一个叫<code>total_pv</code>的class，然后在此class下，添加一行数据，这个数据至少有一个<code>pv</code>的number字段。这里假设你已经看过官方的sdk，所有工作已经做好。</li><li><p>在应用的设置页面，拿到APP ID 和APP KEY，以及上面添加的数据的objectID，填入到主题的<code>_config.yml</code>文件中</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## visitor-count</span></span><br><span class="line"><span class="attr">visitor:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  APP_ID:</span> <span class="string">your</span> <span class="string">APP</span> <span class="string">ID</span></span><br><span class="line"><span class="attr">  APP_KEY:</span> <span class="string">your</span> <span class="string">APP</span> <span class="string">KEY</span></span><br><span class="line"><span class="attr">  OBJ_ID:</span> <span class="string">objectID</span></span><br></pre></td></tr></table></figure></li><li><p>在模板文件<code>themes/maupassant/layout/_partial/footer.pug</code>最后，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">  i.fa.fa-eye</span><br><span class="line">    span.visitors</span><br></pre></td></tr></table></figure></li><li><p>在模板文件<code>themes/maupassant/layout/_partial/after_footer.pug</code>最后，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if theme.visitor.enable == true</span><br><span class="line">    - var app_id=theme.visitor.APP_ID</span><br><span class="line">    - var app_key=theme.visitor.APP_KEY</span><br><span class="line">    - var obj_id=theme.visitor.OBJ_ID</span><br><span class="line">    script(type=&apos;text/javascript&apos;, src=&apos;//cdn.bootcss.com/jquery/3.2.1/jquery.min.js&apos;)</span><br><span class="line">    script(type=&apos;text/javascript&apos;, src=&apos;//cdn1.lncld.net/static/js/3.4.2/av-min.js&apos;)</span><br><span class="line">    script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/leandcnt.js&apos; + &apos;?v=&apos; + theme.version)</span><br><span class="line">    script.</span><br><span class="line">       visitorCount(&apos;#&#123;app_id&#125;&apos;, &apos;#&#123;app_key&#125;&apos;, &apos;#&#123;obj_id&#125;&apos;)</span><br></pre></td></tr></table></figure></li></ol><p>这里要注意的是，如果你的hexo模板渲染引擎无法解析<code>&#39;#{app_id}&#39;</code>变量，就去掉引号和<code>#</code>。我的机器上因为无法解析<code>pug</code>引擎中的变量，因此我换成了<code>jade</code>的方式。关于<code>pug</code>和<code>jade</code>，你只要知道这是两种模板渲染引擎即可，使用方式基本相似。文末我会说为何需要换。</p><ol start="5"><li>在<code>themes/maupassant/source/js</code>目录，添加<code>leadcnt.js</code>文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visitorCount = <span class="function"><span class="keyword">function</span>(<span class="params">app_id, app_key, obj_id</span>) </span>&#123;</span><br><span class="line">    AV.init(&#123;<span class="attr">appId</span>:app_id, <span class="attr">appKey</span>: app_key&#125;);</span><br><span class="line">    <span class="keyword">var</span> cnt=AV.Object.createWithoutData(<span class="string">'total_pv'</span>,obj_id);</span><br><span class="line">    cnt.increment(<span class="string">'pv'</span>,<span class="number">1</span>);</span><br><span class="line">    cnt.save();</span><br><span class="line">    cnt.fetch().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pv = cnt.get(<span class="string">'pv'</span>);</span><br><span class="line">        $(<span class="string">'.visitors'</span>).html(<span class="string">' | '</span> + pv);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;<span class="built_in">console</span>.log(error);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>添加完上述步骤，应该就可以在博客的footer部位，看到有pv数据了，每刷新一次，pv+1。</p><h2 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h2><p>为了显得专(zhuang)业(bi)，我给文章末尾添加了版权说明。使用方法如下：</p><ol><li><p>在主题配置文件<code>_config.yml</code>中开启</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copyright:</span> </span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  author:</span> <span class="string">author_name</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>themes/maupassant/layout/_widget/</code>目录下，添加<code>article_copyright.pug</code>模板文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div.article-footer-copyright</span><br><span class="line">  p= &apos;本文由 &apos; + theme.copyright.author + &apos; 发表，采用&apos;</span><br><span class="line">    a(href=&apos;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh&apos;) 署名-非商业性使用</span><br><span class="line">-禁止演绎4.0</span><br><span class="line">    | 进行许可</span><br><span class="line">  p=&apos;非商业转载请注明作者及出处，商业转载请联系作者本人&apos;</span><br><span class="line">  p=&apos;本文标题: &apos;+ page.title</span><br><span class="line">  p=&apos;本文链接: &apos;</span><br><span class="line">    a(href=url)= url</span><br></pre></td></tr></table></figure></li><li><p>在上级目录，<code>post.pug</code>文件中，在适当位置，引入<code>article_copyright.pug</code>文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">if</span> <span class="string">theme.copyright.enable</span> <span class="string">==</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">include</span> <span class="string">_widget/article_copyright.pug</span></span><br></pre></td></tr></table></figure></li><li><p>最后，根据审美，在<code>themes/maupassant/source/style.css</code>文件中，给版权信息添加css样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* article-footer-copyright */</span></span><br><span class="line"><span class="selector-class">.article-footer-copyright</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.8em</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f8f8f8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article-footer-copyright</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#01579f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本博客的配置，都放在的<a href="https://github.com/hbxjw119/blog" target="_blank" rel="noopener">github</a>上，只要你安装了hexo，以及必要的插件，都可以运行。综合来讲，hexo的自由配置度还是很高的。由于hexo最后会根据模板引擎，生成html静态文件，因此，基本不用担心插件过多而给性能带来损耗。对普通用户来讲，自由配置的基本门槛，就是了解一点模板引擎的知识。本博客的主题引擎，最开始是采用<code>jade</code>，由于商标问题，<code>jade</code>模板在去年已经切换为<code>pug</code>，因此maupassant主题的维护者也进行了更新，但变化基本不大，用户需要做的，就是安装<code>pug</code>模板引擎，然后将模板文件后缀改为<code>pug</code>。模板中变量的使用方式，也需要做细微调整，比如<code>#{variable}</code>，现在直接用<code>variable</code>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用hexo写博客已经有一段时间了，这里把本博客的一些觉得有意思的插件和优化整理出来，方便新手配置和学习。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://xujimmy.com/categories/Blog/"/>
    
    
      <category term="hexo" scheme="http://xujimmy.com/tags/hexo/"/>
    
      <category term="maupassant" scheme="http://xujimmy.com/tags/maupassant/"/>
    
      <category term="配置" scheme="http://xujimmy.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
