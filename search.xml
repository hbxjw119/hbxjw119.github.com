<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>虚拟内存简介</title>
      <link href="//2020/07/12/introduction-virtual-memory.html"/>
      <url>//2020/07/12/introduction-virtual-memory.html</url>
      
        <content type="html"><![CDATA[<p>虚拟内存是计算机领域中一个很重要的概念，不管是对于日常工作排查问题，还是技术面试，出现的频率都很高。之前对这块内容的理解一直只存在于头脑里，现在把它拿出来，形成书面记录。<br><a id="more"></a></p><blockquote><p>需要说明下，虚拟内存有两种理解：一种是操作系统把硬盘的一部分当内存使用，以达到扩大内存的目的，大学或者很多入门级电脑书籍里都这么说，这其实是不全面的，或者只是表象。另一种理解是计算机系统中对物理内存的一种抽象，这种理解更底层，更深层次，或者说本质的东西，本文介绍的是第二种。</p></blockquote><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>我们知道，冯·诺依曼结构的计算机中，任何一个程序想要运行，必须首先加载进内存，计算机的内存可以看成是一个连续的线性空间，同数组一样，也有下标，称之为内存地址，或物理地址。内存地址从 0 到 $N$，表示系统可以寻址的范围，例如，一个 4GB 的内存，内存地址范围为 $[0-2^{32}]$，也把这个范围称之为地址空间。程序只有加载到内存中，才能被 CPU 执行，如下图是一个简易的内存示例，每个格子代表一个内存地址，有 A、B 两个程序被加载到内存，A 占用了 [0-7] 这段内存区域，B 占用了 [17-28] 这段内存区域。其他空白的区域，可以被其他程序所使用。<br><img src="/images/virtual-memory/1.png" alt=""></p><h2 id="没有虚拟内存的年代"><a href="#没有虚拟内存的年代" class="headerlink" title="没有虚拟内存的年代"></a>没有虚拟内存的年代</h2><p>早期的计算机系统，程序可以直接访问整个内存，就如上图所示，程序员必须清楚的知道如何使用和管理主存，这是一个很麻烦的工作，程序员得确保他的程序在加载时，不能超过可用内存。当计算机发展成多任务系统时，即加载多个程序到内存，他们必须考虑以下问题：</p><ul><li>内存布局：多个程序如何共享主存的内存空间？例如上图， A，B 两个程序，如何保证它们在内存能“和平共存”？程序员必须知道 A 占用了哪些内存地址，B 占用了哪些内存地址，避免它们地址冲突、覆盖的情况。</li><li>内存碎片：随着多个程序的加载，内存开始出现一些碎片，如上图，A，B 两个程序中间的地址是空的，假如 [10-15] 这段内存又加载了一个程序 C，那么 [8-9]，[16] 地址剩下来，现在程序 D 想要一段大小为 5 的内存，但已经没有合适的地址分配给它了。这样 [8-9], [16] 就成了内存碎片。随着内存变大，程序加载数增多，碎片也变得越来越多，这是内存的极大浪费。</li><li>安全：由于程序可以访问整个内存空间，A 程序会不会有意或者无意读取 B 程序的数据？例如密码等一些敏感的信息？无论如何，这都是无法容忍的。</li></ul><p>可以看到，早期编程是很痛苦的，假想下，如果有一个自动的内存分配和管理机制，让程序员不用操心内存布局、碎片、安全等问题，那一定是极好的。于是，虚拟内存应运而生。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>在虚拟内存体系下，一个进程不能直接访问物理内存，而只能访问虚拟内存，它看到的是一个被称为虚拟地址空间的东西，进程只和虚拟地址打交道，然后由操作系统和硬件通过某种方式把虚拟地址转为实际的物理地址。这样，进程只需读写虚拟内存地址即可，根本不用管从虚拟地址到物理地址的转换，如下图所示。注意到，进程 2 使用的物理内存实际可以是不连续的。<br><img src="/images/virtual-memory/2.png" alt=""></p><h2 id="虚拟内存的好处"><a href="#虚拟内存的好处" class="headerlink" title="虚拟内存的好处"></a>虚拟内存的好处</h2><p>从上图的例子中，可以得出虚拟内存至少有以下好处：</p><ul><li>每个程序都有一个从 0 开始的，独立的虚拟地址空间，这样程序员就不用处理内存偏移这些琐碎的事情了，极大降低了编程的工作难度。</li><li>虚拟内存总是连续的，尽管实际映射的物理内存可能不连续。操作系统会把底层那些可用的、碎片化的内存整合成一个统一的虚拟内存地址，这就充分利用了碎片化的物理内存。</li><li>每个程序看到的虚拟地址空间大小是一致的，近似于无限，这样程序员就不用担心自己的程序太大而无法加载进内存。</li><li>虚拟内存保证了安全性，程序 A 和程序 B 的虚拟地址空间是独立的，它们无法访问到对方的地址，即使通过某种恶意手段访问到，也能被操作系统检测到并触发异常。同时，进程对自己虚拟地址空间的操作也不是为所欲为，如果对一个只读的地址写操作，也会引发操作系统异常，极大的保证了内存读写的安全性。</li></ul><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>上面我们也说到，虚拟地址最终会转换成物理地址，即给定一个虚拟地址 X，系统能把他转换成物理地址 Y。因此系统得保存虚拟地址到物理地址的映射关系。很容易想到维护一个 1 : 1 的映射表，即虚拟地址和物理地址一一对应，然而实际不可行，保存这样的一个映射表这需要占用大量的存储空间。</p><p>解决办法是通过把虚拟内存和物理内存分成连续、固定大小的块。虚拟内存中，我们把块称之为<strong>虚拟页（Virtual Page）</strong>，物理内存中，我们把块称之为<strong>物理页（Physical Page，有的地方也称之为帧，Frame）</strong>。绝大部分情况下，页的大小是 4KB，寻址时，以页为单位进行操作。同时，处理器上有个称为 <strong>MMU（Memory Management Unit）</strong>的部件，它的功能是将虚拟地址转换为物理地址，虚拟页和物理页间的映射关系保存在一个被称为<strong>页表</strong>的数据结构中，每个进程都有自己的页表，页表存放在内存，由操作系统管理。下图展示了这种映射关系，虚拟内存和物理内存中每个格子表示一个页。当应用程序读写一个虚拟地址时，MMU 会计算它的虚拟页索引，并在页表中找这个虚拟页对应的物理页，一旦找到，就返回给应用程序，这样就完成了一次实际的内存读写。<br><img src="/images/virtual-memory/3.png" alt=""></p><h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>上图 3 中，可以看到有的虚拟页并没有映射到物理页（编号6、7的虚拟页），当应用程序访问这种还没有映射的页时，找不到对应的物理页，这种情况被称为<strong>缺页（Page Missing）</strong>，缺页就会触发一个<strong>缺页异常（Page Fault）</strong>，MMU 会检测到缺页异常，并把控制权交给操作系统，操作系统会执行缺页异常处理程序，它会尽可能为这个虚拟页映射一个可用的物理页，如果找不到，就牺牲一个已经映射的物理页，把它回写到硬盘，然后把该页映射到新的虚拟页。当缺页异常处理程序返回时，它会重新执行导致缺页的指令，该指令把导致缺页的虚拟地址重新发给 MMU，由于现在页表已经有了映射关系，因此不会再引发缺页了。</p><h3 id="页面调度"><a href="#页面调度" class="headerlink" title="页面调度"></a>页面调度</h3><p>上述的这种在硬盘和内存交换页的行为，称为页面调度（Paging），或者页交换（Swapping）。页面调度有可能发生在缺页异常时，也可能发生在其他场景。由于内存总是稀缺资源，当一个应用程序暂时不活动，或者某些映射的物理页暂时未使用到，操作系统会把它先保存到硬盘里，等需要的时候，再从硬盘换到内存。这实际就提供了一种“部分加载”或“懒加载”的机制——直到应用需要某些数据时，才从硬盘中加载，否则先不加载。</p><p>页面调度对应用程序是透明的，应用程序不用考虑内存是否足够能加载它，正因为如此，在应用程序看来，内存是无限的，所以，在一个 4G 内存的机器上，可以运行需要 5G 或更多内存的程序。</p><p>但凡事都有两面性，换页也有负面作用。我们知道硬盘的速度远慢于内存(<a href="https://xujimmy.com/2019/09/29/computer-memory.html">10 万倍的数量级差距</a>)。因此换页时，操作系统把数据从硬盘拷贝到内存是一个很耗时的工作，表现就是“电脑突然卡了下”。当系统运行的程序过多，缺页异常频繁发生，系统不停的进行页面调度工作，换页操作花费的时间甚至比运行程序本身还要多，这时系统表现就是卡顿，这种情况称为<strong>系统颠簸（Thrashing）</strong>。处理方式就是对症下药：要么加大内存，或者关掉一些程序。</p><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>虚拟内存机制也很好的解决了进程的安全问题，有了 MMU 和页表，通过给页表加一些标志，可以实现一个进程只能访问属于它自己的虚拟内存，以及控制页的读写权限。任何试图访问一个不属于进程自己的的内存地址，或者对一个只读的内存地址进行写操作，都会被操作系统检测到，并抛出一个错误，Unix 系统中叫<strong>段错误（Segmentation Fault）</strong>，Windows 系统中叫<strong>非法访问（Access Violation）</strong>，通常此时操作系统会中止或杀掉进程。</p><p>虚拟内存还有很多其他的使用方式，例如内存映射文件。读写一个文件时，一般我们会通过 read/write 等系统调用的方式，把文件拷贝到内存。但如果使用内存映射的方式，可以省掉拷贝的操作，直接访问文件，就好像它已经被加载到了内存。当真正需要读写时，虚拟内存会保证把必要的数据从硬盘搬到内存，这种方式可以显著提高文件访问效率。</p><p>例如还有共享物理内存，当多个进程需要使用某个数据时，可以在物理内存中只放一份，然后在把各自的虚拟页指向它，这样就能达到共享内存的目的。典型的如 fork 系统调用创建子进程，实际就只是复制了一份父进程的页表，再配合写时复制机制，因此效率是很高的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟内存是对内存的一种抽象，使用虚拟内存时，CPU 寻址方式是虚拟寻址，即将虚拟地址转换为物理地址，这需要 MMU 硬件和操作系统的密切配合完成。虚拟内存系统简化了内存管理、链接、加载、代码和数据的共享以及访问权限的保护，是计算机系统中最重要的概念之一。理解了虚拟内存原理，可以帮助我们写出安全、高效的程序，对排查系统问题也大有裨益。也就理解了“把一部分硬盘当内存使用”只是操作系统实现虚拟内存的一个方式而已。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.internalpointers.com/post/introduction-virtual-memory" target="_blank" rel="noopener">https://www.internalpointers.com/post/introduction-virtual-memory</a></li><li><a href="https://en.wikipedia.org/wiki/Virtual_memory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Virtual_memory</a></li><li>《深入理解计算机系统》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由病毒检测想到的一种面试题</title>
      <link href="//2020/05/22/poison-detect.html"/>
      <url>//2020/05/22/poison-detect.html</url>
      
        <content type="html"><![CDATA[<p>最近看到一个新闻，武汉开展全城新冠病毒核酸检测，要在 10 天内检测全市 1000 多万人中病毒携带者，这无疑是一个巨大的工程。这里我不打算深究医护人员是采用什么方式完成这项任务，主要想从这个检测事例中，引出一个有意思、又很有实践意义的问题：有 N 瓶无色无味液体（N 可能很大，如 100，1000，10000 等），其中混入了一瓶有毒液体，同时也有试剂，可以检测液体的毒性，如果试剂滴入到有毒液体中，液体变蓝，否则不变色，除此之外，不能通过其他方式检测。问题来了，如何用最少的检测次数，找到这瓶有毒液体。</p><a id="more"></a><p>这是一类问题，网上也能找到很多类似变种，如用小白鼠检测毒药，但本质都是一样的。回到上述这个问题，最直观的办法，当然是一瓶一瓶的检测，最坏的情况下，需要 N -1 次才能找到有毒的那瓶，有没其他更快的办法呢？学计算机的都知道二分查找，又叫折半查找，但这个问题条件不具备有序性，是没法用二分查找的。</p><p>我们不妨把问题简化下，假如 N=2，即在 2 瓶液体中找到有毒的那瓶，这就简单了，随便把试剂滴入一瓶液体中，如果这瓶液体变蓝，则找到，有毒的就是这瓶，如果没变蓝，那有毒的就是另一瓶。所以，N=2 时，检测一次，可以确认有毒液体。<br>把 N 加大点，当 N=4 时，如何快速找到有毒的那瓶呢？可以这样，把 4 瓶液体均分为 A，B 两组，将每组的两瓶液体取少量混合放入新瓶，这样会得到两瓶混合液体，用试剂检测这两瓶混合液体，问题又变成上面 N=2 的情况了，假如 A 组的混合液体变蓝，说明有毒液体是 A 组两瓶液体中的一瓶，再检测一次，可以确定有毒液体；假如 A 组的混合液体没变蓝，那有毒液体是 B 组两瓶液体中的一瓶，再检测一次，同样可以确定有毒液体。用这种方式，N=4时，检测两次，就可以确认有毒液体。<br>当 N=8 时，我们同样先分为 A，B 两组，将每组的 4 瓶液体取少量混合，用试剂检测两瓶混合液体，假如 A 组的混合液体变蓝，说明有毒液体是 A 组 4 瓶液体中的一瓶，问题回到 N=4 的情况了，再测两次，即可确认有毒液体。<br>所以，当 N=8 时，共检测 3 次，可以确认有毒液体。<br>那么，当 N=16 时，共需要检测 4 次，可以确认有毒液体。这比一瓶一瓶的检测快多了。那么，假如 N 不等于 2、4、8、16 这种 2 的 n 次幂时，怎么办呢？其实是一样的，例如 N=7，还是可以先分两组，一组 4 瓶，一组 3 瓶，后面的流程类似。于是，我们可以得到一个一般性结论：<strong>当有 $N$ 瓶液体，一瓶有毒，则只需要 $\log_2{N}$ 次检测，即可确定有毒液体。或者说，如果有 $k$ 次检测机会，那么最多可以确定 $2^k$ 瓶液体中混入的那瓶有毒液体</strong>。</p><p>这种方式，有点类似于“折半查找”，每检测一次，可以排除一半的数据集，把问题规模缩小一半。但注意，这绝对不是二分查找，或者折半查找。其实用计算机体系里的观点来看，这种问题被称为二进制问题。我们考察下上面，当 N=8 时的情况，把这 8 瓶液体按二进制编号。从 000 到 111，为了方便叙述，也把各瓶标上号，如下图。<br><img src="/images/virus-detect/pic-1.png" alt=""><br>然后，按每一个二进制位是否是 1 来采样混合液体，例如，E、F、G、H 可以取少量组成混合液体，因为他们的第 3 位二进制位是 1，同理 B、D、F、H 可以取少量组成混合液体，C、D、G、H 可以取少量组成混合液体。这样，我们有了 3 瓶混合液体，编号为 1、2、3，用试剂分别检测这 3 瓶混合液体，就可以确定有毒的那瓶液体的二进制编号。比如，如果 1 号变蓝，说明有毒液体肯定在 E、F、G、H 中的一个，即有毒液体那瓶的第 3 位二进制位为 1，如果 2 号变蓝，则说明有毒液体肯定在 C、D、G、H 中的一个，即有毒液体那瓶的第 2 位二进制位为 1，如果 3 号瓶没变蓝，则说明有毒液体不在 B、D、F、H 中，即有毒液体那瓶的第 1 位二进制位为 0。于是，有毒液体的那瓶二进制编号是 110，即 G 是有毒的。于是，我们检测了 3 次，最终确定了要找的那瓶有毒液体。</p><p>那么，如果有 100 瓶，则需要 7 位二进制编码，检测 7 次，即可知道有毒液体的那瓶二进制编码。</p><p>这种方法科学而高效，考察的是对二进制的理解和使用，在面试中也经常出现，这里总结了下一般思路。可能有同学已经知道用二进制方法，但真到面试时，却不知道怎么运用，给别人讲明白。还有的同学陷入一个思维误区，一上来，看到是查找问题，想当然的就套用二分查找，这也是很多人会犯的错误。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 protobuf</title>
      <link href="//2019/12/11/use-proto.html"/>
      <url>//2019/12/11/use-proto.html</url>
      
        <content type="html"><![CDATA[<p>在软件开发过程中，通常会使用 http 方式调用别人的接口获取数据，json 是一种流行且易读的数据交换格式，因此在调接口时，大家都习惯用这种格式。但对于微服务来说，或者对于高性能的 rpc 请求，http 和 json 实际还是有点过重，具体体现在，http 协议规定了在传输数据时，必须要有请求头，请求行，请求体。而 protobuf 格式的数据，可以很好解决这个问题。它对传输的数据做了很好的编码和压缩，虽然不易阅读，但传输的体积和效率，比 json 或 xml 好很多。与 protobuf 类似的，还有 thrift。虽然使用上有差别，但目的都是类似：高性能的序列化框架。本文记录下如何使用 proto 格式处理数据，或者称为消息。</p><a id="more"></a><blockquote><p>注：本文的 protobuf 示例使用的语言是 C++，protobuf 版本是 proto2。</p></blockquote><p>首先，我们都要写一个 proto 的文件，用来描述接口的字段以及类型，假定文件名叫 user.proto，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package user</span><br><span class="line"></span><br><span class="line">message User</span><br><span class="line">&#123;</span><br><span class="line">message Addr </span><br><span class="line">&#123;</span><br><span class="line">optional string province = 1;</span><br><span class="line">optional string city = 2;</span><br><span class="line">optional string road = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Gender</span><br><span class="line">&#123;</span><br><span class="line">MALE = 0;</span><br><span class="line">FEMALE = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Phone</span><br><span class="line">&#123;</span><br><span class="line">enum Type</span><br><span class="line">&#123;</span><br><span class="line">HOME = 0;</span><br><span class="line">COMPANY = 1;</span><br><span class="line">&#125;</span><br><span class="line">optional Type type = 1 [default = HOME];</span><br><span class="line">optional string no = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">optional string name = 1;</span><br><span class="line">optional Gender gender = 2;</span><br><span class="line">optional uint32 age = 3;</span><br><span class="line">repeated Phone phone = 4;</span><br><span class="line">optional Addr address = 5;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是 user.proto 的定义，有几点值得注意：</p><ul><li>每个 proto 都要声明 package，以表明本 proto 的作用域，类似于 java 中的 package。</li><li>如果使用的 proto 版本是 v3，则文件第一行得写<code>syntax = &quot;proto3&quot;</code>，如果是 v2 版本，则可以省略。</li><li>message 是 proto 中最基本的关键字，写 message 就如同定义一个类一样，有各种字段，以及字段的类型，常用的基本类型有 uint32，uint64，string，message 也可以嵌套定义，因此也有复合类型，如上面的 Addr，就是复合类型。</li><li>每个字段都有序号，序号是 protobuf 在序列化和反序列时用来做标识，对于使用者来说不用过多关注，同时序号没有特别要求，可以调换字段位置，序号也可以不连续，但序号不能重复，序号最大 2^29-1，不过一般也不会定义这么大的序号。</li><li>字段可以有默认值，如上面的 Phone Message 中的 type 字段。</li></ul><p><strong>写好 proto 文件，就相当于写了一份类的说明书</strong>，可以使用 protobuf 提供的编译器生成相应的类和 api，如果已经下好了 protobuf，可以执行下面语句。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=<span class="variable">$SRC_DIR</span> --cpp_out=<span class="variable">$DST_DIR</span> <span class="variable">$SRC_DIR</span>/user.proto</span><br></pre></td></tr></table></figure></p><p>其中，SRC_DIR 是 user.proto 所在的目录，DST_DIR 是生成文件所在的目录，执行完后，DST_DIR 下会多了几个文件：<code>user.ph.h</code> 和 <code>user.ph.cc</code> ，打开文件，会发现是 User 类的定义，以及各种 api 方法。使用起来也很方便，下面是各种字段类型的读写操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.ph.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line">user::User admin;</span><br><span class="line">admin.set_name(<span class="string">"jim"</span>);</span><br><span class="line">admin.set_gender(user::User::Gender::MALE);</span><br><span class="line">admin.set_age(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">auto</span> phone = admin.mutable_phone()-&gt;Add();</span><br><span class="line">phone-&gt;set_type(user::User::Phone::Type::COMPANY);</span><br><span class="line">phone-&gt;set_no(<span class="string">"13599999"</span>);</span><br><span class="line"><span class="keyword">auto</span> addr = admin.mutable_address();</span><br><span class="line">addr-&gt;set_province();</span><br><span class="line">addr-&gt;set_city();</span><br><span class="line">addr-&gt;set_road();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 admin 填充完毕，可以进行序列化存到文件，或者 rpc 传输，这里省略</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作</span></span><br><span class="line"><span class="built_in">string</span> name = admin.name();</span><br><span class="line"><span class="keyword">if</span> (admin.has_age()) &#123;</span><br><span class="line">int32 age = admin.age();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> gender = admin.gender();</span><br><span class="line"><span class="keyword">if</span> (gender == user::User::Gender::MALE) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; item : admin.phone()) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = item.type();</span><br><span class="line"><span class="keyword">auto</span> n = item.no();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> province = admin.address().province();</span><br><span class="line"><span class="built_in">string</span> city = admin.address().city();</span><br><span class="line"><span class="built_in">string</span> road = admin.address().road();</span><br><span class="line"></span><br><span class="line">user::User admin2;</span><br><span class="line">admin2.CopyFrom(admin);</span><br></pre></td></tr></table></figure><p>上面就是对 User 类的读写操作，总结以下几点：</p><ul><li>对于基本数据类型的字段，如 string，int32，写就是 set_xxx，读就是调用与字段名相同的方法（在这点上我感觉有些别扭，为何写是 set，读不用 get 统一下？是为了保持和 C++ 的风格一致？）。</li><li>要检查字段是否赋值，使用 has_xxx 方法。而如果字段是 repeated，就不能简单的使用 has_xxx，而要使用 xxx.size() 是否大于 0 来判断。</li><li>对于复合类型的字段读写稍微麻烦点，写操作基本都是调用 mutable_xxx，获取相应的指针，然后对指针进行逐一赋值。读操作稍微简单，链式调用方法即可。</li><li><p>对于 repeated 类型，可以使用 for 循环读取，赋值时，可以使用 for 循环赋值，也可以使用标准库中的 transform 来赋值，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(phone_list.begin(), phone_list.end(), google::protobuf::RepeatedFieldBackInserter(admin.mutable_phone()), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; phone) &#123; </span><br><span class="line">user::User::Phone p;</span><br><span class="line">p.set_type(phone.type());</span><br><span class="line">p.set_no(phone.no());</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;);</span><br><span class="line">其中，phone_list 是类似于 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;user::User::Phone&gt; 的列表。</span><br></pre></td></tr></table></figure></li><li><p>如果使用了 C++11，对于复合类型，尽量使用 auto 来定义接收值，可以简化不少。</p></li><li>可以使用 CopyFrom 对一个对象赋值，避免字段的逐一赋值。</li></ul><p>以上就是对 protobuf 的一些使用总结，如果你使用的是其他语言，如 java, python，也可以使用 proto 工具生成对应的类和 api，读写方式也基本类似。</p><p>总结：</p><ul><li>与 json 类似，protobuf 也是网络传输的一种方式，不同的是，它有自己的格式，这种格式不像 json 那么直观，但却相当紧凑，可以大幅度提高信息传递的效率。</li><li>由于 protobuf 有自己的编码方式，但我们不用关心它是怎么编码，只需要使用它提供的编译器，自动生成 get/set 代码，直接对消息进行读写即可，极大提高了生产力。</li><li>protobuf 有详细友好的官方文档，而且也不难读，基本所有的问题都能在官方文档里找到答案。</li><li>protobuf 不是自我描述的，不像 json，xml，你拿到相应的内容，就能直观的看到每个字段以及值，protobuf 是以二进制方式存储和传输，无法直接读出任何内容，而只能通过 proto 文件，生成相应的 api，通过 api 才能正确读取。这点既是优点，使数据具有一定的 “加密性”，也是缺点，数据可读性极差。<strong>所以 protobuf 非常适合内部服务之间 RPC 调用和传递数据</strong>。目前大厂内部各服务间的调用，很多都是构建在 protobuf 上的。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/tutorials</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protobuf </tag>
            
            <tag> rpc </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序员需要知道的数量级</title>
      <link href="//2019/09/29/computer-memory.html"/>
      <url>//2019/09/29/computer-memory.html</url>
      
        <content type="html"><![CDATA[<p>看书的时候，遇到这么一个表，我觉得非常有用，特此记录下。<br><a id="more"></a></p><p>下表展示了一个 3.3GHz 的 CPU，访问各存储设备的耗时，以及等比放大后的相对时间。</p><table><thead><tr><th>事件</th><th>延时</th><th>相对时间比例</th></tr></thead><tbody><tr><td>1个 CPU 周期</td><td>0.3 ns</td><td>1 s</td></tr><tr><td>L1 缓存访问</td><td>0.9 ns</td><td>3 s</td></tr><tr><td>L2 缓存访问</td><td>2.8 ns</td><td>9 s</td></tr><tr><td>L3 缓存访问</td><td>12.9 ns</td><td>43 s </td></tr><tr><td>主存访问</td><td>120 ns</td><td>6 分</td></tr><tr><td>固态硬盘（SSD）</td><td>50-150 us</td><td>2-6 天</td></tr><tr><td>旋转磁盘</td><td>1-10 ms</td><td>1-12 月</td></tr><tr><td>网络：从北京上海</td><td>30 ms</td><td>3 年</td></tr><tr><td>网络：从北京到旧金山</td><td>190 ms</td><td>19 年</td></tr><tr><td>TCP 重传</td><td>1-3 s</td><td>105-317 年</td></tr></tbody></table><p>从上面这张表，我们可以得到什么启示？我认为至少有以下几点：</p><ul><li>各存储器的访问时延，比我们想象中的要大，看似纳秒和微秒都很快，但实际上相差巨大，一次磁盘 IO 的时延，CPU 可以执行十万百万条指令。</li><li>各存储器访问的数量级，比如 SSD 访问在微秒(us)级别，而普通磁盘访问在毫秒(ms)级别</li><li>数据越“靠近” CPU，访问更快，但存储设备也越贵，存储容量也越小。如旋转磁盘现在 TB 级别很常见，而主存还基本是 GB 级别，L1~L3 缓存只有 KB 级别。这是一个速度和成本的博弈，如果想追求速度，钱不是问题，那么请用更好的 CPU，更大的内存，而不是更大的磁盘；反之，如果钱很紧张，数据访问的频次低，那么可以降低内存，而换上更大的硬盘。</li><li>所有的性能问题，都可以从四个方面优化：CPU，内存，IO，网络。且收益依次增高，如减少一次网络调用带来的收益，要比减少一次磁盘访问带来的收益更大更明显</li></ul><p>上面这个表，也印证了一句经典的话：<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>。L1~L3 缓存是 CPU 和内存之间的中间层，而内存又是磁盘和 CPU 缓存之间的中间层</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>云计算中的资源调度</title>
      <link href="//2019/08/11/schedule-in-cloud.html"/>
      <url>//2019/08/11/schedule-in-cloud.html</url>
      
        <content type="html"><![CDATA[<p>云厂商将机房中服务器的计算能力进行整合，如 CPU、内存等，并把这些硬件统一抽象为资源，然后按需卖给用户，这就是云计算理念，怎么把这些资源有效的管理和调度起来，最大化资源利用率，关系着云厂商的成本和营收，也是各厂商实现差异化的一个重要切入点。本文讲讲云计算中的资源调度，或者称为 scheduler。<br><a id="more"></a></p><p>openstack 中，有个叫做 nova-scheduler 的模块，类似于 k8s 中的 scheduler 组件，这两个模块就是资源调度，功能类似，是我们讨论的主角。要说明的是，本文并不打算拿源码逐行分析，而只是阐述资源调度里的一些核心思想。</p><h2 id="什么是资源调度"><a href="#什么是资源调度" class="headerlink" title="什么是资源调度"></a>什么是资源调度</h2><p><strong>资源调度要解决的核心问题是，用户创建的 VM 或 pod 应该分配到集群的哪个节点上</strong>。以及当某个节点负载超过报警阈值时，自动将 VM 或 pod 调度到其他负载较低的节点，以达到整个集群中所有节点的 CPU，内存，I/O 等指标保持大致相当的水平，类似于负载均衡。毫无疑问，这样做一方面提高集群的资源利用率，另一方面降低个别节点负载过高导致 VM 或 pod 性能跟着受影响。为了方便，下文只用 VM 代表被调度对象。</p><h2 id="怎么做资源调度"><a href="#怎么做资源调度" class="headerlink" title="怎么做资源调度"></a>怎么做资源调度</h2><p>资源调度的过程就是一个筛选最优解的过程，这里的解指的是集群中最优的节点。为了找到最优解，显然需要知道节点有哪些过滤条件，影响因子，以及各影响因子的权重。只要找到这些因素，我们就可以对各节点进行过滤筛选和打分排序，直到找出最优节点，筛选过程类似于下图。<br><img src="/images/schedule/filters.jpg" alt="筛选过程"></p><p>一般的，资源调度对节点的筛选会分为两个步骤：硬性条件筛选，软性条件筛选（需要说明下，这两个名词是我参考了文末的资料，并非原创）。在一些开源框架中，这两个步骤都有特定的叫法，如 openstack 中，这两个步骤分别称为 filter 和 weighting，在 k8s 中，分别称为 predicate 和 priority。</p><h3 id="硬性条件筛选"><a href="#硬性条件筛选" class="headerlink" title="硬性条件筛选"></a>硬性条件筛选</h3><p>硬性条件筛选，解决的是”能不能“的问题，即这个 VM 能不能建在这个节点上。那么有哪些硬性筛选条件呢？</p><ul><li><p><strong>节点类型</strong><br>  节点类型包括节点的固有属性，包括硬件类型，软件类型等。比如用户创建的 VM 对计算性能有要求，指定了 CPU 型号为 1802，因此那些 CPU 非指定型号的节点将直接被过滤掉；再比如，某个节点当前被设置为 disable 或 maintanced，表示该节点有问题或处于维护状态，这样的节点将被过滤掉。</p></li><li><p><strong>计算容量</strong><br>  整个很好理解，只有容量满足需求的节点才能通过筛选。比如用户创建的 VM 是 8 核 16 G，那么那些可用 CPU 数少于 8 或者可用内存少于 16 G 的节点将被过滤掉。</p></li><li><p><strong>磁盘容量</strong><br>  这个类似于计算容量，用户需要一个 500 G 的本地 SSD 磁盘，那些磁盘容量少于 500 G 的节点将被过滤掉。</p></li><li><p><strong>节点配额</strong><br>  当一个节点计算容量和磁盘容量都满足条件，并不一定能通过筛选，还要看该节点是否满足系统配额，比如系统规定，每个节点最多只能放有 10 个 VM，那么如果某节点已经到上限，此时也会被过滤掉。</p></li></ul><p>这里列举的只是一部分典型的筛选条件，还有其他的条件这里没有给出。</p><p>硬性条件筛选过滤掉了所有不满足条件的节点，剩下的节点都是满足创建 VM 的。硬性条件筛选不具有权重，筛选时，根据某一条件，节点要么能通过筛选，要么不能。任意一个条件筛选完后，发现没有可用的节点，那么就认为调度失败，要么直接返回错误，要么循环一直重新筛选，直到筛到有可用节点为止。<br>只有通过所有条件筛选的节点，才可以进行下一步软性条件筛选。</p><h3 id="软性条件筛选"><a href="#软性条件筛选" class="headerlink" title="软性条件筛选"></a>软性条件筛选</h3><p>通过上一步的硬性条件筛选，现在可以对剩下的所有节点进行软性条件筛选了。软性条件筛选解决的是”好不好“的问题，即 VM 建在这个节点上好不好，是不是最优的。我们也看下有哪些软性条件。</p><ul><li><p><strong>资源占用小</strong><br>  这个原则很直观：VM 最好是建在那些负载较低的节点上，这样有利于 VM 的快速启动以及性能。负载较高的节点，会导致上面的 VM 资源争抢严重。最坏的情况下，甚至导致节点宕机，因此最好不要选择负载高的节点。</p></li><li><p><strong>亲和性</strong><br>  亲和性是说，尽量将多个 VM 放在一个节点，或者绑定在一个节点上。例如，现在每个节点上有 500G 的磁盘空间供 VM 使用，假如 VM A 占用了 Node1 上的 300G，这时有一个创建 VM 的请求，它想要 200G 的空间，那么它可以选择节点 Node1，也可以选择其他 500G 的节点，但根据亲和性原则，它最好选择 Node1，因为这样正好可以把 Node1 上的磁盘用完，充分利用了磁盘资源。如果不这样选择，而是选择了其他有 500G 容量的节点，如 Node2，那么现在 Node1 上剩 200G，Node2 上剩 300G，如果这时再想创建一个 400G 或 500G 的 VM，Node1 和 Node2 均无法满足磁盘容量需求，这时不得不选择一个其他有 500G 的节点，如 Node3。这时 Node1 和 Node2 上剩余的磁盘资源就这么空着浪费掉了，有了亲和性，只需要使用 Node1 和 Node2 即可，这就是一个亲和性表现。</p></li><li><p><strong>打散分布</strong><br>  打散正好跟亲和性相反，也可以称为反亲和性。有的情况下，我们会按照某种规则，将资源尽量进行打散分布，例如，某个用户创建 5 台 VM，这里就可以将这 5 个 VM 做打散处理，将他的 VM 尽量分布在不同的节点上。这样的好处是，避免了某个节点宕机导致该用户在上面建的 VM 全挂，通俗点，不要将鸡蛋放在一个篮子里。这里是按照用户来进行打散筛选的，实际还有很多其他维度可以应用打散筛选规则，如根据标签打散，在创建 VM 时，给 VM 打上一个标签，有相同标签的多个 VM 打散分布在不同的节点上。</p></li><li><p><strong>本地基础镜像缓存</strong><br>  本地基础镜像是指 VM 运行时需要的 base 镜像。我们知道，KVM 使用了一种称为写时复制的技术，每个 VM 都是由一个 base 层和一个 top 层构成，base 层是只读的，里面的数据是操作系统，和一些预装程序，所有的写操作都在 top 层完成，这样的好处是，多个 VM 可以共用一个 base，而只有 top 层独立。base 一般称为基础镜像，也可以叫 backing file。这些基础镜像一般会集中放在一个镜像服务器上，当需要时，会被下载到指定节点，作为这个节点上所有相同系统的 VM 的 base。后面如果再创建了相同系统的 VM，就不用再去下载了，这样可以大大加快创建 VM 的速度。<br>  现在假如要创建一个 CentOS7 的 VM，Node1 上已经有 CentOS7 的 base，而 Node2 上没有，那么我们应该选择 Node1，这样免去了下载 base 的时间成本。</p></li></ul><p>软性条件筛选每个因素都可以有对应的权重，根据这些权重和分值，可以给通过了硬性条件筛选的所有节点计算加权分值，得分最高的节点即是最优节点。</p><p>最优节点找到后，调度的任务就完成了，剩下的就是在这节点上创建 VM 了。k8s 中，这个过程被称为 binding（pod 和 node 绑定）。</p><p>上面列出的只是一部分条件，其他的条件不一一列举，事实上，软性条件筛选灵活性很高，比硬性条件筛选更复杂，更主观，影响因子可以有很多，权重也可以动态调整，需要根据实际情况，业务情况，选择合适的条件，合理的权重。</p><p>总结下来，整个调度过程，就是一个不断过滤筛选的过程，输入 VM 的各项规格，调度器根据这些规格参数，以及集群中所有节点的属性，输出一个最合适的节点，可用下图来概括调度的作用。<br><img src="/images/schedule/scheduler.jpg" alt="调度器"></p><p>另外，上面的每个筛选流程都是独立的，也就是说，可以在任意两个流程中插入自己的筛选逻辑，只要符合期望即可，甚至完全不用框架提供的调度器，完全使用自定义的调度器。事实上很多企业内部自研的调度，都是在开源框架的基础上，加入了一些定制化的调度逻辑来满足自己的需求，比如，在硬性条件筛选阶段，把过滤效率高的流程提前，一次性过滤尽可能多的不符合条件的节点；软性条件筛选阶段，在允许一定容忍度情况下，寻找一个局部最优节点而不是全局最优节点，也能加快筛选过程。但也需要考虑到，筛选逻辑并非越多越好，过多反而会使筛选效率降低，得不偿失。</p><h2 id="资源重调度"><a href="#资源重调度" class="headerlink" title="资源重调度"></a>资源重调度</h2><p>经过上面的步骤，我们解决了如何为新创建的 VM 分配一个合理的节点。但需要注意，系统运行过程中，节点的各参数都是动态变化的，比如某节点现在负载较低，过了一会儿，该节点上面的 VM 做大量运算，或者节点执行像打快照这类比较重的操作，导致节点负载升高，超过警戒阈值，那么这时需要对节点上的 VM 做迁移操作，将部分 VM 迁到其他节点，以降低该节点的负载。迁到哪个节点上呢？这就又涉及到上面的调度过程了，还是需要经过硬性条件和软性条件筛选，这个过程就是重调度。</p><p>资源重调度是一个很重要，也很复杂的问题，最原始的方式是人肉盯监控报警，一旦出现负载高的节点，由人工手动迁移 VM，这种处理方式简单但费力，半夜被报警吵醒也是常事，相当于响应式处理。当集群节点数上去后，就需要一种能自动迁移的机制了，也就是智能调度，这种方式不仅免去人工操作的繁琐，还具有一定的预测能力，即依靠机器学习或神经网络等技术，能提前预知哪些节点可能会报警，那么就提前自动迁移该节点上的 VM，整个过程不需要人工干预。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>云计算完成了 CPU、内存、磁盘、网络等资源的抽象，资源调度解决的问题是如何将一个 VM，一个 pod，或者更抽象点说，一个应用，放到最合适的位置，以提高整个集群中节点的使用率，既不出现节点负载很高导致性能受影响，也不会有使用率低导致机器的浪费。本文简单介绍了资源调度的流程，包括硬性筛选和软性筛选，以及一些典型的筛选条件，实际使用的调度要比这复杂的多，基于此，智能调度也是未来资源调度领域的一个热点。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://tech.meituan.com/2019/08/22/kubernetes-cluster-management-practice.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/08/22/kubernetes-cluster-management-practice.html</a><br>《容器与容器云》</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openstack </tag>
            
            <tag> k8s </tag>
            
            <tag> schedule </tag>
            
            <tag> 资源调度 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 PXE 从网络安装操作系统</title>
      <link href="//2019/07/21/pxe-install-os.html"/>
      <url>//2019/07/21/pxe-install-os.html</url>
      
        <content type="html"><![CDATA[<p>平时我们拿到一台新电脑后，第一件事就是安装操作系统，安装系统常规方式是用光盘或 U 盘，需要提前在 BIOS 里设置引导顺序，让 CDROM 或 U 盘为第一引导项，重启后就可以走安装系统流程了，安装过程中还需要手动设置一些选项，如设置时区，硬盘分区等。等安装完后，再设置 BIOS 从硬盘启动，系统就算安装好了。这是家庭或电脑店里的常规方式。试想下，企业采购一批服务器，100 台甚至上千台，如果仍然采用这种方式，那运维得累死。这时，我们可以采用 PXE 方式，从网络给服务器安装系统。</p><a id="more"></a><h2 id="什么是-PXE"><a href="#什么是-PXE" class="headerlink" title="什么是 PXE"></a>什么是 PXE</h2><p>这里我不打算把维基百科中的概念性语言搬到这里，我们只需要知道，<strong>PXE 也是一种装机技术，唯一和平时装机方式不同的地方是，PXE 使用的系统镜像和内核，不是放在光盘和 U 盘里，而是放在了远端网络上，装机过程中，PXE 会自动从远端下载文件到本地，然后完成系统安装。</strong><br>更重要的是，它可以在远端 ks 文件的指导下，完成无人值守，自动设置，自动装机。因此，企业中大部分都会采用这种方式来进行批量装机。</p><h2 id="需要准备哪些东西"><a href="#需要准备哪些东西" class="headerlink" title="需要准备哪些东西"></a>需要准备哪些东西</h2><p>原理知道了，但具体需要哪些准备条件呢？既然是从网络引导安装，那么至少具备：</p><ul><li>远端必须得有个存放系统镜像以及一些装机所需文件的服务器，并且提供下载服务</li><li>设置本地机器从网络引导</li><li>本地机器必须具备 IP，以便从远端下载文件到本地</li></ul><p>第一个条件很好具备，拿一台机器起个 nginx 或 ftp 服务就好了。在 PXE 装机环境下，这个服务器被称为部署服务器（pxe server）。</p><p>第二个问题可以直接进 BIOS 设置，但如果要装机的数量庞大，也得累死。更通用的方式是通过机器的 IPMI 设备进行设置，IPMI 是一个通用接口标准，最重要的就是 BMC（Baseboard Management Controller），它是主板上的一块芯片，独立于 BIOS 和 OS ，并且可以配置 IP，通过这个 IP 可以对计算机进行远程控制，比如通电，断电，重启，设置引导项，查看计算机部件的物理信息，如 CPU 核数，甚至风扇温度等。BMC 配的这个 IP 我们称为<strong>带外 IP</strong>，看下面示意图。<br><img src="/images/pxe/bmc.png" alt="计算机上的bmc设备"><br>使用方式也很简单，一般服务器厂商都会给 IPMI 配置一个简单的 UI，直接在浏览器里输入带外 IP 即可打开。或者<code>yum install ipmitool</code>，这是 shell 环境下的一个 IPMI 管理工具，自带基本命令。假设机器的带外 IP 是 10.0.0.1，端口为 623，登录账号密码都为 admin，常用命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开机器电源</span></span><br><span class="line">ipmitool -I lanplus -H 10.0.0.1 -p 623 -U admin -P admin power On</span><br><span class="line"><span class="comment"># 关闭电源</span></span><br><span class="line">ipmitool -I lanplus -H 10.0.0.1 -p 623 -U admin -P admin power Off</span><br><span class="line"><span class="comment"># 重启机器</span></span><br><span class="line">ipmitool -I lanplus -H 10.0.0.1 -p 623 -U admin -P admin power reset</span><br><span class="line"><span class="comment"># 设置第一引导方式为 pxe</span></span><br><span class="line">ipmitool -I lanplus -H 10.0.0.1 -p 623 -U admin -P admin chassis bootdev pxe</span><br></pre></td></tr></table></figure></p><p>带外 IP 非常有用，很大程度上避免了需要去机房人肉操作的麻烦，比如线上一台物理机宕机，系统崩溃需要重启，打电话喊人进机房按重启键就太原始了，直接通过带外 IP，发条 reset 命令就可以重启了。</p><p>第三个问题看似不是什么问题，但不要忘了，在一个还没有装系统的机器上，是没有 IP 的，也没地方让你去执行 wget 之类的下载命令。<br>但每台机器上都有网卡设备，网卡有 mac 地址，我们可以在部署服务器上，起一个 DHCP 服务，让本地网卡发 DHCP 广播，部署服务器收到后，给本地机器网卡分配一个 IP。DHCP 工作原理大家可以翻大学的计算机网络，或者自行查看维基百科。这过程就像我们回到家里，手机自动连到家里 WIFI 一样，因为家里的路由器有 DHCP 服务，它帮手机自动分配了 IP，所以就可以上网了。自动分配 IP 的好处就是简单，免去人工配置，而且绝对不会有 IP 冲突。如果是手动配，效率低不说，还必须知道已经分了哪些 IP，避免再分配相同的 IP。但自动分配 IP 的弊端是，它分配的 IP 是临时的，比如今天给你手机分配的 IP 是 192.168.1.3，明天回来，给你分的可能就是 192.168.1.5 了。但只要你一直用，保持 WIFI 不断开，那这个 IP 也就不会变。在 PXE 装机环境中，总是会有个 DHCP 服务，由它给这个网络中的网卡分配 IP，为了节省，直接在部署服务器上起 DHCP 服务即可。</p><blockquote><p>需要注意的是，一个 PXE 装机网络中，只能有一个 DHCP 服务，这是由 DHCP 工作原理决定的。如果有多个 DHCP，会导致 IP 分配失败。</p></blockquote><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>上面的问题都有解答，可以来实际操作了，条件所限，本文使用 VirtualBox 来搭建 PXE 装机环境，所以没有真实的 IPMI 设备，但好在 VirtualBox 可以设置让 VM 从网络启动，因此不影响效果。<br>我们需要至少两个 VM，一个作为 pxe server，一个作为 client 待装系统。先来看下 PXE 装机流程图<br><img src="/images/pxe/pxe-boot.png" alt="PXE 装机流程"><br>可以看到，整个过程大致可分两步</p><ol><li>client 端申请 IP，这是执行后续步骤的先决条件</li><li>client 在指定目录拉取内核和必要的装机文件</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>必须得确保这两个 VM 所在的网络中，只有 pxe server 提供 DHCP 服务，如果你选择桥接模式，即 VM 和宿主机在同一个网络，那么得保证这个网络中没有其他 DHCP 服务，如果你在家里装，需要关掉家里路由器上的 DHCP；如果是在公司办公网装，那就得谨慎了，办公网的网络配置一般不能由自己规划，一不小心，可能导致办公网瘫痪，但可以用 VirtualBox 的内部网络，即 VM 和宿主机网络隔离，VM 之前互通，那么这天然就是一个良好的装机环境，但这种情况下，VM 是没法通外网的，要装一些包就很麻烦，要么让 VM 和宿主机共享一个目录，把包导入到 VM，要么先把 VM 设为桥接模式通外网，把需要的包装好后再设为内部网络模式。为了方便，下文用家庭桥接模式，网络拓扑如下<br><img src="/images/pxe/network-top.png" alt="PXE 装机网络拓扑"></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>准备 CentOS 的 ISO 安装包，创建一个 centOS 的 VM，设置网络为桥接模式，装好系统，作为 pxe server，暂称为 A，假设其 IP 为 192.168.1.5。装完后，将 ISO 安装包从宿主机传到 A 某目录，如 /tmp，后面需要用。</li><li><p>安装 dnsmasq，用来提供 DHCP 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install dnsmasq</span><br></pre></td></tr></table></figure><p> 将原来的 /etc/dnsmasq.conf 备份，重新生成一个配置，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网卡名，这里根据你的网卡填写</span></span><br><span class="line">interface=eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定</span></span><br><span class="line">dhcp-boot=pxelinux.0</span><br><span class="line">port=0</span><br><span class="line"><span class="built_in">enable</span>-tftp</span><br><span class="line">tftp-root=/var/lib/tftpboot/</span><br><span class="line"><span class="built_in">log</span>-facility=/var/<span class="built_in">log</span>/dnsmasq.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># dhcp 分配的 ip 范围</span></span><br><span class="line">dhcp-range=192.168.1.100,192.168.1.110</span><br><span class="line"><span class="comment"># netmask</span></span><br><span class="line">dhcp-option=1,255.255.255.0</span><br><span class="line"><span class="comment"># DNS</span></span><br><span class="line">dhcp-option=6,233.5.5.5,8.8.8.8</span><br></pre></td></tr></table></figure></li><li><p>安装 syslinux，tftp-server，vsftpd 提供内核和镜像下载服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install syslinux, tftp-server, vsftpd</span><br></pre></td></tr></table></figure><p>拷贝相关文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r /usr/share/syslinux/* /var/lib/tftpboot</span><br></pre></td></tr></table></figure></li><li><p>生成必要的目录和文件，上面的 dnsmasq 配置会从这里读取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/tftpboot/pxelinux.cfg</span><br><span class="line">mkdir /var/lib/tftpboot/centos7</span><br><span class="line">touch /var/lib/tftpboot/pxelinux.cfg/default</span><br></pre></td></tr></table></figure><p>default 文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default menu</span><br><span class="line">prompt 0</span><br><span class="line">label pxe</span><br><span class="line">kernel centos7/vmlinuz</span><br><span class="line">append initrd=centos7/initrd.img method=ftp://192.168.1.5/pub</span><br></pre></td></tr></table></figure><p>注意上面的 IP 地址为 pxe server 的 IP</p></li><li><p>挂载 ISO 文件，拷贝内核文件和镜像到指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop /tmp/centos-dvd.iso  /mnt </span><br><span class="line">cp /mnt/images/pxeboot/vmlinuz  /var/lib/tftpboot/centos7</span><br><span class="line">cp /mnt/images/pxeboot/initrd.img  /var/lib/tftpboot/centos7</span><br><span class="line">cp -r /mnt/* /var/ftp/pub/</span><br><span class="line">chmod -R 755 /var/ftp/pub</span><br></pre></td></tr></table></figure></li><li><p>启动所有服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start dnsmasq</span><br><span class="line">systemctl start vsftpd</span><br><span class="line">systemctl <span class="built_in">enable</span> dnsmasq</span><br><span class="line">systemctl <span class="built_in">enable</span> vsftpd</span><br></pre></td></tr></table></figure><p>ps 命令查看进程，确保上述服务都已经启动，并能从浏览器能访问到 ftp 中的文件，如果没法访问，查看是否因为防火墙的原因。到这一步 pxe server 就准备好了。</p></li><li>再创建一个 centOS 的 VM，称为 B，注意 B 的内存必须设置大于 1 G，否则会导致安装失败。设置 B 也为桥接模式，启动时按 F12，设置从网络引导。</li><li>如果一切顺利，可以看到 B 先广播了一个 DHCP 包，被 A 上的 dnsmasq 收到，响应了一个 DHCPOFFER，并给 B 分配了 IP，然后 B 从 A 的 tftp 目录下载内核，最后就进入到熟悉的装机界面了。</li></ul><h2 id="ks-自动安装"><a href="#ks-自动安装" class="headerlink" title="ks 自动安装"></a>ks 自动安装</h2><p>上面的安装流程，实现了从网络装机目的，但有个问题：进入装机界面后，仍然需要我们手动选择一些配置，批量装机的话，一台一台配置，还是很麻烦。我们可以通过 ks（kickstart） 文件，实现自动配置，即在需要选择的步骤时，由 ks 自动帮我们选择。</p><p>ks 文件实际就是个装机模板，它定义了系统装机时的一些配置选项，比如时间，网络，分区，用户名，密码等。一份典型的 ks 文件如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">install </span><br><span class="line">url --url=ftp://192.168.1.5/pub/</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># BASIC CONFIGURATIONS</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># System language</span></span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyboard layout</span></span><br><span class="line">keyboard --vckeymap=us --xlayouts=<span class="string">'us'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># System timezone</span></span><br><span class="line">timezone Asia/Shanghai --isUtc</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELinux configuration</span></span><br><span class="line">selinux --disabled</span><br><span class="line"></span><br><span class="line"><span class="comment"># System services</span></span><br><span class="line">services --enabled=<span class="string">"chronyd"</span></span><br><span class="line">firstboot --<span class="built_in">disable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use graphical install</span></span><br><span class="line">graphical</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reboot after installation</span></span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># System authorization information</span></span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># ROOT PASSWORD</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"></span><br><span class="line">rootpw --iscrypted <span class="variable">$1</span><span class="variable">$TzIdo</span>.bL<span class="variable">$rjBu</span>.XWo38VS0xQ/QWOYI.</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># NETWORK CONFIGURATIONS</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line">network --hostname=localhost</span><br><span class="line"></span><br><span class="line">network --bootproto=dhcp --device=eth0 --onboot=on</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># DISK PARTITIONS</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"></span><br><span class="line">autopart --<span class="built_in">type</span>=lvm</span><br><span class="line">clearpart --all --initlabel</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># POST SCRIPTS</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line">%post</span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br><span class="line"></span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># PACKAGES</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line">%packages</span><br><span class="line">@core</span><br><span class="line">chrony</span><br><span class="line">kexec-tools</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%addon com_redhat_kdump --<span class="built_in">enable</span> --reserve-mb=<span class="string">'auto'</span></span><br></pre></td></tr></table></figure></p><p>将上述内容写入到 /var/ftp/pub/ks/centos.ks 文件中，并修改上面第 4 部的 default 文件，指明 ks 文件的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default menu</span><br><span class="line">prompt 0</span><br><span class="line">label pxe</span><br><span class="line">kernel centos7/vmlinuz</span><br><span class="line">append initrd=centos7/initrd.img devfs=nomount ksdevice=bootif ks=ftp://192.168.1.5/pub/ks/centos.ks</span><br></pre></td></tr></table></figure></p><p>这样，当 client 下载内核后，会从指定路径下载 ks，然后在 ks 的引导下，自动装机，这样就不需要人工做任何操作了。更重要的是，只要共用一份相同的 ks，那么所有的机器装好系统后，设置都是一样的。</p><blockquote><p>CentOS 系统的模板类型叫 kickstart，而 ubuntu 的话，称 preseed，二者的格式有所不同</p></blockquote><h2 id="裸金属服务器"><a href="#裸金属服务器" class="headerlink" title="裸金属服务器"></a>裸金属服务器</h2><p>现在公有云和私有云中，有一类称为裸金属服务器的产品，如阿里云的神龙裸金属服务器，华为的 BMS 等，特点是具备了虚拟机的弹性，又有物理机的性能。实际上它就是一种物理机托管，云平台通过 IPMI 设备将这些物理机管理起来，用户要用服务器时，在云平台上选择好规格，点击创建，后端会根据规格，选择一台实际的物理机，通电，然后 PXE 装系统，装好后交付给用户。更进一步，可以直接把安装好系统的 ghost 或 qcow2 文件放在 pxe server，装机时直接释放到所有机器，就像我们恢复系统样，省去了安装系统的步骤，更加便捷效率更高。甚至本地机器根本不需要硬盘，直接挂载一个云盘，然后将系统释放到云盘即可。当用户使用完后，直接给该物理机断电，相当于归还过程。后面如果又有用户用，重新走通电装系统流程。在 openstack 项目中，有个叫 ironic 的子项目，就是裸机管理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 PXE 装机的基本原理和使用场景，这也是企业 IDC 机房大规模安装系统的方式，运维只要准备一个 pxe server，然后通过 ipmi 批量设置所有机器都从 PXE 引导，这样就不需要拿着光盘 U 盘在机房人肉操作了。实际使用中，可能会有更多的定制化，比如在 ks 里自动安装一些必备软件，比如装机前后，向某个 log server 发请求，表明装机情况等。云厂商的裸金属服务器产品，基本都基于这种原理，或者加入了一些定制化，使之更便捷装机效率更高。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.51cto.com/itwish/2154820" target="_blank" rel="noopener">https://blog.51cto.com/itwish/2154820</a></li><li><a href="https://www.tecmint.com/install-pxe-network-boot-server-in-centos-7/" target="_blank" rel="noopener">https://www.tecmint.com/install-pxe-network-boot-server-in-centos-7/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pxe </tag>
            
            <tag> ipmi </tag>
            
            <tag> dnsmasq </tag>
            
            <tag> dhcp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是 I/O 多路复用</title>
      <link href="//2019/06/27/what-is-io-multiplexing.html"/>
      <url>//2019/06/27/what-is-io-multiplexing.html</url>
      
        <content type="html"><![CDATA[<p>在高并发环境下，web 服务器需要处理成千上万的客户端连接，如何最大限度发挥单台机器的性能，使之在处理大量连接时仍保持较低的负载，这是个很重要的课题。本文介绍下解决此类问题的一种很经典的方式：I/O 多路复用。<br><a id="more"></a></p><h2 id="传统-I-O"><a href="#传统-I-O" class="headerlink" title="传统 I/O"></a>传统 I/O</h2><p>为了了解 I/O 多路复用是怎么产生的，我们先看下传统的网络 I/O 模式，也被称为 BIO(Blocking IO)。</p><p>在编写服务端网络程序时，传统的方式是这样的：创建套接字并绑定端口，然后用一个 while 循环，在循环里调用 accept，程序会阻塞，一旦有连接到来，accept 就返回，然后针对该连接做相应的读写处理。形式像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line"><span class="comment">// 绑定套接字</span></span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">2345</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 accept 等待客户端连接，程序阻塞，当有连接到达时才返回</span></span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    <span class="comment">// 对套接字读写</span></span><br><span class="line">    handle(socket);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line">serverSocket.colse();</span><br></pre></td></tr></table></figure></p><p>一般我们在刚学网络编程时，都会用这种的方式，也被称为单线程模式，这种模式的特点就是简单直白，方式固定，写起来较容易。但有个致命问题：同一时间，它只能处理一个客户端请求，因为它直接是在主线程中处理请求的，只有在上一个请求处理完毕，才能接着处理下一个请求，一旦某个请求处理较慢，那后面的请求只能等待。</p><p>把上面的单线程模式改下，对每个连接，新开一个线程单独进行读写处理，这样就可以同时处理多个连接了，形式如下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 创建和绑定步骤不变</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">       Socket socket = serverSocket.accept();</span><br><span class="line">       <span class="comment">// 新开一个线程，对套接字读写</span></span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           handle(socket);</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这种模式就是多线程模式，比上面的那种要高级一点，它可以同时处理多个连接，因为对每个连接的处理都是在一个单独的线程中，和主线程分离开来，主线程可以继续 accept 客户端连接。</p><p>但这种模式仍然存在问题：</p><ol><li>线程的创建和销毁的成本是很高的，创建线程需要消耗内存，1 个线程需要耗费 512K 到 1M 的内存，几十上百个可能看不出来，成千上万的话，内存很快就耗尽。</li><li>线程池能解决部分问题，但当请求过多，线程池仍然处理不过来，导致大量的请求超时，更严重的是，大量的线程会导致大量的线程切换，线程切换，或者说上下文切换是需要 CPU 开销的，线程切换越频繁，真正分配给业务的 CPU 资源就越少。</li></ol><p>上面的两种模式，不管是单线程模式还是多线程模式，我们都称之为阻塞模式(Blocking I/O)，是因为它们对连接的处理，都是以线程为基石，在一个线程中处理一个 socket 的读写，但实际情况是，线程的大部分时间都是在等待数据的到来。当调用 recvfrom 时，线程会等待着客户端的数据到达网卡，然后网卡把数据交给内核，然后内核再把数据拷贝到用户进程空间，这时 recvfrom 才会返回。这个过程<br>中，线程的绝大部分时间都是处于等待数据状态，什么也做不了。而下面要介绍的 I/O 多路复用，就是为解决此问题而生。</p><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h2><p>上面我们分析了由线程直接处理网络 I/O 的低效原因，想象下，当我们调用 recvfrom，发现数据还没准备好，就不傻等了，而是告诉系统：等数据准备好了，你告诉我下，我再来读。这时线程可以先去干点别的，比如去检查下有没有其他的连接。过了一会儿，系统产生了一个可读事件，告诉我们，你要的数据准备好了，可以来读了，这时就可以继续回到刚才的地方读取数据。这样效率不是就好多了吗？因为在等数据的同时，我还可以干其他的事情。这是一种<strong>非阻塞模式</strong>，那么这种“数据好了通知我们”的机制怎么实现呢？</p><p>其实，操作系统已经给我们提供了 <strong>select，poll，epoll，kqueue</strong> 这样的系统调用，来完成我们上面的要求，这些系统调主要干一件事：<strong>监听一个或多个文件描述符上的各类事件，一旦文件描述符上有事件产生，就返回</strong>。文件描述符，是 Unix 系统下的一个叫法，也称为 fd(file descriptor)，下文统称为 fd，fd 对应于 Windows 平台下的句柄（handle），一个文件描述符唯一标识了某进程打开的某个文件，Unix 的设计哲学就是一切皆文件，socket 也是文件，可以作为 fd 被监听。监听哪些事件呢？有：连接事件（acceptable），可读事件（readable），可写事件（writeable），关闭事件（closeable）等。于是通过这类系统调用，监听多个 fd，一旦某个 fd 上有某个事件产生，调用就会返回，于是我们知道“有事发生”，然后根据事件的类型，做不同的处理。因此，有时也把这种模型称为<strong>事件驱动模型</strong>，或者 <strong>Reactor 模式</strong>。</p><p>I/O 多路复用的关键，是它可以让内核监听 fd 的事件，而且可以同时监听多个 fd，和用一个线程处理一个 socket 连接有根本的区别，它只需要一个线程或进程，就管理了多个连接，我们可以用一句话来概括 I/O 多路复用：<strong>在一个线程或一个进程中，监听了多个 fd。这里的复用，指的是多个 fd，或者说多个连接，复用了一个线程或者进程。</strong></p><h3 id="I-O-多路复用的三种方式"><a href="#I-O-多路复用的三种方式" class="headerlink" title="I/O 多路复用的三种方式"></a>I/O 多路复用的三种方式</h3><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>首先来看 select，它的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></p><ol><li>nfds 为需要监听的最大 fd 个数+1。</li><li>中间的三个参数 readfds、writefds 和 exceptfds 指定我们要让内核监听读、写和异常条件的 fd。如果对某一个的条件不感兴趣，就可以把它设为空指针。fd_set 结构体可以理解为集合，存放的是 fd，可以通过下面的宏处理这三种 fd_set:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_CLR(inr fd, fd_set *fdset);   <span class="comment">// 清除 fd set 中相关 fd 的位</span></span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set *fdset); <span class="comment">// 测试 fd set 中相关 fd 的位是否为真</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *fdset);  <span class="comment">//  设置 fd set 中相关 fd 的位</span></span><br><span class="line">FD_ZERO(fd_set *fdset);         <span class="comment">//  清除 fd set 的全部位</span></span><br></pre></td></tr></table></figure></li></ol><p>select 的使用方法，我们看下面的例子，为了简单起见，我们只传入了可读事件的 fd，对其他的字段设置为 NULL，表示我们不感兴趣。在 for 事件循环中，调用 select，一旦 fd 有可读事件，就调用 read 处理读事件。其中判断可读是通过调用 FD_ISSET 来完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> nbytes;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* select call happens here */</span></span><br><span class="line">    <span class="keyword">if</span> (select(FD_SETSIZE, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"select"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(i, &amp;read_fds)) &#123;</span><br><span class="line">            <span class="comment">/* read call happens here */</span></span><br><span class="line">            <span class="keyword">if</span> ((nbytes = read(i, buf, <span class="keyword">sizeof</span>(buf))) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                handle_read(nbytes, buf);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* real version needs to handle EINTR correctly */</span></span><br><span class="line">                perror(<span class="string">"read"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后，程序会阻塞在 select，一旦 fds 中有可读事件，select 即返回，然后就可以遍历，查看到底是那个 fd 可读，并做相应处理。</p><p>I/O 多路复用概念被提出来后，select 是第一个实现它的系统调用，它是一个古老的实现，在 20 世纪 80 年代就诞生了，几乎所有的平台上都支持，良好跨平台支持也是它的一个优点。然而，它的缺点也不可忽视：</p><ul><li>监听的 fd 数量存在最大限制，在 Linux 上这个最大值是 1024，这在 select 诞生的那个年代来说足够了，但对现在互联网信息爆炸时代来说，极大限制了 select 的可用性。</li><li>其次，一旦监听的 fd 上有事件产生，select 仅仅会返回，但并不会告诉我们是哪些 fd 产生了事件，这时需要自己遍历所有的 fdset，依次检查每个 fd 上的事件标志位。显然，遍历的这个过程时间复杂度是 O(n)。因此，即使把上面的最大监听数改大，但带来的问题是效率的降低。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>再来看 poll，它是 select 的改进版，主要改进点有：</p><ul><li>去掉了 1024 这个最大监听数的限制。用户可以自定义监听 fd 数。</li><li>简化了 select 调用方式，它的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>不同于 select 使用三个位图来表示三个 fdset 的方式，poll 使用一个 pollfd 的指针实现，pollfd 结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> fd;                         <span class="comment">// file descriptor</span></span><br><span class="line">        <span class="keyword">short</span> events;                   <span class="comment">// requested events to watch</span></span><br><span class="line">        <span class="keyword">short</span> revents;                  <span class="comment">// returned events witnessed</span></span><br><span class="line">&#125; <span class="keyword">pollfd_t</span>;</span><br></pre></td></tr></table></figure></p><p>pollfd 结构包含了要监听的 event 和发生的 event，不再使用 select “参数-值”传递的方式，使得 poll 支持的 fd 集合限制远大于 select 的 1024。但是，poll 并没有解决 select 最根本的问题：它依然需要遍历所有 fd 来检查事件，遍历的时间复杂度依然是 O(n)。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>再来看看 epoll，epoll 和上面的 select 和 poll 有着本质的区别，除了没有最大监听数限制外，它还有一个最大特点：<strong>只返回有事件发生的 fd，所以不需要遍历所有监听的 fd 来找到哪些 fd 产生了事件。因此，它的时间复杂度为 O(k)，其中 k 为产生事件的 fd 数</strong>。因此，epoll 的效率不会像 select 和 poll 那样，随着监听 fd 的数量的增长而下降，那么它是怎么做的呢？来看下使用 epoll 时需要的三个系统调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>epoll_create： 创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 select 中的第一个参数，给出最大监听的 fd+1 的值，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</li><li>epoll_ctl：对指定 fd 执行 op 操作，epfd 是 epoll_create 的返回值。op 表示操作，用三个宏来表示：添加 EPOLL_CTL_ADD，删除 EPOLL_CTL_DEL，修改 EPOLL_CTL_MOD。分别添加、删除和修改对 fd 的监听事件，epoll_event 告诉内核需要监听什么事。</li><li>epoll_wait：等待 epfd 上的 io 事件，最多返回 maxevents 个事件。</li></ul><p>上面对函数的解释可能比较抽象，简单来讲：当我们调用 epoll_create 时，内核就创建了一棵红黑树和一个就绪（Ready）链表，其中，红黑数用于存储后面 epoll_ctl 传过来的 fd，以支持高效的查找、插入和删除。就绪链表用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个就绪链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。使用 epoll 的方式大概长这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10;</span></span><br><span class="line"><span class="keyword">int</span> event_count;</span><br><span class="line"><span class="comment">// 这里是创建网络程序的一般步骤</span></span><br><span class="line"><span class="comment">// ... socket(), bind(), listen()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建epoll文件描述符，出错返回 -1</span></span><br><span class="line"><span class="comment">// int epoll_create(int size) 从Linux2.6.8开始，size 值被忽略，不过为保持兼容需要设定为一个正整数</span></span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">1024</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events_in</span>[<span class="title">MAX_EVENTS</span>];</span> <span class="comment">// 记录套接字相关信息</span></span><br><span class="line">ev.events = EPOLLIN; <span class="comment">// 监视有数据可读事件</span></span><br><span class="line">ev.data.fd = fd; <span class="comment">// 文件描述符数据，其实这里可以放任何数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入监听列表，当fd上有对应事件产生时，epoll_wait会将epoll_event填充到events_in数组里</span></span><br><span class="line"><span class="comment">// 出错返回 -1</span></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 等待事件，epoll_wait 会将事件填充至 events_in 内</span></span><br><span class="line">    <span class="comment">// 返回获得的事件数量，若超时且没有任何事件返回0，出错返回 -1。timeout 设置为 -1 表示无限等待。</span></span><br><span class="line">    <span class="keyword">int</span> event_count = epoll_wait(epollfd, events_in, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;event_count; i++) &#123; <span class="comment">// 遍历所有事件</span></span><br><span class="line">        <span class="keyword">if</span> (events_in[i].data.fd == fd) &#123; <span class="comment">// 新连接请求</span></span><br><span class="line">            <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ev.events = EPOLLIN; </span><br><span class="line">            setnonblocking(new_fd);  <span class="comment">// 如果要使用Edge Trigger还需将 new_fd 设为非阻塞</span></span><br><span class="line">            ev.data.fd = new_fd;</span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_ADD, new_fd, &amp;ev); <span class="comment">// 将新连接加入监视列表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 其他的事件处理，如读写事件</span></span><br><span class="line">            <span class="keyword">int</span> new_fd = events_in[i].data.fd;</span><br><span class="line">            <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_DEL, new_fd, <span class="literal">NULL</span>); <span class="comment">// 不再监听fd，最后一个参数被忽略</span></span><br><span class="line">            close(new_fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll 有两种工作模式：LT（level trigger）模式和 ET（edge trigger）模式，也叫水平触发和边沿触发，默认的是 LT 模式</p><ul><li>LT 模式：当 epoll_wait 检测到 fd 事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li><li>ET 模式：当 epoll_wait 检测到 fd 事件发生，只有当 fd 事件变化时，即从 unreadable 变为 readable 或从 unwritable 变为 writable 时，它才返回事件 fd，因此应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此 fd 事件。</li></ul><p><strong>一句话：如果 fd 上有事件发生，LT 模式下会一直通知你，ET 模式只会通知一次。</strong></p><p>因此，如果 epoll 工作在 ET 模式，正确的读写方式应该如下所述，具体描述可以参考<a href="http://kimi.it/515.html" target="_blank" rel="noopener">这篇文章</a>，这里只说结论：</p><blockquote><p>读：只要可读，就一直读，直到返回 0，或者 errno = EAGAIN<br>写：只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN</p></blockquote><p>ET 模式也称为高速模式，在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接字模式，以避免由于一个 fd 的阻塞读/阻塞写操作把处理多个 fd 的任务饿死，如上面代码的第 25 行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnonblocking(new_fd);</span><br></pre></td></tr></table></figure></p><p>epoll 的上述特点，使 I/O 多路复用系统的性能提升到一个新的台阶。当管理的连接数不多时，使用 select/poll 和使用 epoll 的差别不大，但是当连接数上十万百万时，就会发现 epoll 的效率远高于 select/poll。因为在互联网大量并发的连接场景下，实际同一时刻，真正活跃（Active）的连接，其实只占少数，其他的都是空闲（idle）状态。epoll 不遍历所有连接，只对活跃的连接做处理。</p><blockquote><p><strong>需要注意的是：epoll 是 Linux 2.6 内核版本引入，只用于 Linux 平台，BSD 或 MacOS 对应的实现就是 kqueue，Windows 下就是 IOCP</strong>。</p></blockquote><h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><p>实际上，当我们使用 I/O 多路复用时，也很少会直接调用 select/poll/epoll，这样开发周期长，对开发者有较高要求，出问题难以调试，直接使用现有的库会大大降低开发难度，如 libevent，netty 等，他们对于不同的平台底层使用不同的方式，比如你是 MacOS，底层就用 kqueue，如果是 Linux 2.6或更新，则用 epoll。这些库提供了一套统一的 API，好处是允许你的代码在不同平台上运行而不需要改变任何代码，用户只需直接使用即可。</p><h2 id="I-O-多路复用的问题"><a href="#I-O-多路复用的问题" class="headerlink" title="I/O 多路复用的问题"></a>I/O 多路复用的问题</h2><p>细心的同学会发现，I/O 多路复用是单线程的，不能充分利用多核；同时，单线程模型事件处理中，不能有阻塞，一旦发生阻塞，会大大降低该模型性能，甚至不如多线程模型的 BIO ，这就对开发者的技术有更高的要求了。<br>另一方面，基于事件驱动的 I/O 多路复用，仍然属于<strong>阻塞型 I/O</strong>，它会阻塞在等待事件发生的系统调用。</p><h2 id="I-O-多路复用案例"><a href="#I-O-多路复用案例" class="headerlink" title="I/O 多路复用案例"></a>I/O 多路复用案例</h2><p>I/O 多路复用技术，已经在很多高性能软件和系统中得到广泛使用，只要弄明白了 I/O 多路复用的底层原理，也就明白那些优秀的软件为何性能很高了。经典的如 Redis，我们知道 Redis 是一个高性能的缓存服务器，它是单线程的，但它的性能并没有因为单线程而降低，反而特别高效，其中一个很重要的原因就是使用的 I/O 多路复用。在 Redis 内部，将客户端的套接字以文件事件进行抽象，客户端的连接，读写等操作，均会在 Redis 产生相应的文件事件，然后由相应的事件处理器进行处理，而 Redis 的单线程，可以监听成千上万个套接字，从而保证了高效的网络通信。同时，Redis 有良好的跨平台特性，由此我们可以断定，Redis 底层并没有写死使用 epoll 方式，因为那样会限制它只能运行于 Linux 平台，实际上，在我们编译 Redis 时，Redis 会根据平台情况，选择使用最合适的方式。</p><p>再如 Nginx，Nginx 是一款优秀的，抗并发能力很强的 web 服务器，在它的 Worker 进程中，也是通过 kqueue、epoll 等事件通知机制循环处理连接请求，可以使 Nginx 在高并发的情况下，仍然保持较低的 CPU 使用率，同时它也有良好的跨平台特性。nginx 的架构模型可以参考<a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener">这篇文章</a></p><p>再如 Netty，Netty 是 Java 写的高性能网络编程框架，它是 Java NIO 库的进一步封装，大大简化了 NIO 的使用方式，Netty 的网络部分使用了经典的 Reactor 模式，其中的 IO 线程 NioEventLoop 聚合了多路复用器，称为 Selector，根据平台选择不同的 I/O 多路复用，如 kqueue、epoll。同时，它可以搭配线程池使用，每个线程都是一个 Selector，成为多线程的 Reactor 模型。因此它的性能也非常强劲。Netty 的线程模型可以看<a href="https://www.infoq.cn/article/netty-threading-model" target="_blank" rel="noopener">这篇文章</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面，我们讨论了传统的 BIO 模式的弊端，以及 I/O 多路复用的原理和经典使用案例，那么我们以后写网络程序，是不是无脑用 I/O 多路复用呢？得看场景：</p><ul><li>如果你的应用并发量不大，用户的请求连接少，连接不是瓶颈，那么请直接使用 BIO+多线程方式，简单易调试，完全用不着 I/O 多路复用，这样只会增加代码的复杂度，出问题难以调试。</li><li>如果你的应用并发量高，需要同时处理海量的连接，那么请使用 I/O 多路复用方式。但是记住，你必须始终保持异步思想，事件处理中不要有任何阻塞操作。至于是用 select/poll 还是 epoll，请看<a href="http://cxd2014.github.io/2018/01/10/epoll/" target="_blank" rel="noopener">这篇文章</a></li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></li><li><a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll" target="_blank" rel="noopener">https://eklitzke.org/blocking-io-nonblocking-io-and-epoll</a></li><li><a href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html</a></li><li><a href="https://www.zhihu.com/question/20122137" target="_blank" rel="noopener">https://www.zhihu.com/question/20122137</a></li><li><a href="http://kimi.it/515.html" target="_blank" rel="noopener">http://kimi.it/515.html</a></li><li><a href="https://segmentfault.com/a/1190000016875057" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016875057</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> select </tag>
            
            <tag> epoll </tag>
            
            <tag> BIO </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 中 Future 和异步任务</title>
      <link href="//2019/05/29/java-Future-and-Executor.html"/>
      <url>//2019/05/29/java-Future-and-Executor.html</url>
      
        <content type="html"><![CDATA[<p>Java 中的多线程技术一直是个热门话题，而线程池、异步任务是多线程编程中绕不开的一个技术要点，本文介绍下 java 中的 Future 相关使用方法以及任务执行框架 ExecutorService。</p><a id="more"></a><h2 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h2><p>先看一个案例：用多线程输出 1 亿内的所有质数，并要求输出的质数顺序是排好序的。</p><p>如果单纯要完成质数输出，有很多方式，比如将 1 亿数字平均分为 100 份，每份 100 万个，用 100 个线程分别求解质数，每个线程的 run 函数里，打印质数。我们写下这样的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end   = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i += <span class="number">1000000</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                subList.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建线程打印质数</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrimeThread(subList)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span> || num % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= Math.sqrt(num); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们发现，Runnable 中的 run 返回是 void，也就是说，每个线程只能输出结果，而没办法返回结果，因此最终的输出是无序的。有没有办法把这个结果返回呢？答案是肯定的，我们可以用 Callable</p><p>Callable 和 Runnable 的功能类似，但有 3 个不同点：<br>1、Callable 中的 call 是泛型方法，并且有返回值，也会抛出异常，需要对异常进行处理<br>2、Callable 不像 Runnable 可以直接用来 new Thread(new Runnable) 开一个线程，Callable 一般配合线程池使用<br>3、向线程池提交一个 Callable 任务后， 线程池并不是直接给我们返回任务的结果，而是返回一个 Future，通过这个 Future，我们才可以拿到执行结果。</p><h2 id="Future-是什么"><a href="#Future-是什么" class="headerlink" title="Future 是什么"></a>Future 是什么</h2><p>看了上面的描述，可能有同学还是不太理解 Future 是什么，从字面意来看，它是”将来”，但这太抽象了，事实确实如此，从 Future 的源码来看，它是一个接口，接口就是抽象的，它表示的是一个任务的执行情况。为了帮助理解，我们可以把它和<strong>句柄</strong>，或者文件描述符（fd）做类比，假如我们要对文件或者网络设备进行读写，通常会拿到一个句柄，文件的话，通常是文件句柄，网络的话，通常是 socket，调用句柄的 read 和 write 方法即可对文件或 socket 进行读写，类比过来，Future 就是一个表示<strong>任务的句柄</strong>，通过这个“句柄”，我们可以获得任务的执行情况，以及给任务发送一些指令。用一个简单例子来体会下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        String name = <span class="string">"jimmy"</span>;</span><br><span class="line">        <span class="comment">// 用 submit 方法，向线程池提交一个 Callable 任务，submit 返回一个 Future，也就是标识该任务的"句柄"</span></span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> UpperStringTask(name));</span><br><span class="line">        <span class="comment">// get 方法，获取任务的执行结果，如果任务执行过程中出错，会抛出 ExecutionException 异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperStringTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 call 方法，并返回 String</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子是一个很简单的示例，Callable 里执行的也是很简单的任务：将一个字符串转为大写，并返回。返回的结果，可以通过 future.get() 方法获得。可以看到，Callable 的使用方式和 Runnable 基本类似：Runnable 重写 run 方法，Callable 重写 call 方法。这里关键的地方在于，我们不是通过 new 一个 Thread 来启动任务，而是用 ExecutorService 的 submit 方法提交任务，submit 方法返回的也只是 Future，即一个任务的“句柄”，而不是任务结果本身。需要通过 Future 的 get 方法来获得任务结果。如果执行失败或者上面例子，就是将字符串 “jimmy” 转为大写的结果。由于任务的 call 方法返回的是 String 类型，因此 future 也应该是 String，即 <code>Future&lt;String&gt;</code> 。需要提醒的是，get 方法是个阻塞方法，这意味着，如果任务比较耗时，则 get 会一直等待任务执行完成才返回。</p><h3 id="Future-中的方法"><a href="#Future-中的方法" class="headerlink" title="Future 中的方法"></a>Future 中的方法</h3><p>除了 get 方法获得任务执行结果，Future 还有其他方法，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断操作是否已经完成，包括了正常完成、异常抛出、取消</span></span><br><span class="line">future.isDone()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消操作，方式是中断。参数 true 说的是，即使这个任务正在执行，也会进行中断</span></span><br><span class="line">future.cancel(<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否被取消，只有在任务正常结束之前被取消，这个方法才会返回 true</span></span><br><span class="line">future.isCancelled()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面不带参数的 get 方法是阻塞的，会一直等待任务执行完成，也可以给 get 传一个参数，设置超时时间</span></span><br><span class="line">future.get(timeout, TimeUnit)</span><br></pre></td></tr></table></figure></p><p>可以看到，确实可以把 Futuere 想象成任务的句柄，通过这个句柄，获得任务的状态，以及对任务做一些操作。这一点上，Callable 要比 Runnable 灵活许多。</p><p>弄明白了上面简单例子，我们就可以尝试解决文章开头的那个案例了，注释已经说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 表示一批任务执行情况的 future 集合，每个任务的结果是 List&lt;Integer&gt;</span></span><br><span class="line">        List&lt;Future&lt;List&lt;Integer&gt;&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;PrimeTask&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end   = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 1 到 1 亿 分为 100 个区间，每个区间 1000000 个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i += <span class="number">1000000</span>) &#123;</span><br><span class="line">        List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        subList.add(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交一个 PrimeTask 类型的任务，返回的 future 类型是 List&lt;Integer&gt;</span></span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; future = executor.submit(<span class="keyword">new</span> PrimeTask(subList));</span><br><span class="line">        <span class="comment">// 然后将 future 添加到结果集</span></span><br><span class="line">        futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代 future 集合，获取每个任务的执行结果，集合中的 future 顺序和上面提交任务的顺序是一致的，</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Integer&gt;&gt; f : futures) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shtdown();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeTask</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span> || num % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= Math.sqrt(num); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="执行-Runnable-任务"><a href="#执行-Runnable-任务" class="headerlink" title="执行 Runnable 任务"></a>执行 Runnable 任务</h3><p>那么有没有可以执行 Runnable 类型任务的类呢？其实 submit 方法也可以接收一个 Runnable 类型参数，也会返回一个 Future，只不过由于 Runnable 任务没有返回值，因此你用返回的 Future 并调用 Future.get，任务完成后只能得到一个 null。所以，这里的 Future 只能用来查看任务状态，如 Future.isDone，或者取消任务，如 Future.cancel。此外，ExecutorService 继承于 Executor 接口，Executor 有个 execute 方法，这个方法就是用于接收 Runnable 类型的任务，因此我们也可以在 ExecutorService 中使用 execute 方法提交 Runnable，即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际是将 Runnable 任务委托给了父类 Executor 中的 execute</span></span><br><span class="line"><span class="keyword">void</span> ExecutorService.execute(Runnable task);</span><br></pre></td></tr></table></figure></p><p>由于本文主要侧重点在 Future，因此执行 Runnable 的例子不打算介绍了，简单总结下：</p><ul><li>ExecutorService 可以接收 Callable 和 Runnable 类型的任务，使用 submit 方法提交任务，该方法返回任务句柄 Future</li><li>Callable 任务执行完毕后，通过 Future.get 获取任务结果，Runnable 任务执行完后无结果</li></ul><h2 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h2><p>在绝大部分场景下，ExecutorService 都可以满足我们的需要。假设现在有这样一个场景：我们向 ExecutorService 依次提交了 4 个任务 A，B，C，D，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">futures.add(executorService.submit(A));</span><br><span class="line">futures.add(executorService.submit(B));</span><br><span class="line">futures.add(executorService.submit(C));</span><br><span class="line">futures.add(executorService.submit(D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代 futures 获取结果</span></span><br><span class="line"><span class="keyword">for</span> (Future future:futures) &#123;</span><br><span class="line">    Integer result = future.get();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，A 任务特别耗时，而 B，C，D 任务很快就完成了，由于<code>future.get()</code>是阻塞的，因此上面在迭代 future 时，我们不得不等待 A 完成后，即第一个 future.get() 返回后，才能继续拿 B，C，D的结果。这里的主要问题是，当我们提交一个任务集合时，我们事先是不知道集合中哪个任务会先执行完，因此只能拿到一个 future 集合，这个集合的顺序和我们提交任务的顺序一致，然后依次迭代 future 取结果。因此，上面我们求质数，迭代 future 集合时，可能出现这种情况：<strong>后面某个区间的质数已经求解完毕，但前面的区间还没求解完</strong>。由于上面案例需要顺序输出质数，因此我们对 future 顺序迭代取结果。</p><p>再假设一个情况，如果我们提交的是下载任务：从不同的镜像源下载某个安装包。如 ubuntu.iso 文件，A 任务从国外官方官网下，B 任务从 163 镜像站下，C 任务从 ali 镜像站下，哪个任务先下载完就用哪个，并终止其他任务，这时用上述迭代方式就不合适了。</p><p>此时我们可以使用 <strong>ExecutorCompletionService</strong>。相比于 ExecutorService，ExecutorCompletionService 这个类提供了 take 方法，这个方法也会阻塞的等待任务集合执行，一旦集合中有完成的任务，take 就返回，注意，take 返回的是 future，也即已经完成的任务的“句柄”，这时调用 get 方法，即可拿到结果了。从描述来看，take 方法似乎跟 BlockingQueue 里的 take 方法类似，事实也确实如此，ExecutorCompletionService 是在 ExecutorService 的基础上，用一个 LinkedBlockingQueue 队列存 future。一旦有任务完成，就把该任务的 future 放入到 LinkedBlockingQueue 中，<strong>如果说<br>ExecutorService = incoming queue + worker threads，那么<br>ExecutorCompletionService = incoming queue + worker threads + output queue</strong></p><p>使用上，ExecutorCompletionService 也非常容易，ExecutorCompletionService 提供了一个构造方法，可以直接把 ExecutorService 包装成 ExecutorCompletionService，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletionService executorCompletionService= <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executorService);</span><br></pre></td></tr></table></figure></p><p>上面的例子用 executorCompletionService 来改写下，注释说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">CompletionService executorCompletionService= <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executorService);</span><br><span class="line">List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">futures.add(executorCompletionService.submit(A));</span><br><span class="line">futures.add(executorCompletionService.submit(B));</span><br><span class="line">futures.add(executorCompletionService.submit(C));</span><br><span class="line">futures.add(executorCompletionService.submit(D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里就不是迭代 futures 了，而是调用 executorCompletionService 的 take 方法，然后再 get</span></span><br><span class="line"><span class="comment">// 结果的顺序和提交任务的顺序可能不一致，取决于谁先执行完，就先获取谁的结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;futures.size(); i++) &#123;</span><br><span class="line">    Integer result = executorCompletionService.take().get();</span><br><span class="line">    <span class="comment">// 拿到结果，做其他处理</span></span><br><span class="line">    <span class="comment">// doSomeThing()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在再来考虑下上述那个从不同镜像源下载安装包的场景，注释已经说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Executor e, Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 初始化一个 ExecutorCompletionService</span></span><br><span class="line">    CompletionService&lt;Result&gt; ecs = <span class="keyword">new</span> ExecutorCompletionService&lt;Result&gt;(e);</span><br><span class="line">    <span class="comment">// 获得任务总数</span></span><br><span class="line">    <span class="keyword">int</span> n = solvers.size();</span><br><span class="line">    List&lt;Future&lt;Result&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Result&gt;&gt;(n);</span><br><span class="line">    Result result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;Result&gt; s : solvers) &#123;</span><br><span class="line">            futures.add(ecs.submit(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依照任务完成顺序获取结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Result r = ecs.take().get();</span><br><span class="line">                <span class="comment">// 一旦某个任务执行完，终止循环</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = r;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(ExecutionException ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后取消所有任务，对已经完成的任务，执行 cancel 无影响</span></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Result&gt; f : futures)</span><br><span class="line">            f.cancel(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        use(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，上面的两个案例，我们不是迭代 Future 来拿结果，而是用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;task.size; i++)</span><br></pre></td></tr></table></figure></p><p>来迭代的，由于我们对结果的顺序不关心，而且 take 方法是 ExecutorCompletionService 类的，因此不能迭代 Future，而只能迭代个数，Future 个数或者任务个数，所以这里就得小心的处理 take 方法了。如果个数弄错，可能导致队列已经没有任务，但 仍然调用 take，导致一直阻塞。我们可以继承 ExecutorCompletionService，增加一个原子变量属性，每次提交一个任务，变量加 1，最终用这个变量表示任务的个数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Runnable 执行一个不返回结果的任务，Callable 执行一个有返回结果的任务</li><li>可以使用 Executors 的静态方法创建线程池，由线程池来执行任务</li><li>submit 方法用于提交任务，并返回 Future，可以把它当成任务的句柄</li><li>Future 的 get 是阻塞方法，向 ExecutorService 提交多个任务，最终迭代 Future 时，结果的顺序和任务提交的顺序一致</li><li>ExecutorCompletionService 的 take 方法可以获取已完成的任务的 Future，是通过将任务结果放入 BlockingQueue 实现</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://dzone.com/articles/executorservice-vs" target="_blank" rel="noopener">https://dzone.com/articles/executorservice-vs</a></li><li><a href="https://www.javaspecialists.eu/archive/Issue214.html" target="_blank" rel="noopener">https://www.javaspecialists.eu/archive/Issue214.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异步任务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git pull 和 git rebase</title>
      <link href="//2019/04/23/git-pull-and-git-rebase.html"/>
      <url>//2019/04/23/git-pull-and-git-rebase.html</url>
      
        <content type="html"><![CDATA[<p>git 是团队开发中常用的代码版本管理工具，我们经常会遇到这样一个场景：在 feature 分支上开发完一个新功能后，通常会做这样的操作：<code>git pull</code>，然后<code>git push</code>。但也有人喜欢在<code>git pull</code>后面再上<code>--rebase</code>参数，即<code>git pull --rebase</code>，这是什么意思呢？<br><a id="more"></a></p><p>我们知道，<strong>git pull = git fetch + git merge</strong>，即首先将本地的分支信息更新以和远程保持同步，然后将再将远程分支合并到本分支。而 <strong>git pull –rebase = git fetch + git rebase</strong>。可以看到，<code>git pull</code>和<code>git pull --rebase</code>的区别，就是<code>git merge</code>和<code>git rebase</code> 的区别，跟<code>git merge</code>相比，<code>rebase</code>主要有下面几点不同：</p><ul><li>让多个人在一个分支开发的提交点形成一条线，而不是多条线，从而保持分支的整洁</li><li><code>rebase</code>参数，让你的 commit 在该分支最前面，</li><li>分支上不会有合并的提交记录</li></ul><p>可能有同学对上面的解释还是不明白，那我们看看下面的提交树来直观感受下（提交图形化工具为 <a href="https://github.com/jonas/tig" target="_blank" rel="noopener">tig</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-04-22 20:12 +0800 jimmy M─┐ [master] Merge branch &apos;feature_dev&apos;</span><br><span class="line">2019-04-22 20:07 +0800 jimmy │ o [feature_dev] commit on feature_dev 2</span><br><span class="line">2019-04-22 20:07 +0800 jimmy │ o commit on feature_dev 1</span><br><span class="line">2019-04-22 20:08 +0800 jimmy o │ commit on master 4</span><br><span class="line">2019-04-22 20:08 +0800 jimmy o │ commit on master 3</span><br><span class="line">2019-04-22 20:06 +0800 jimmy o─┘ commit on master 2</span><br><span class="line">2019-04-22 20:06 +0800 jimmy I   commit on master 1</span><br></pre></td></tr></table></figure></p><p>上面展示的是一个 git 项目的提交记录数，该项目有两个分支：master 和 feature_dev，从下往上看，master 分支上有 4 次提交记录，分别是 commit on master 1-4，feature_dev 分支上有两次提交，分别是 commit on feature_dev 1-2，最上面的那次提交，是在 master 上执行<code>git merge feature_dev</code>产生的一次提交，从<code>M</code>标识也可以看出这是一次合并操作，可以看到，现在总共有 7 次提交记录，同时我们也注意到，虽然 master 上的第 3 次提交和第 4 次提交时间比 feature_dev 上的两次提交要晚，但合并后，feature_dev 上的提交却在上面。</p><p>如果我们使用<code>git rebase feature_dev</code>呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-04-22 20:08 +0800 jimmy o [master] commit on master 4</span><br><span class="line">2019-04-22 20:08 +0800 jimmy o commit on master 3</span><br><span class="line">2019-04-22 20:07 +0800 jimmy o [feature_dev] commit on feature_dev 2</span><br><span class="line">2019-04-22 20:07 +0800 jimmy o commit on feature_dev 1</span><br><span class="line">2019-04-22 20:06 +0800 jimmy o commit on master 2</span><br><span class="line">2019-04-22 20:06 +0800 jimmy I commit on master 1</span><br></pre></td></tr></table></figure></p><p>上面就是在 master 上执行了<code>git rebase feature_dev</code>后的提交记录，可以看到，此时的提交记录都在一条线上了，就像是直接把 feature_dev 上的那两次提交插入到 master 上一样，更有意思的是，现在只有 6 次提交记录了，没有因为合并而产生的提交记录，事实上，合并的提交记录通常是无意义的。再回过头来，看看上面说的 3 点区别，是不是更加明朗呢？</p><p>需要注意的是，上面的演示，并没有展示代码冲突的场景，这在实际开发过程中是很常见的，不过，即使遇到了也不要慌，git 一个很好的优点是，如果你哪一步操作有问题，都会给出友好的提示，如上面你执行<code>git pull --rebase</code>后遇到冲突，会给出类似如下提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict in &lt;some-file&gt;</span><br></pre></td></tr></table></figure></p><p>跟之前套路一样，把冲突的文件解决下，然后执行<code>git add &lt;some-file&gt;</code>和 <code>git rebase --continue</code>即可，跟使用<code>git pull</code>基本一致。</p><p>总结下，<code>git pull</code>和<code>git pull --rebase</code>二者的最终目的一致，主要区别在于提交记录上，或者说执行<code>git log --oneline --decorate --graph --all</code>后，二者看到的提交树不一样，加上<code>--rebase</code>参数后，项目分支整洁了，即使有多个人在该分支上开发，最终看到的提交记录也只有一条线， 而且每个提交都是有意义的。反过来，也简化了哪里引入 Bug 的分析，如果有必要，回滚修改也可以做到对项目影响最小。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md" target="_blank" rel="noopener">https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md</a></li><li><a href="https://www.cnblogs.com/xueweihan/p/5743327.html" target="_blank" rel="noopener">https://www.cnblogs.com/xueweihan/p/5743327.html</a></li><li><a href="https://my.oschina.net/gef/blog/2978848" target="_blank" rel="noopener">https://my.oschina.net/gef/blog/2978848</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker 和 KVM 虚拟机</title>
      <link href="//2019/04/04/docker-and-vm.html"/>
      <url>//2019/04/04/docker-and-vm.html</url>
      
        <content type="html"><![CDATA[<p>近几年，随着微服务概念和容器化思想的风(chao)靡(zuo)，Docker 技术成了各大厂和各种吹牛大会上的香饽饽，一提到 Docker，就是各种优势，大有在云计算领域一统江湖的趋势。但是 Docker 真的是万精油吗？本文简单介绍下 Docker 的一些底层技术，以及和传统虚拟机的一些差异。</p><h2 id="开局一张图"><a href="#开局一张图" class="headerlink" title="开局一张图"></a>开局一张图</h2><p>我们先来看一张图<br><img src="/images/vm/vm-vs-docker.png" alt="图1"></p><p>这里先不解释上图的含义，等介绍完下面内容，再回过头看。</p><h2 id="为什么需要-Docker-这类技术"><a href="#为什么需要-Docker-这类技术" class="headerlink" title="为什么需要 Docker 这类技术"></a>为什么需要 Docker 这类技术</h2><p>对于应用程序开发和测试工作者来说，经常会遇到这样的场景：在开发环境下运行得好好的应用，部署到测试环境时就出问题，一会儿缺个目录，一会儿少个包，比如运行 Java，得装对应版本的 JDK，设置环境变量等。而有了 Docker，一切就简单了，首先开发机和测试机都安装好 Docker，开发把要测试的 App 和需要的库、依赖等，打成一个 Docker image，交付给测试，测试拿到这个 image，只需一个命令<code>docker run</code>，一个容器就运行起来，应用也就在测试环境跑起来了，如果测得没有问题，就可以拿这个 image 部署到生产环境了。整个过程中，不管有多少测试环境，只要大家拿的是相同的 image，就不会出现因为环境不同而导致应用无法运行。而升级也非常简单，停掉老容器，运行新容器。这就是 Docker 最大的优点，<strong>你只需要关注应用本身，而不需要关注应用之外的依赖和环境。</strong> 将应用程序打包成一个镜像，然后以容器的方式运行，Docker 的这个思想，大大提高了应用的开发效率，降低了运维成本。</p><h2 id="运行-Docker-需要的内核技术"><a href="#运行-Docker-需要的内核技术" class="headerlink" title="运行 Docker 需要的内核技术"></a>运行 Docker 需要的内核技术</h2><p>上面我们说，使用 Docker 后，就不需要关心执行环境的问题了，也就是表明，容器中的 Java 程序，用的是打包在容器中的 JDK1.8，而不会是宿主机上装的 JDK1.5，容器的执行环境和宿主机是隔离开的。那么，Docker 是怎么实现宿主机和容器的环境隔离呢？又有哪些东西是需要隔离的呢？</p><p><strong>Docker 通过命名空间(namespace) 机制来实现隔离，而 Linux 内核提供了 6 种 namespace 隔离的系统调用</strong>，我们知道，通过<code>fork()</code>系统调用可以创建新进程，而<code>clone()</code>则是创建新进程的一种更通用的方式，其原形如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure></p><p>注意到其中有个 flags 的参数，调用<code>clone()</code>在创建新进程时，flags 支持传入类似型如 CLONE_* 的参数，使创建的进程有不同的独立的 namespace，达到隔离的目的。有 6 种 namespace 的名称、使用的参数、以及隔离效果如下：</p><table><thead><tr><th>命名空间</th><th>系统调用参数</th><th>隔离内容</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>隔离主机名和域名，传入这个参数，新进程有自己的主机名了</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>隔离信号量，消息队列和共享内容，新进程无法通过信号量的方式感知命名空间外的进程</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>隔离进程编号，新进程的 pid 和 宿主机 pid 是独立开了</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>隔离网络设备，网络栈，端口等，进程有了自己的网络资源、端口</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>挂载点，进程可以有自己的文件系统</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>隔离用户和用户组</td></tr></tbody></table><p>上表中的多个参数支持<code>与</code>操作，这样我们创建出的新进程就可以隔离多项内容。<br>上述这 6 种命名空间，将 Linux 命名空间中的进程和命名空间外的进程区分开来，位于同一个命名空间中的进程可以感知各自存在，而且会认为这个命名空间就是整个世界环境，对命名空间外的一切是一无所知的，这样就达到了隔离目的。Docker 本质上就是一个使用 Linux 命名空间技术，来达到“虚拟化”的效果。</p><p>既然 Docker 大法这么好，那为何还要有 KVM 这一类虚拟机呢？</p><h2 id="KVM-虚拟机"><a href="#KVM-虚拟机" class="headerlink" title="KVM 虚拟机"></a>KVM 虚拟机</h2><p>大多数朋友可能都有过在自己 Windows 电脑上装 VMWare 或者 VirtualBox 跑虚拟机的经历，运行虚拟机前，需要准备一个 ISO 镜像，然后让你选择给虚拟机分配多大内存，多大磁盘等，一切准备好后，启动虚拟机，就可以看到熟悉的装机界面了，接下来就和在物理机上装系统一样。</p><p>在 Linux 环境下，我们也有相应的虚拟化解决方案——QEMU/KVM，同样，我们创建虚拟机前，也要准备好镜像，以及定义好虚拟机的各种规格等。注意，这里说的镜像和上文 Docker 中的镜像是两个完全不同的概念，这里的镜像就是我们平时装操作系统用的镜像，里面只包括了引导程序和操作系统，而且装好后，这个镜像就不用了；而上文说的 Docker 镜像，是一个运行 App 和依赖库的最小包，或者把它理解成一个 zip 包。每次运行容器，都需要这个镜像。从创建 KVM 虚拟机的过程来看，显然它对虚拟机的各种资源有更详细的描述，基本等同于创建了一个“物理机”了，毕竟物理机有的它都有。</p><p>这里不打算讨论 Win 平台下的虚拟化，我们着重看下 Linux 下的虚拟化。最常见的虚拟化组合就是 QEMU/KVM 了。QEMU 是一款开源的模拟器和虚拟机监视器（Virtual Machine Monitor, VMM）。QEMU 主要提供两个功能给用户使用：</p><ul><li>作为用户态模拟器：通过动态代码翻译机制来执行不同架构的代码，例如在 X86 平台上模拟 ARM 平台下执行环境。</li><li>作为虚拟机监视器：模拟全系统，利用其它 VMM（如 Xen，KVM等等）来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。</li></ul><p><strong>从上面描述我们可以看到，QEMU 其实是一个纯软件实现的虚拟机模拟器，但虚拟化效率很低，因此配合 KVM 等一类 VMM，利用 KVM 提供的硬件加速，使得在 QEMU 中运行的 CPU 指令，直接在宿主机的物理 CPU 上执行，使虚拟机的性能更高。</strong>KVM 已经是 Linux 平台下的一个内核模块了，它本身不实现任何模拟，运行于内核空间，仅仅是暴露了一个 /dev/kvm 接口，由运行于用户空间的 QEMU 与之交互。当虚拟机有 CPU 操作时，QEMU 将指令转交给 KVM 模块，而 IO 仍然由 QEMU 来完成。因此，由 QEMU/KVM 组合创建的虚拟机，被称为 KVM 虚拟机。</p><p>KVM 的基本架构可以用下图来表示<br><img src="/images/vm/kvm.png" alt="图2"></p><p>运行一个 KVM 虚拟机不像运行一个 Docker 那么简单，除了要安装好一系列包，还得检查你机器的 CPU 是否在硬件上支持虚拟化扩展特性参数，具体的可以参考 <a href="https://opengers.github.io/virtualization/kvm-libvirt-qemu-1/" target="_blank" rel="noopener">这篇文章</a>。</p><p>一个 KVM 虚拟机运行起来后，从宿主机的角度来看，它就是一个标准的 Linux 进程，具体来讲，是 QEMU 进程。可以通过命令行虚拟机管理工具 virsh 来对虚拟机进行开机关机等操作。</p><h2 id="二者的比较"><a href="#二者的比较" class="headerlink" title="二者的比较"></a>二者的比较</h2><p>从图1和上面的讨论，我们看到，Docker 只是一种 Linux 容器(LXC，Linux Container)，容器是什么？和虚拟机一样，本质上都是 Linux 系统中的一个进程。Docker 和虚拟机的生命周期，都是在宿主机上完成，但二者也有显著的差别。</p><p>首先是二者的实现方式，上面我们说 Docker 是 Linux 容器，这决定了，Docker 只能运行于 Linux 系统，看到这里，可能有人会说，我的 Windows 上，Mac 上现在也跑着 Docker 呢，但是请注意，这都是通过软件技术做的一些障眼法，如 Boot2Docker，它使 Docker 客户端运行在用户的操作系统，但仍然起了一个 Linux 虚拟机，上面跑着 Docker deamon 服务，还是脱离不了 Linux，这种方式比直接在 Linux 上运行 Docker, 无疑更加复杂，也丧失了 Docker 的方便性和灵活性。此外，LXC 决定了我们起一个容器，容器中只能是 Linux 平台的应用，不可能运行 Windows 平台下的程序，而 KVM 虚拟机是一种硬件全虚拟化的解决方案，不受此限制，在 Linux 机器上，我们仍然可以虚拟化出一个 Windows 系统，并运行对应平台的程序。</p><p>其次，从图1我们看到，一个宿主机上的所有的容器，都是共享宿主机的操作系统内核，这决定了，Docker 的隔离性要比 KVM 类的虚拟机弱。如果宿主机内核出了问题，这将影响其上的所有 Docker 容器。</p><p>在大规模部署和资源调度方面，Docker 和虚拟机都有成熟的方案，Docker 领域有比较流行的 K8S，Mesos 等框架，开源社区活跃；虚拟机领域著名的有 openstack，以及一些企业自研的调度平台，从热门话题来看，显然 Docker 要更胜一筹。</p><h2 id="二者的定位"><a href="#二者的定位" class="headerlink" title="二者的定位"></a>二者的定位</h2><p>站在云计算的视角来看，KVM 虚拟机，属于 IaaS 层面产品，它给用户提供的是一套完整的基础设施，用户可以拿虚拟机做任何用途，跑运算，做 Web 服务等；而 Docker，更像是 PaaS 层的产品，它提供了一个特定的软件运行的环境，用户拿到一个 Redis 的 Docker image，那么只能跑数据库服务，而不可能跑 Web 服务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每个新技术的出现，都是为了解决特定的问题，Docker 和 KVM 虚拟机，在大的方面上，都是为了提高效率，最大化的利用物理资源。Docker 在构建、部署方面，有着虚拟机无法比拟的优势，虚拟机在云计算领域，有更广的发挥空间。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/" target="_blank" rel="noopener">https://cameronlonsdale.com/2018/11/26/whats-in-a-docker-image/</a></li><li><a href="https://woshijpf.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96/2018/11/21/QEMU-KVM-%E5%8E%9F%E7%90%86%E7%BB%BC%E8%BF%B0.html" target="_blank" rel="noopener">https://woshijpf.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96/2018/11/21/QEMU-KVM-%E5%8E%9F%E7%90%86%E7%BB%BC%E8%BF%B0.html</a></li><li><a href="https://www.jianshu.com/p/03d3afff3b5f" target="_blank" rel="noopener">https://www.jianshu.com/p/03d3afff3b5f</a></li><li><a href="https://blog.opskumu.com/kvm-notes.html" target="_blank" rel="noopener">https://blog.opskumu.com/kvm-notes.html</a></li><li><a href="https://opengers.github.io/virtualization/kvm-libvirt-qemu-1/" target="_blank" rel="noopener">https://opengers.github.io/virtualization/kvm-libvirt-qemu-1/</a></li><li>《容器与容器云》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 中常用的监控和故障处理命令行工具</title>
      <link href="//2019/02/24/java-analyzer-tools.html"/>
      <url>//2019/02/24/java-analyzer-tools.html</url>
      
        <content type="html"><![CDATA[<p>我们常常需要获取 Java 程序运行过程中的一些执行情况，如执行路径，GC 情况，堆栈信息等。JDK 给我们提供了一些简单但却很有用的命令行工具，本文介绍下这些工具的使用和参数说明，用于备忘。<br><a id="more"></a></p><h3 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps: 虚拟机进程状况工具"></a>jps: 虚拟机进程状况工具</h3><p>这个命令和 Linux 下 ps 命令类似，可以理解为 Java 中的进程查看命令，这条命令最主要的功能就是看虚拟机的 ID 号，而这个 ID 号和操作系统中的 PID 是一致的，很多工具，都需要提供 PID 才能做进一步分析，因此，这个命令一般是查问题时第一个会用到的命令。jps 命令有以下这些参数可用：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出虚拟机 ID 号，不看其他东西</td></tr><tr><td>-m</td><td>输出虚拟机启动时传给主类 main() 函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果是 jar 包，输出 jar 路径</td></tr><tr><td>-v</td><td>输出虚拟机启动时的 JVM 参数</td></tr></tbody></table><p>某次 jps 执行样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~ # jps -mlv</span><br><span class="line">3155 sun.tools.jps.Jps -mlv -Denv.class.path=/root/apache-jmeter-5.0/lib/ext/ApacheJMeter_core.jar:/root/apache-jmeter-5.0/lib/jorphan.jar:/root/apache-jmeter-5.0/lib/logkit-2.0.jar: -Dapplication.home=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64 -Xms8m</span><br><span class="line">25054 org.apache.catalina.startup.Bootstrap start -Djava.util.logging.config.file=/usr/local/zstack/apache-tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.net.preferIPv4Stack=true -Dcom.sun.management.jmxremote=true -Djava.security.egd=file:/dev/./urandom -Xms512M -Xmx4096M -agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n -Djava.endorsed.dirs=/usr/local/zstack/apache-tomcat/endorsed -Dcatalina.base=/usr/local/zstack/apache-tomcat -Dcatalina.home=/usr/local/zstack/apache-tomcat -Djava.io.tmpdir=/usr/local/zstack/apache-tomcat/temp</span><br></pre></td></tr></table></figure></p><h3 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat: 虚拟机统计信息监视工具"></a>jstat: 虚拟机统计信息监视工具</h3><p>这个命令用于监视虚拟机各种运行状态信息，在无 GUI，只有纯命令行的服务器上，它是运行期定位虚拟机性能问题的首选工具，jstat 命令格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat option vmid interval count</span><br></pre></td></tr></table></figure></p><p>其中 interval 和 count 表示查询间隔和次数，如果省略，则只查询一次，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 9527 250 20</span><br></pre></td></tr></table></figure></p><p>表示每250ms 查询一次进程为 9527 的垃圾收集情况，共查询 20 次。选项 option 可以有下面这些</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类装载，卸载数量，总空间以及类装载所耗费时间</td></tr><tr><td>-gc</td><td>监视 Java 堆情况，包括 Eden 区，两个 survivor 区，老年区，永久代的容量，已用空间，GC 时间合计等信息</td></tr><tr><td>-gcnew</td><td>监视新生代 GC 状况</td></tr><tr><td>-gcold</td><td>监视老年代 GC 状况</td></tr><tr><td>-gcpermcapacity</td><td>监视永久代使用的最大、最小空间</td></tr></tbody></table><p>如某次 jstat 执行样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~ # jstat -gcutil 25054 1000 10</span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">4.03   0.00  86.89  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br><span class="line">4.03   0.00  86.89  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br><span class="line">4.03   0.00  86.89  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br><span class="line">4.03   0.00  86.89  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br><span class="line">4.03   0.00  87.08  52.67  98.03  96.14     42   82.191     3    6.057   88.247</span><br></pre></td></tr></table></figure></p><p>上面结果表明：新生代 Eden 区（E，表示 Eden）使用了 86.89% 的空间，Survivor0 区（S0）使用了 4.03%，Survivor1 区（S1）是空的，老年代（O）使用了 52.67%。元空间（M，表示 Metaspace，可以理解为 Java 8 以前的 P，永久代）使用了 98.03%。压缩使用比例（CCS）为 96.14%。从启动到采集时，共发生 Minor GC（YGC，表示 Young GC）42 次，总耗时（YGCT） 82.191 秒，发生 Full GC（FGC）3 次，总耗时（FGCT） 6.057 秒，所有 GC 总耗时（GCT）88.247 秒。</p><h3 id="jmap-内存映像工具"><a href="#jmap-内存映像工具" class="headerlink" title="jmap: 内存映像工具"></a>jmap: 内存映像工具</h3><p>这个命令用于生成堆转储快照，也称为 heapdump 或 dump 文件，当然还可以通过 -XX:+HeapDumpOnOutOfMemoryError 参数，让虚拟机在 OOM 异常时自动生成 dump 文件。jmap 命令使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap option vmid</span><br></pre></td></tr></table></figure></p><p>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapfile.bin 9527</span><br></pre></td></tr></table></figure></p><p>表示以二进制格式，生成名为 heapfile 的 dump 文件，9527 为 JVM 的 ID，也即 PID。有了这个 dump 文件，就可以使用下面的 jhat 工具来分析了。</p><h3 id="jhat：堆转储快照分析工具"><a href="#jhat：堆转储快照分析工具" class="headerlink" title="jhat：堆转储快照分析工具"></a>jhat：堆转储快照分析工具</h3><p>这个命令和上面的 jmap 配合使用，使用方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat heapfile.bin</span><br></pre></td></tr></table></figure></p><p>jhat 会起一个 server，通过浏览器就可以访问分析结果。不过，一般也很少用 jhat 来分析 dump 文件，首先是 jhat 提供的功能还相对简陋，现在有更多先进的工具，如<a href="https://visualvm.github.io/" target="_blank" rel="noopener">VisualVM</a> 来分析；其次分析 dump 文件是一个耗时又耗硬件资源的工作，一般会把 dump 文件从生产服务器拷贝到其他机器来分析。</p><h3 id="jstack：堆栈跟踪工具"><a href="#jstack：堆栈跟踪工具" class="headerlink" title="jstack：堆栈跟踪工具"></a>jstack：堆栈跟踪工具</h3><p>这个命令用来生成虚拟机当前时刻的线程快照，也称为 threaddump 或 javacore 文件，除了 jstack 命令，还有很多其他方式也可以获取线程快照，如<a href="https://community.oracle.com/blogs/ramlakshmanan/" target="_blank" rel="noopener">这里</a>介绍的方法。线程快照就是当前虚拟机内每条线程正在执行的方法堆栈集合，有了线程快照，就可以定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源长时间等待等，都是造成线程长时间停顿的常见原因。线程出现停顿时，通过 jstack 来查看各个线程调用堆栈，就可以知道没有响应的线程到底在后台做什么，或者等待什么。<br>使用方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack option vmid</span><br></pre></td></tr></table></figure></p><p>其中 option 可以有如下选项</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当 jstack vmid 无响应是，-F 强制生成thread dump</td></tr><tr><td>-l</td><td>除堆栈信息，还打印出锁的附加信息</td></tr><tr><td>-m</td><td>打印除 java 堆栈外，还打印本地方法的帧</td></tr></tbody></table><p>jstack 命令会将堆栈信息直接返回，不会生成文件，因此一般也会把 jstack 打印的堆栈信息重定向到文件，然后直接用其他工具分析，如上文提到的 VisualVM，或一些<a href="https://fastthread.io/" target="_blank" rel="noopener">在线分析网站</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是一些常见分析 JVM 和故障处理的工具，这些工具看似简单，但真正用好却非易事，事实上，一个线上 OOM 问题，除了熟练使用好这些工具外，还需要大量的实战经验，这些不是一朝一夕能获得的，需要日常工作中总结和锻炼。</p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li>《深入理解 Java 虚拟机》</li><li><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">https://www.cnblogs.com/paddix/p/5309550.html</a></li><li><a href="http://www.importnew.com/29891.html" target="_blank" rel="noopener">http://www.importnew.com/29891.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 中的同步方法</title>
      <link href="//2018/10/22/java-concurrent.html"/>
      <url>//2018/10/22/java-concurrent.html</url>
      
        <content type="html"><![CDATA[<p>说到 java 中的同步，必然少不了耳熟能详的<code>synchronized</code>，<code>ReentrantLock</code>，以及可能用过但不怎么常见的<code>Atomic</code>，<code>volatile</code>，本篇即简单介绍下他们的区别和使用场景。</p><a id="more"></a><h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><p>首先要明确一个事实：同步是为了解决多线程的并发问题，但并不是说只要有多线程，就一定会有并发问题。多线程环境下，如果你只是调用了一些方法，但没有访问共享的变量或内存，就不存在并发问题，注意：一定是<strong>共享的变量或内存</strong>。在 java 里，这样的变量一般是在堆和方法区中存在，他们可以被多个线程同时访问到。<strong>换句话说，堆和方法区中的变量，需要考虑并发问题，比如并发访问某个对象的实例属性，静态属性，还有数组的元素等，就是典型的需要考虑并发问题场景。而方法的参数，方法体中定义的局部变量是放在栈上的，属于线程私有，可以不用考虑并发问题。</strong>举个例子，看下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variables</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> c)</span>:</span></span><br><span class="line"><span class="function">       <span class="keyword">int</span> d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面定义的类，其中，a 变量是类的静态变量，属于类变量，存放在方法区，b 是成员变量，存放在堆中，而 c 和 d 是局部变量，存放在栈中，因此多线程环境下，对 a 和 b 的操作需要考虑并发问题，而 c 和 d 的操作，则不需要考虑。</p><p>那么并发问题需要解决什么呢？通常，解决的问题有三个：<strong>原子性</strong>，<strong>可见性</strong>，<strong>有序性</strong></p><ol><li><p>原子性：<br> 即一个操作或者多个操作，是一个不可分割的部分，要么全部执行成功并且执行的过程不会被任何因素打断，要么就都不执行。这个很好理解，一般教科书上，都会引用银行转账的例子，来说明原子性。即扣钱操作和加钱操作应该是不可分割的，不能出现钱扣了，但对方没收到钱，或者收到钱了，但钱没扣。在数据库事务中，也会看到原子性的影子。</p></li><li><p>可见性：<br>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。一般计算机 CPU 都会有高速缓存，当某个线程对一个变量进行修改，修改后的值不会马上写入到主存，而是会放入到执行该线程的 CPU 高速缓存中。这样可能导致其他 CPU 上的线程看不到这个变量的修改，因为它读的仍然是自己 CPU 上的高速缓存里的值。</p></li><li><p>有序性：<br> 即程序执行的顺序按照代码的先后顺序执行。我们在写一段代码，当 JVM 执行该代码时，并不一定会按照我们代码写的先后顺序去执行，可能会发生指令重排序。什么是指令重排序？一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p></li></ol><p><strong>要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong>那么怎么保证这三点呢？</p><h2 id="同步的方法"><a href="#同步的方法" class="headerlink" title="同步的方法"></a>同步的方法</h2><p>我们看看下面几段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count.getAndIncrement();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上的三个 increment 方法，均是对 count 字段做加 1 操作，哪些可以在并发场景下正确运行？看完这篇文章，相信大家能回答这个问题。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code>属于 java 中的关键字，是最常用的锁，也是一种独占锁，或者称为互斥，这意味着，<strong>当你使用<code>synchronized</code>关键字对代码进行同步后，如果有多个线程想执行这段代码，这些线程会变成串行</strong>，即如果当前有线程在执行这段代码，其他的线程只能等待。<code>synchronized</code>可以保证并发编程中要求的原子性，可见性和有序性。</p><p>对于同步代码块，<code>synchronized</code>是通过获取对象的监视锁，即<code>monitor</code>来实现同步，java 中，每个对象都有一个<code>monitor</code>，或者称为监视器，被<code>synchronized</code>包裹的代码编译成字节码后，会在代码块前后，引入<code>monitorenter</code>和<code>monitorexit</code>的字节码来实现的，JVM 规定，当<code>monitor</code>被占用时，代码块即会处于锁定状态，其他线程无法访问。像<code>wait/notify</code>等方法也依赖于<code>monitor</code>。对于同步方法，JVM 是采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步的，即一个线程想调用某方法，会检查是否有<code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后才能执行方法。</p><p>在类的任意位置都可以使用<code>synchronized</code>对想要同步的代码进行同步，如类的实例方法，静态方法，实例对象，Class 对象，代码块等。在上例中，我们对 Sample 类的静态方法 increment() 做了同步，锁住的是当前的 Sample 类对应的 class 对象，再来看看<code>synchronized</code>在代码中不同位置的使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCounter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  Object syncObj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步静态方法，锁住的是 SyncCounter.class对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticIncrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (syncObj) &#123;</span><br><span class="line"><span class="comment">// doSomething();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，分别在不同的地方使用了<code>synchronized</code>。为了执行 doSomething，必须获得对象 syncObj 的锁，syncObj 可以是类实例或者是类，典型的如 this，当两个并发线程访问同一个对象 object 中的这个 synchronized(this)同步代码块时，同一时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。但仍然可以访问该 object 中的非synchronized(this)同步代码块。 </p><p>同时，<code>synchronized</code>也是一个可重入锁，即如果一个线程持有了对象锁，那么当它再次想访问锁住的临界资源时，将可以成功。</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>提到<code>volatile</code>，一般都会提到可见性，所以在处理同步问题上它大显作用，那么<code>volatile</code>是如何保证可见性的呢？ 当对<code>volatile</code>变量做写入操作时，在 JVM 字节码中，你会看到一条 lock 前缀的指令，这是告诉 CPU，请立即将这个变量写入到主内存，以保证其他 CPU 重新从内存中读取这个新值，然后放入自己的缓存，这样就保证了可见性。 </p><p><code>volatile</code>的开销比 <code>synchronized</code>小、使用成本更低。但<code>volatile</code>只能用来修饰变量，而不能修饰方法或者代码块，可以把<code>volatile</code>看做是一个轻量级的<code>synchronized</code>，但仅此而已，<code>synchronized</code>不仅保证可见性，还能保证原子性，而<code>volatile</code>是不能保证原子性的。它不适合在对该变量的写操作依赖于变量本身自己。举个最简单的栗子：在进行计数操作时，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count++</span><br></pre></td></tr></table></figure></p><p>实际是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count= count + 1;</span><br></pre></td></tr></table></figure></p><p>count 最终的值依赖于它本身的值。所以使用<code>volatile</code>修饰的变量在进行这么一系列的操作的时候，仍然会有并发的问题。而像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag = true;</span><br></pre></td></tr></table></figure></p><p>这样的语句，由于 flag 的值不会依赖自身，因此这种情况下，<code>volatile</code>可以代替<code>synchronized</code>。通常来说，如果一个变量被声明为<code>volatile</code>，仅仅是表明：</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了这个变量的值，这新值对其他线程来说是立即可见的</li><li>禁止进行指令重排序</li></ol><p>而要使用<code>volatile</code>，必须具备以下2个条件：</p><ol><li>对变量的写操作不依赖于当前值，如像上面那样，给一个标志变量 flag 赋值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li></ol><p>其他情况下，仍然是需要用<code>synchronized</code>的。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>上面说的<code>synchronized</code>，是一个严格的排它锁，一方面，没有抢到锁的线程，会一直等待锁的释放；另一方面，当锁释放时，所有的线程都会参与争抢。如果我们需要一种遵守“先来后到”规则的公平锁，或者想给那些等待锁的线程一个超时时间，<code>synchronized</code>就无法满足需求了，这时可以使用<code>ReentrantLock</code>，在基本用法上，<code>ReentrantLock</code>和<code>synchronized</code>很相似，前者是一个实现了<code>Lock</code>接口的可重入锁，因此需要调用 lock() 和 unlock() 来完成锁的申请和释放，重要的是，<code>ReentrantLock</code>具备几个<code>synchronized</code>没有的高级功能：<strong>等待可中断</strong>，<strong>公平锁</strong>，<strong>绑定多个条件</strong>。而在性能上，二者却基本没有什么差别，<code>ReentrantLock</code>甚至比<code>synchronized</code>更优一点。</p><p>那么是不是说可以抛弃<code>synchronized</code>，而只用<code>ReentrantLock</code>呢？不然，首先，在使用方式上，<code>synchronized</code>更简洁紧凑，用户几乎不用关心锁的释放，即使是被同步的代码中抛出了异常，也可以自动释放锁。而<code>ReentrantLock</code>在同步结束后，需要显示的调用 unlock()，通常会在 finally 块中调用。其次，<code>synchronized</code>为许多开发者所熟悉，并且许多程序框架已经使用了它，如果将两种机制混合，既容易使人迷惑，也容易发生错误。因此，除非你有特别的理由，而<code>synchronized</code>无法满足，比如上述说的那三点。否则，还是应该优先考虑使用<code>synchronized</code>。</p><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><p>上面提的<code>synchronized</code>和<code>ReentrantLock</code>，可以认为是阻塞型同步方式，或者说悲观锁。在锁的申请，线程调度和恢复过程中，存在着很大开销。<code>volatile</code>虽然是一种更轻量级的同步机制，但如上面所说，它无法保证原子性。有没有一种类似于<code>volatile</code>，又能保证原子性的机制呢？<strong>Atomic</strong>类型登场了。从字面意思来讲，就知道这是一种原子类型，可以实现同步。在说<code>Atomic</code>之前，有必要复习下<strong>CAS</strong>的概念，CAS(compare and swap)，即<strong>比较并交换</strong>，这是计算机领域中很典型而又很重要的无锁思想，乐观锁通常用的就是 CAS 思想，如 MySQL 中的 MVCC，redis 中的 Watch ，都是用的 CAS 方式实现乐观锁。CAS 操作是通过将内存中的值与指定数据进行比较，当数值一样时，将内存中的数据替换为新值，它是大多数 CPU 架构直接支持的原子指令。因此，我们说 CAS 操作是原子性的，是因为 CPU 指令来保证它是原子的，它是由硬件来提供。</p><p><code>Atomic</code>类型就是 JVM 中支持 CAS 的一种实现。如<code>AtomicInteger</code>,<code>AtomicLong</code>等。具体在 <code>java.util.concurrent.atomic</code>这个包下</p><p>在上述代码中，我们看下 <code>getAndIncrement()</code>方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看看 getAndAddInt 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中，compareAndSawpInt 方法原型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一和第二个参数代表对象的实例以及地址，第三个参数代表期望值，第四个参数代表更新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure></p><p>注意到上面有个 unsafe，这是 sun.misc.Unsafe 类的实例，在 JDK 的并发包中，很多地方都用到了它，它提供了一些底层操作的能力，它设计出来是给 JDK 中的源码使用的，比如 AQS、ConcurrentHashMap 等，这个 Unsafe 类不是给我们的代码使用的，是给 JDK 源码使用的，最后它调用的是一个 native 方法，底层跟硬件相关，生成的指令可以保证原子性。</p><blockquote><p>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好(减少乐观锁的重试次数)。</p></blockquote><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>最后我们来说说<code>ThreadLocal</code>，其实这个类的出现并不是用来解决在多线程并发环境下资源的共享问题的，它和上面几个同步方式不一样，上面的关键字都是从线程外来保证变量的一致性，这样使得多个线程访问的变量具有一致性，可以更好的体现出资源的共享。</p><p>而<code>ThreadLocal</code>的设计，并不是解决资源共享的问题，而是用来提供线程内的局部变量，这样每个线程都自己管理自己的局部变量，别的线程操作的数据不会对我产生影响，互不影响，所以不存在解决资源共享这么一说，如果是解决资源共享，那么其它线程操作的结果必然我需要获取到，而<code>ThreadLocal</code>则是自己管理自己的，相当于封装在<code>Thread</code>内部了，供线程自己管理。来看个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;string&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;string&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            threadLocal.set(String.valueOf(num));</span><br><span class="line">            System.out.println(<span class="string">"threadLocalValue:"</span>+threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">1</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">2</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadLocalValue:1</span><br><span class="line">threadLocalValue:3</span><br><span class="line">threadLocalValue:2</span><br></pre></td></tr></table></figure></p><p><strong>值得注意的一点</strong>：<code>ThreadLocal</code>在线程使用完毕后，我们应该手动调用<code>remove</code>方法，移除它内部的值，这样可以防止内存泄露，当然还有就是将<code>ThreadLocal</code>设为<code>static</code>。</p><p><code>ThreadLocal</code>内部有一个静态类<code>ThreadLocalMap</code>，使用到<code>ThreadLocal</code>的线程会与<code>ThreadLocalMap</code>绑定，维护着这个<code>Map</code>对象，而这个<code>ThreadLocalMap</code>的作用是映射当前<code>ThreadLocal</code>对应的值，<code>key</code>为当前<code>ThreadLocal</code>的弱引用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>java 多线程需要考虑并发问题，只要是原子性，可见性，有序性没有同时得到保证，就会产生并发问题，需要做同步。</li><li>做同步时，优先考虑使用<code>synchronized</code>，如有特殊情况，再做优化，如考虑使用<code>ReentrantLock</code>。</li><li>当满足<code>volatile</code>的使用条件时，可以用<code>volatile</code>，来实现轻量级锁。</li><li>由于 <code>Atomic</code> 是通过 CAS 来实现同步，是一种非阻塞解决并发的方式，不会锁住当前线程，效率会更高，当然它也会存在 CAS 所带来的 ABA 问题，另一方面，由于存在重试机制，并发越高，失败重试的次数越多，极大增加 CPU 开销，不适合于竞争非常频繁的场景。</li><li>ThreadLocal 并不解决线程间共享数据的问题，它适用于变量在线程间隔离且在方法间共享的场景。</li></ul><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></li><li><a href="https://www.2cto.com/kf/201601/486898.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201601/486898.html</a></li><li><a href="https://emacsist.github.io/2017/07/04/java-%E4%B8%AD-%E7%9A%84-synchronized-%E4%B8%8E-atomic/" target="_blank" rel="noopener">https://emacsist.github.io/2017/07/04/java-%E4%B8%AD-%E7%9A%84-synchronized-%E4%B8%8E-atomic/</a></li><li><a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1883</a></li><li><a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">http://www.jasongj.com/java/threadlocal/</a></li><li>《java并发编程实战》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 中集合和泛型最佳实践</title>
      <link href="//2018/06/20/java-collections-generics-best-practices.html"/>
      <url>//2018/06/20/java-collections-generics-best-practices.html</url>
      
        <content type="html"><![CDATA[<p>最近看 Java，读到一篇比较好的英文文章，特翻译了下记录下来。原文链接在<a href="http://www.codejava.net/java-core/collections/18-java-collections-and-generics-best-practices" target="_blank" rel="noopener">这里</a></p><p>集合类和泛型是 Java 中比较常用的技术，也是面试时经常问到的点。本篇文章向大家分享的，是一个资深 Java 开发者多年的实战经验。通过本篇文章，你会了解怎么高效而优雅的使用集合、泛型，而不是仅仅停留在 “just work”。</p><a id="more"></a><h2 id="选择正确的集合"><a href="#选择正确的集合" class="headerlink" title="选择正确的集合"></a>选择正确的集合</h2><p>这是使用集合之前的第一个也是最重要的步骤。根据要解决的问题，选择最合适的集合。如果你选错了，你的程序可能仍然有效，但效率不高。如果你选择一个合适的集合，那么程序可能会简单得多，运行也快得多。</p><p>选择合适的集合就像选择一辆从东京到纽约的汽车。如果选择一条船，也许你会在几个月后到达目的地。如果你选择一架飞机，你会在一天之内到达时代广场。如果你选择一列火车，那你都到不了目的地。</p><p>要知道哪种集合（List，Set，Map，Queue等）适合于解决问题，您应该弄清楚每个集合的特点和行为以及它们之间的差异。您还需要了解每个具体实现（ArrayList，LinkedList，HashSet，TreeSet等）的优缺点。</p><p>基本上，您决定通过回答以下问题来选择一个系列：</p><ul><li><p>它是否允许重复元素？</p></li><li><p>它接受null吗？</p></li><li><p>它允许按索引访问元素吗？</p></li><li><p>它提供快速添加和快速移除元素吗？</p></li><li><p>它支持并发吗？</p></li><li><p>等等</p></li></ul><p>每当你不确定某个特定集合的相关信息时，也请参阅他们的 Javadocs</p><h2 id="声明集合时始终使用接口类型"><a href="#声明集合时始终使用接口类型" class="headerlink" title="声明集合时始终使用接口类型"></a>声明集合时始终使用接口类型</h2><p>看看下面两条声明语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();   <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; listNames = <span class="keyword">new</span> ArrayList &lt;String&gt;（）; <span class="comment">//（2）</span></span><br></pre></td></tr></table></figure></p><p>（1）和（2）之间有什么区别？<br>在（1）中，变量 listNames 的类型是 List，在（2）中 listNames 具有 ArrayList 的类型。通过使用接口类型声明集合，代码将更加灵活，因为您可以在需要时轻松更改具体实现，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listNames = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p><p>当您的代码设计为依赖于 List 接口时，您可以轻松地在 List 的实现之间进行交换，而无需修改使用它的代码。在方法参数的情况下，对集合使用接口类型的灵活性更加明显。考虑以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Set&lt;Integer&gt; numbers)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，通过声明参数编号为 Set 类型，客户端代码可以传递 Set 的任何实现，例如 HashSet 或 TreeSet：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(TreeSet);</span><br><span class="line">foo(HashSet);</span><br></pre></td></tr></table></figure></p><p>这使您的代码更灵活，更抽象。相比之下，如果您声明参数编号为 HashSet 类型，则该方法不能接受除 HashSet（及其子类型）之外的任何内容，这样代码就少了灵活性。另外还推荐将接口用作返回集合的方法的返回类型，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection <span class="title">listStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; listStudents = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// add students to the list</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> listStudents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这无疑会增加代码的灵活性，因为您可以更改方法中的实际实现而不影响其客户端代码。所以这第二个最佳实践鼓励你使用抽象类型而不是具体类型。</p><h2 id="使用通用类型和钻石操作符"><a href="#使用通用类型和钻石操作符" class="headerlink" title="使用通用类型和钻石操作符"></a>使用通用类型和钻石操作符</h2><p>当然可以像下面这样声明一个泛型类型的集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; listStudents = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br></pre></td></tr></table></figure></p><p>自Java 7 以来，编译器可以从左侧声明的泛型类型推断右侧的泛型类型，因此您可以编写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; listStudents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>&lt;&gt; 非正式地称为钻石操作符。这个操作符非常有用。想象一下，如果有以下集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;String, Student&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Map&lt;String, Student&gt;&gt;();</span><br></pre></td></tr></table></figure></p><p>没有钻石操作符，你必须重复相同的声明两次，这使得代码冗长，所以尽量使用钻石操作符声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;String, Student&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><h2 id="初始化集合时，尽可能指定容量"><a href="#初始化集合时，尽可能指定容量" class="headerlink" title="初始化集合时，尽可能指定容量"></a>初始化集合时，尽可能指定容量</h2><p>具体的集合类几乎都具有重载构造函数，该构造函数指定集合的​​初始容量（集合在创建时可以保持的元素数量）。这意味着，如果您非常确定将向集合中添加多少元素，请在创建该集合的新实例时指定初始容量。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure></p><p>这会创建一个最初可容纳5000个元素的数组列表。如果不指定此数字，则每次超出当前容量时，数组列表本身将不得不增大其内部数组，这是低效的。因此，请查阅每个集合的Javadocs以了解其默认初始容量，以便您知道是否应明确指定初始容量。</p><h2 id="使用-isEmpty-而不是-size"><a href="#使用-isEmpty-而不是-size" class="headerlink" title="使用 isEmpty() 而不是 size()"></a>使用 isEmpty() 而不是 size()</h2><p>如果要检查一个集合是否为空，最好不要这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (listStudents.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// dos something if the list is not empty  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相反，你应该使用 isEmpty() 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!listStudents.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// dos something if the list is not empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>isEmpty() 和size() 之间并没有性能差异，使用 isEmpty() 的原因是代码的可读性。</p><h2 id="不要在返回集合的方法中返回-null"><a href="#不要在返回集合的方法中返回-null" class="headerlink" title="不要在返回集合的方法中返回 null"></a>不要在返回集合的方法中返回 null</h2><p>如果一个方法被设计为返回一个集合，那么在集合中没有元素的情况下它不应该返回null。考虑以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findStudents</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; listStudents = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">//students are found//) &#123;</span></span><br><span class="line">        <span class="comment">// add students to the lsit</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> listStudents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，如果找不到学生，该方法返回 null。这里的关键是，不应该使用空值来表示没有结果。最好的做法是，返回一个空集合来表示没有结果。上述代码可以通过初始化集合来轻松更正:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; listStudents = <span class="keyword">new</span> ArrayList&lt;&gt;;</span><br></pre></td></tr></table></figure></p><p>因此，请始终检查代码的逻辑以避免返回 null 而不是空集合。</p><h2 id="不要使用经典-for-循环"><a href="#不要使用经典-for-循环" class="headerlink" title="不要使用经典 for 循环"></a>不要使用经典 for 循环</h2><p>如果您编写代码来迭代像下面这样的列表集合，没有什么不妥:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listStudents.size(); i++) &#123;</span><br><span class="line">    Student aStudent = listStudents.get(i);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do something with aStudent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，这种做法不太好，因为使用计数器变量 i ，如果它在循环内部的某处被更改，那么可能会导致潜在的错误。这种循环也不是面向对象的，因为每个集合都有自己的迭代器。所以建议使用如下代码的迭代器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Student&gt; iterator = listStudents.iterator();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Student nextStudent = iterator.next();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do something with nextStudent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，如果迭代器创建后，有另一个线程修改了集合，则该迭代器可能会抛出 ConcurrentModificationException，导致潜在错误。因此最好使用下面的增强 for 循环：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Student aStudent : listStudents) &#123;</span><br><span class="line">    <span class="comment">// do something with aStudent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正如你所看到的，虽然增强型for循环在后台使用迭代器，但它更简洁易读。</p><h2 id="优先使用-forEach-和-Lambda-表达式"><a href="#优先使用-forEach-和-Lambda-表达式" class="headerlink" title="优先使用 forEach() 和 Lambda 表达式"></a>优先使用 forEach() 和 Lambda 表达式</h2><p>从Java 8开始，每个集合都提供了将迭代代码封装在集合本身内部的 forEach() 方法（内部迭代），并且您只需将 Lambda 表达式传递给此方法即可。这使得迭代代码更加紧凑，更灵活，更强大。如下一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; fruits = Arrays.asList(<span class="string">"Banana"</span>, <span class="string">"Lemon"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>);</span><br><span class="line"> </span><br><span class="line">fruits.forEach(fruit -&gt; System.out.println(fruit));</span><br></pre></td></tr></table></figure></p><p>这相当于以下增强的 for 循环：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String fruit : fruits) &#123;</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以我鼓励你使用 forEach() 方法迭代集合，这样可以帮助你专注于代码而不是迭代。</p><h2 id="正确覆盖-equals-和-hashCode-方法"><a href="#正确覆盖-equals-和-hashCode-方法" class="headerlink" title="正确覆盖 equals() 和 hashCode() 方法"></a>正确覆盖 equals() 和 hashCode() 方法</h2><p>当您使用自定义类型的集合时，如一个 Student 对象的列表，记得要正确地覆盖自定义类型中的 equals() 和 hashCode() 方法，以便允许集合有效且正确地管理元素，尤其是在基于它们的哈希代码值组织元素的 Set 集合中。</p><h2 id="正确实现-Comparable-接口"><a href="#正确实现-Comparable-接口" class="headerlink" title="正确实现 Comparable 接口"></a>正确实现 Comparable 接口</h2><p>请记住，当您的自定义类型的元素被添加到通过自然排序（例如 TreeSet 和 TreeMap ）对元素进行排序的集合中时，您的自定义类型会正确实现 Comparable 接口，它还有助于根据元素的自然排序对列表集合中的元素进行排序。</p><h2 id="使用-Arrays-和-Collections-实用程序类"><a href="#使用-Arrays-和-Collections-实用程序类" class="headerlink" title="使用 Arrays 和 Collections 实用程序类"></a>使用 Arrays 和 Collections 实用程序类</h2><p>请注意，Java 集合框架提供了两个名为 Arrays 和 Collections 的实用程序类，它们为我们提供了许多有用的功能。例如，Arrays.asList() 方法返回一个包含给定元素的列表集合，如您所见，我在很多示例中使用了此方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listFruits = Arrays.asList(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</span><br><span class="line">List&lt;Integer&gt; listIntegers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">List&lt;Double&gt; listDoubles = Arrays.asList(<span class="number">0.1</span>, <span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>);</span><br></pre></td></tr></table></figure></p><p>Collections 类提供了各种有用的方法来搜索，排序，修改集合中的元素（几乎都在 lists 中）。因此，在查找其他库或编写自己的代码之前，请记住查看这两个实用程序类的可重用方法。</p><h2 id="在集合上使用-Stream-API"><a href="#在集合上使用-Stream-API" class="headerlink" title="在集合上使用 Stream API"></a>在集合上使用 Stream API</h2><p>从Java 8开始，每个集合现在都有返回元素流的 stream() 方法，因此您可以利用 Stream API 轻松执行聚合函数。例如，以下代码使用 Stream API 来计算整数列表的总和:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">System.out.println(<span class="string">"sum = "</span> + sum);</span><br></pre></td></tr></table></figure></p><p>这里的关键是，总是利用集合上的 Stream API 来编写代码，以便快速方便地执行集合函数。</p><h2 id="优先使用-concurrent-包代替-synchronized"><a href="#优先使用-concurrent-包代替-synchronized" class="headerlink" title="优先使用 concurrent 包代替 synchronized"></a>优先使用 concurrent 包代替 synchronized</h2><p>当您必须在多线程应用程序中使用集合时，请考虑在 <code>java.util.concurrent</code>包中使用并发集合，而不要使用由<code>Collections.synchronizedXXX()</code>方法生成的同步集合。这是因为<code>concurrent</code>集合旨在通过实现像写时复制(CopyOnWrite)，比较和交换，以及特殊锁等不同的同步机制，在并发应用程序中提供最高性能。以下列表显示了如何选择一些并发集合（右侧），它们与正常集合（左侧）相同</p><ul><li><p>HashMap -&gt; ConcurrentHashMap</p></li><li><p>ArrayList -&gt; CopyOnWriteArrayList</p></li><li><p>TreeMap -&gt; ConcurrentSkipListMap</p></li><li><p>PriorityQueue -&gt; PriorityBlockingQueue</p></li></ul><h2 id="使用第三方集合库"><a href="#使用第三方集合库" class="headerlink" title="使用第三方集合库"></a>使用第三方集合库</h2><p>Java 集合框架并不总是满足所有需求，所以第三方集合库出现以满足我们的需求。有很多优质的第三方库，这里列举4个值得收藏的库：</p><ul><li><p>Fastutil：对于像 int 或 long 这样的原始类型集合，Fastutil 是绝佳选择。它甚至能够处理超过21亿（2 ^ 31）个元素的大型集合。</p></li><li><p>Guava：这是用于Java 6+的 Google 核心库。它包含了很多方便的创建集合的方法，如 fluent builders，以及高级集合类型，如 HashBiMap，ArrayListMultimap 等。</p></li><li><p>Eclipse集合：这个库包括几乎所有你可能需要的集合：原始类型集合，multimaps，bidirectional maps 等等。</p></li><li><p>JCTools：这个库为 JVM 提供 Java 并发工具。它提供了 JDK 当前缺少的一些并发数据结构，例如高级 concurrent queues。</p></li></ul><p>不要将自己锁定在JDK提供的Java Collections Framework上，并始终利用第三方集合库。</p><h2 id="消除-unchecked-警告"><a href="#消除-unchecked-警告" class="headerlink" title="消除 unchecked 警告"></a>消除 unchecked 警告</h2><p>当编译器发出未经检查的警告时，请不要忽略它们。最好的做法是，你应该消除未经检查的警告。考虑下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(list1);</span><br></pre></td></tr></table></figure></p><p>尽管上面代码仍可编译，但编译器会发出如下警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note: ClassNam.java uses unchecked or unsafe operations</span><br></pre></td></tr></table></figure></p><p>未经检查的警告很重要，所以不要忽视它们。这是因为每个未经检查的警告都表示运行时可能出现 ClassCastException。在上面的代码中，如果 list1 包含 Integer 元素而不是 String，那么使用 list2 的代码将在运行时抛出 ClassCastException。<br>尽最大努力消除这些警告。上面的代码可以这样纠正：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(list1);</span><br></pre></td></tr></table></figure></p><p>但是，并不是每一个警告都可以像这样轻易消除。如果您无法消除未检查的警告，请证明该代码是类型安全的，然后在尽可能最窄的范围内使用 <code>@SuppressWarnings(“unchecked”)</code>注释来禁止警告。也写注释解释为什么你压制警告。</p><h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><p>尽可能的把已有的类型泛型化，因为泛型更安全，更易于使用。当你设计新的类型时，也要考虑它们是否可以被泛型化。同样的，Java 也鼓励您使用泛型参数编写新方法，并将现有方法转换为使用类型参数，因为泛型方法比非泛型方法更安全，更易于使用。泛型方法还可以帮助您编写更通用且可重用的 API。</p><h2 id="使用有界通配符来增加-API-灵活性"><a href="#使用有界通配符来增加-API-灵活性" class="headerlink" title="使用有界通配符来增加 API 灵活性"></a>使用有界通配符来增加 API 灵活性</h2><p>在编写新的泛型方法时，请考虑在输入参数上使用通配符类型以获得最大灵活性。考虑以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(Collection&lt;Number&gt; col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (Number num : col) &#123;</span><br><span class="line">        sum += num.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此方法的局限性是它只能接受 List<number>，Set<number>，但不接受 List<integer>，List<long> 或 Set<double>。为了最大限度地提高灵活性，请更新方法以使用有界通配符，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(Collection&lt;? extends Number&gt; col)</span></span></span><br></pre></td></tr></table></figure></double></long></integer></number></number></p><p>现在，该方法可以接受任何类型的集合，这些类型是整数，双精度，长精度等数字的子类型。</p><p>以上就是使用 Java 中集合和泛型的最佳实践，或许有些你已经知道，但关键是，你要尽快在日常编码中，有意识的使用它。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的这 10 年</title>
      <link href="//2018/06/07/my-10-years.html"/>
      <url>//2018/06/07/my-10-years.html</url>
      
        <content type="html"><![CDATA[<p>这篇文字在草稿箱里已经存了几个月了，趁着周末加班改完 bug，还是做个了结吧。</p><p>现在是2018年6月，新闻前两天还一直在报道今年高考的消息，今年全国高考人970万。回想起我第一次参加高考，已经过去整整 10 年了，现在看到视频里那些进入考场的莘莘学子，感慨万分，他们才是早上八九点的太阳啊。。。看了下历年的高考人数变化，没想到，我高考的那两年，居然是高考人数的最高峰。像是过关游戏中，小手一抖，选择了 hard 模式。高考的人数变化，也一定程度上，反应了我们国家人口的变化。越来越多的人相信，在未来半个世纪，中国劳动力人口在呈逐年下降趋势。目前，国家全面开放二胎政策，鼓励多生。想想当年父母生我弟时，由于“计划生育”，村中大队的人过来要求罚款，但家里实在一贫如洗，那些人就如强盗样，把家唯一的家电：一台收音机给抱走了。这才多少年啊？！而现在孩子如同碎钞机，巨大抚养压力，反而大多数家庭都打消了二胎的想法，不可谓不讽刺。<br><a id="more"></a></p><p>我第一次参加高考是 2007 年，可是那年天不如愿，发挥失常，没考出理想成绩。尤其是语文，写完作文我就基本知道要凉，结果出来后，无意外，肯定上不了一本线，又不想去二本，于是咬牙复读了一年，第二年终于如愿以偿。想起复读那年，国内发生了太多大事，年初的雪灾，汶川地震，北京奥运。雪灾的那几个月，记得每天晚上放学回家，地面都是一层厚厚的冰，走路骑车都很危险。虽然每年我们那都会下雪，但地面长时间结冰，还是头一次见。快过年时，老师说，外面县市的同学如果没车回不去，本地的同学每人捎一个回家过年吧。。。</p><p>雪灾过后，然后就是5.12 地震了。记得那天，我们在拍毕业照吧，在操场上，没怎么感觉，第二天，从新闻报纸得之消息后，才发现四川的灾情是多么严重。当电视里的温总理前往灾区，安慰无家可归的孩子说不要哭，当老师说着捐款时，当从报纸看到那惨白的死亡数字，唯一的颜色就是五星红旗时，大家都异常难受。当时，整个国家都陷入了一片悲恸。各种捐款各种物资，如雪花一样运往灾区，5.12地震，对于中国来说，是一次沉重的苦难，也让我第一次真真切切看到了民族的凝聚力，什么叫做一方有难八方支援。</p><p>地震过后，就是第二次高考了。依稀记得进考场前，老师问我们，有没有信心，大家异口同声喊：有！洪亮的声音仿佛整栋楼都在震动，人生难得机会博？那种斗志，只有后来大学时军训才再次重现，此后再也没有了。回首那些年的读书生涯，以及在外面的这么多年，给我的感受是，高考，是人生中的第一道坎，怎么强调它的重要性都不过分。尽管时不时会听到有抨击高考政策的声音，但不可否认，高考是现阶段国内最公平的一次人才选拔，也许是整个社会最公平的一次竞争。不看脸，不拼爹，全凭个人的实力，对于个人来说，这是改变命运最有效，也是最保险的途径了。祝愿今年的考生们，好好把握机会，考出好成绩。</p><p>高考完就是北京奥运，那一年，一首北京欢迎你的歌声传遍海内外，中国夺金的数量一举夺得头魁。十年过去，现在再听听这首歌，联想起去年末北京西红门的那场“赶人”运动，真是一种讽刺。</p><p>那年的暑假没事做，去琴社学了下吉他，两个月的时间，基本入门，从小白到能弹唱基本的歌曲，忽悠外行人还是没问题的。和我一起学的，还有好多小孩，看着他们弹的水平，有的真让我自愧不如。学艺要趁早啊，真和年龄无关。也难怪现在的父母，大把大把的给小孩砸钱报各种班，你没报班都不好意思出去遛娃。兴趣班一节课几百块，报两三个班，每个月都是不小的开支，可怕！</p><p>可是我到大学后，没找个好组织，也苦于那时生活拮据，没钱买个好点的吉他，技能最终荒废。</p><p>我的大学是在山城重庆，这个城市给我的感觉就是潮湿，非常潮湿，学校又是在山上，更加潮湿，绵绵细雨一年四季下个不停，空气湿度高，路面常年湿漉漉的，学校有个著名的“夺命天梯”，从下面往上看，食堂和宿舍楼云雾缭绕，犹如仙境。阳台晒的衣服，几天都干不了，床上的被子，冬天都感觉是湿的。在重庆的那 4 年平平淡淡，感情上，没正经耍过朋友（重庆话里，谈恋爱叫耍朋友，毫无贬义）；学习上，一直处于“中庸状态”，班里的学霸多如牛毛，也跟自己确实没怎么用心有关，虽然四年里都没挂过科，但也没拿过奖学金。大一下学期配了电脑后，游戏和电影成了主要的娱乐方式，玩各种端游，看各种大片。有时会想，大学也不过如此，跟高中时读的书《草样年华》，听的广播剧《让青春继续》里完全不一样啊。</p><p>我学的专业是通信工程，虽然是这学校最好的专业，但一直不知道自己以后想干嘛。选这个专业，也是当时高考完后，在父母，和当时在联通工作的舅舅安排下选的，那时的运营商，日子过得还很滋润，是就业选择的香饽饽，因此他们希望我毕业也就联通工作。但那时的运营商，已处在智能手机爆发的前夜，后来运营商的情况大家都知道了。</p><p>到了大三下，基本到了该决定是考研还是工作的时候，一方面被导师的话蛊惑：考研吧，就算现在不考，以后还是要考（这可能跟导师一直在学校做科研有关）。另一方面，当时确实是不知道自己能干啥，于是没怎么参加校招，加入了班上的考研大军。</p><p>现在看来，考研，可以说是我大学最下功夫最投入的一件事了。记得大学时，每次要到期末考试前才去上自习，一度感慨：现在为了期末考试，就这么累，真不知道以后如果考研，那不是要废掉。没想到最后两眼一黑一路走到底，考研时真的坚持下来了。备考的那半年，每天保持高强度学习，大三暑假回家呆了两周，效率明显不行，果断又回到了学校继续学习。重庆的夏天如火炉，40 度的高温，暑假学校里都没什么人，我每天早上去四教自习，晚上 10 点回宿舍睡觉，有时走在学校空旷的路上，会问自己：这么辛苦，是为了什么呢？</p><p>备考的日子从那年夏天一直持续到冬天，考研如期进行，考完后觉得要凉，结果分数出来后发现并没有。考研过程确实摧残人，尤其是英语，考完后，一部分人会弃考，同宿舍的一个小伙伴，考完数学后直接弃考，我们怎么劝都没用，后来他参加了二战。对于他的弃考，虽然我没问，但我觉得他后来肯定是后悔的。</p><p>成绩出来后，就是准备复试了，当时班上和我考一个学校的还有几个小伙伴，成绩出来的当天我们就坐动车去成都的学校找导师，为了省钱，4 人在学校外面租了个单间住了一周，有两个小伙伴还打地铺，我们约着两天互换睡地铺。。。复试的过程，也是充满了跌宕起伏，由于我过线分数并不高，第一批复试完感觉自己没人要，准备第二批，结果第一批录取名单出来后，跑到网吧查，赫然发现自己居然在列，喜出望外，终于成功了！考研也告一段落。</p><p>考研完，整个人就轻松多了，大学剩下的几个月就轻松多了，尝试找了个兼职：送外卖。。。那会儿还是 2012 年，外卖行业基本还处于萌芽阶段，服务群体就是在校学生，流程也非常原始：首先给各宿舍发小传单，留电话，学生下单方式就是打电话，然后我去店里拿餐，开始时，连电动车都没有，全靠脚力，非常辛苦。做了一个月，拿了 600 块，本来说好的报销电话费，后来老板说亏损 1000 多，我也就没要了。</p><p>现在的外卖业已经相当成熟了，走在外面路上，随时可以看到黄的蓝的骑手在你身边穿梭，而我当年兼职送外卖的那一个月，也可以算是最早的一批骑手吧。外卖送完，就到了大学毕业季，没啥新奇，就是各种聚餐喝酒拍照。</p><p>大学毕业后，和妈妈去新疆的叔叔家玩，他家在哈密，一听这名字，是不是想到了香甜的哈密瓜？没错，那里的瓜真是个大又甜。然而那次旅行真是一次生死的经历，叔叔开车带我们去玩，在天山路上发生了严重车祸，车毁了，万幸的是，车上 5 人都没啥大事，除了我眼睑上被划了一道口子，缝了几针，如果受伤的部位再下去一点，我可能就要成残疾人了。缝好针后，眼皮上留下了一道疤，不过带上眼镜后，没那么明显。车祸后，我感觉像是经过了一次重生，但一段时间坐车都心有余悸，会不由自主想象车祸的场景。</p><p>然后就是在成都读研的三年了，读研的生活就如同成都这个城市一样，不紧不慢，研一需要正常上课，上课的那年，一度让我觉得，这 tm 跟大学有啥区别？所幸的是，这边学霸没那么多，于是这三年都拿了一等奖学金，学费全免，也没怎么跟家里要过钱了。但教研室的老板却是相当的抠，说是老板，其实他是我们的导师，身上各种光环头衔。国家规定给研究生每月发的 270 元补助，他都要扣 70，只给我们发 200。每次项目学校打给我们卡上的劳务费，都要让我们取出来交上去。一直到研三，国家将补助调到了 500，直接打到个人卡上，才没有扣钱。</p><p>在成都，我开始踏上骑行之路，其实本来是玩轮滑的，研一时报了轮滑社，但轮滑有个弊端，对路况要求高，路得平，而且出了学校，外面的马路车多太危险，轮滑速度也慢，种种因素注定轮滑使用的半径还是太小，只能在学校里小打小闹，刷马路就有点吃力，于是改骑行了。成都的骑行氛围很好，有很多骑川藏线的朋友，因为这是川藏线的起点，每年都有很多骑行爱好者，从成都出发，一路骑车去西藏，2000 多公里，要骑 20 多天，需要翻越上 10 座大山，这绝对是一个充满挑战和风险的经历。</p><p>学校有很多玩车的伙伴，其中不缺乏土豪，公路、碳架、上万的豪车也能看到。当然我自己是没钱买好车的，花了 1700，买了个二手的捷安特 ATX750，自从有了山地车，整个世界仿佛大了许多，以前那些觉得好远，交通不方便，坐车好麻烦的地方，也因为有了车而变成可能，周末会约上几个骑友，去温江西财吃鱼香茄子，去都江堰看看水，去龙泉驿爬爬山，去阿坝州看看羌寨。这个车陪伴了我 2 年多，一直到毕业。也许这是一辆自带幸运光环的车，两年多的时间，它没有坏过没有修过，连胎都没爆过，就算是当时去映秀，去卧龙，在那种完全没法骑的石头路上摧残，车身都是泥，都看不清它原来的颜色，它也依然坚固。到毕业时，车上的码表显示已经骑行超过 5000 公里。最终，我把它卖给了一个准备骑川藏的同学，希望幸运也一直伴随着他吧。</p><p>学校的硕士研究生是三年制，实验室的研究方向是光纤传感，这三年，在学术上，做了实验，发了文章，写了专利。除此之外，似乎也没啥了。有时在想，读研的意义又是什么呢？如果一上大学，就知道自己想要什么，兴趣点在哪里，然后定个方向，努力朝着这个方向走，到毕业时也许就不会那么彷徨了。工作，会让你更早进入职场和社会，更早获得锻炼，让你知道企业需要什么；读研，可以再给你一次塑造自己的机会，会给你一个更高的起点，让你找工作时，能比本科有更好的第一印象，至少，在我面试他人时，看到研究生的简历，会比本科生要更加耐心。</p><p>研究生 3 年很快过去，又到了要找工作的季节，这个时候，不能再拿读博来逃避了，都一把年纪了。最终觉得以自己的情况和性格，没法做改变世界的大事，还是老实去写代码吧，于是拿起面试宝典，剑指 offer 看起来。经过一顿恶补，校招时，也骗到了几个 offer，最开始签的是武汉的一家通信类的国企，想着离家近点。到后来还是想搏一搏，遂毁约又签了北京的互联网公司。</p><p>2015 年 6 月，拿完毕业证，学位证，吃完散伙饭，正式结束了读书生涯。7 月，我拖着箱子，踏上了北上的火车，开始了北漂。刚来北京那会儿，既兴奋又孤独，兴奋的是，这是中国的首都，可以看天安门，看鸟巢，以及传说中的“京霾”。孤独的是，班上来北京的只有我一个，在这边没一个认识的人，来的第一天找房子时，没地方放行李箱，就拖着箱子到处找，第一天没找到合适的，就联系了还在北京读研的一个大学同学，正好他在外地实习，于是就在他宿舍借宿了一晚，第二天幸运之光降临，意外联系上了一个在北京已经工作 2 年其他学院的师兄，他那正好空出一个次卧，还没有隔断，价格 1600，贵了点，但房子条件不错，于是果断租下了，住宿问题终于解决。期间问了下在成都上班的小伙伴，有三个同学合租了个大三居，价格1500，平均每人500。。。T_T，WTF！为什么要让我知道！！</p><p>刚来北京的那会儿，特别喜欢出去逛，自己一个人去了天安门，去了北海，去了天坛，去了鸟巢，一切都如电视上看到的那样，如小时候课本说的那样，如歌曲里唱的那样，一切都是那么新奇。公司的氛围也好，有舒适的办公环境，有免费好吃的食堂，身边有厉害的同事，工作上也学到了好多新技术新知识，周末没事会去公司加个班，蹭个免费的饭吃。一切似乎都表明，来北京，值！</p><p>到今年6月，毕业整整三年。这三年，我从一个学生变成一个职场人士(职场人士很正式，给人的印象是一手提公文包，一手打电话，西装革履的人，确切的说，我这属于互联网从业者），从一个单身狗，经过某次偶然机会脱单，又变成一个已婚人士，从对房子毫无概念，到可以接受低工资拿武汉户口只为了买房。曾经一些老江湖说过，毕业 3 年，同学之间就会有一定的差距了，5 年后，差距会很明显。如今，我也站到了这个 3 年的坎上，心态似乎也缓慢发生了变化。没事周末肯定不去公司，逛景点？我住在五环外面呢，进城很麻烦的，别忘了自己低端人口的身份。以前对那些住天通苑，住通州的同事不能理解，上班得一个小时，为嘛住那么远，现在看看自己的通勤时间，似乎没啥不能理解的了。</p><p>其实自己的职业路比较奇特，本科时学的通信，学《信号与系统》，《通信原理》，《数字电路》，研究生时学的光学，学《激光原理》，《非线性光学》，结果找工作机缘巧合，进入到了互联网行业，成了一个码农，基本都是不相干的学科，居然被我给串上了。</p><p>人生总是充满变数，高考时，说想离家近点，要报武汉的大学，结果去了重庆；等考研时，说想考回武汉，结果去了四川；等找工作时，又说想离家近点，找个武汉的工作吧，结果来到了北京。2008 到 2018，离家整整十年。这十年的变化实在太大，十年前，我没有出过省，没有离过家，不知道“从此故乡，只有春夏，再无秋冬”；十年前，我没有银行卡，没有支付宝，更没有存款；十年前，大家都拿着诺基亚手机发短信，比彩铃，比彩屏，没有见过智能机，更不知道 iPhone；十年前，我上网得去网吧，和爸妈视频也只能去网吧，玩游戏也只能在 PC 上玩；十年前，我没有网购，甚至都没听过网购；这十年的变化太大，很多事情，放在十年前不可想象，大到让我对故乡有了一丝陌生感，让我变得经常回忆过去。未来的十年，又会有哪些变化呢？Time will tell</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 zookeeper 的一些原理</title>
      <link href="//2018/04/08/zookeeper.html"/>
      <url>//2018/04/08/zookeeper.html</url>
      
        <content type="html"><![CDATA[<p>分布式系统中，协调和管理服务是一个复杂的过程，数据的一致性也是一个不可避免的问题，而 zookeeper 是一个解决分布式集群应用中数据一致性问题的有效工具，它提供基于类似于文件系统的目录节点树方式的数据存储，<strong>但是 zookeeper 并不是用来专门存储数据，它的主要作用是用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。</strong></p><h2 id="zookeeper-的数据模型"><a href="#zookeeper-的数据模型" class="headerlink" title="zookeeper 的数据模型"></a>zookeeper 的数据模型</h2><p>zookeeper 的设计，借鉴了 Linux 中的文件系统，我们知道，在 Linux 中，用 <code>/</code> 来区分目录，如<code>/</code> 表示根目录，<code>/home</code> 表示在根目录下有个 home 目录， 同样，在 zookeeper 中，<code>/</code> 表示根节点， <code>/master</code> 表示根节点下的 master 节点，zookeeper 中的这种节点，被称为 <strong>znode</strong>。我们可以像创建目录一样，在 zookeeper 中创建任意一个节点。如图一。<br><img src="/images/zookeeper/znode.png" alt="图一"></p><p>与 Linux 目录不同的是， znode 节点还有自己独特的一些属性。</p><ul><li>访问一个 znode 只能使用绝对路径，而不能使用相对路径，例如 <code>../</code> 和 <code>./</code> 这种表示在 zookeeper 中是不被允许的。</li><li>znode 节点中，也可以存放数据，但并不适合存放大量数据，znode 节点存储数据大小不能超过 1M。</li><li>节点有持久节点 (persistent) 和临时节点 (ephemeral)，在创建 znode 时指定，且后续不可修改。持久节点创建后，除非主动删除，否则会一直存在。临时节点创建后，一旦客户端与 zookeeper 会话断开，临时节点就会被删除。当然临时节点也可以被显示删除。节点的这种特定，很适合用来做分布式系统中节点的健康检查。</li><li>节点可以有子节点，就像 Linux 某目录可以有子目录一样，但临时节点不可以有子节点</li><li>节点可以被监控（watch），当某个节点被客户端监控，那么当该节点中存储的数据，或者该节点的子节点发送变化，zookeeper 会通知设置监控的客户端，那么客户端可以根据通知，做相应的变化。这是 zookeeper 的核心特性，许多应用场景，均是使用了该特性。</li></ul><p>有了znode 的概念，应运而生，就有了操作 znode 的 API，zookeeper 提供了 Restful 的 API，可以很方便的对节点进行 CRUD 操作。</p><ul><li>create 创建一个 znode</li><li>delete 删除一个 znode</li><li>getData 获取一个 znode 中的数据</li><li>exists 判断一个 znode 是否存在</li><li>getChildren 获取一个 znode 的所有子节点</li></ul><h2 id="zookeeper-部署模式"><a href="#zookeeper-部署模式" class="headerlink" title="zookeeper 部署模式"></a>zookeeper 部署模式</h2><p>zookeeper 既可以以单节点模式运行，即只在一台机器上部署 zookeeper 服务，也可以以集群方式运行。事实上，为了发挥 zookeeper 的高可用特性，最佳实践应该以集群方式运行。幸运的是，在个人测试或者资源紧张时，在单台机器上，zookeeper 仍然可以模拟集群模式，即在一台机器上起多个 zookeeper 实例，只需要在配置文件中，修改指定配置项即可。</p><p>当 zookeeper 以集群方式运行时，会有一些独特的特性。</p><p>首先，并不是所有的节点都是一样的，zookeeper 集群中，会自主产生一个 leader 节点，其他都是 follower 节点，或者 observer 节点。所有对 zookeeper 的写操作，都会由 leader 节点来完成。读操作，可以由 follower 或者 leader 节点完成。事实上，当客户端连接到 zookeeper 时，它根本就不知道连接的是 leader 还是 follower。因此，当客户端有写操作，而它有恰恰连接到的是 follower 节点，那么该写操作仍然是转发给 leader 节点来完成。当 leader 节点挂掉时，zookeeper 会自动重新从剩余的节点中，再选一个 leader 出来。至于 leader 是怎么选出来的，这个涉及到 zookeeper 的选主算法，本文不做深入讨论。</p><p>其次，zookeeper 通过复制保证高可用性，每个 follower 节点的数据，都是 leader 节点数据的副本。集群中，只要有半数以上的节点处于可用状态，那么 zookeeper 就可以正常对外提供服务。如 5 个节点的 zookeeper 集群，就算有 2 个节点挂了，也可以保证服务继续，因为剩余的 3 个节点超过了半数。</p><p>再者，由于集群模式下的 zookeeper 服务有多个节点，同一时间，不同的客户端连接到 zookeeper，看到的数据应该是一样的，即 zookeeper 必须要保证数据一致性。zookeeper 从以下几点，保证了数据一致性</p><ul><li><strong>顺序一致性</strong><br>  来自任意特定客户端的更新都会按其发送顺序被提交。也就是说，如果一个客户端将 znode z 的值更新为 a，在之后的操作中，它又将 z 的值更新为 b，则没有客户端能够在看到 z 的值是 b 之后再看到值 a（如果没有其他对z的更新）</li><li><strong>原子性</strong><br>  每个更新要么成功，要么失败。这意味着如果一个更新失败，则不会有客户端会看到这个更新的结果</li><li><strong>单一系统镜像</strong><br>  一个客户端无论连接到哪个节点，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的节点，它所看到的系统状态不会比在之前节点上所看到的更老。当一个节点出现故障，导致它的一个客户端需要尝试连接集合体中其他节点时，所有滞后于故障节点的节点都不会接受该连接请求，直到节点的状态赶上之前故障的节点为止。</li><li><strong>持久性</strong><br>  一个更新一旦成功，其结果就会持久存在并且不会被撤销。这表明更新不会受到服务器故障的影响。</li></ul><h2 id="zookeeper-的使用场景"><a href="#zookeeper-的使用场景" class="headerlink" title="zookeeper 的使用场景"></a>zookeeper 的使用场景</h2><p>了解了 zookeeper 的一些基本概念，我们对 zookeeper 有了宏观上的认识，<strong>zookeeper 的这种设计，类似于设计模式中的观察者模式，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应，从而实现集群中类似 Master/Slave 管理模式。</strong> </p><p>下面看看使用 zookeeper 的几个场景。</p><h3 id="统一命名-Name-Service"><a href="#统一命名-Name-Service" class="headerlink" title="统一命名 (Name Service)"></a>统一命名 (Name Service)</h3><p>分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，就像数据库中产生一个唯一的数字主键一样，通常情况下用树形的名称结构是一个理想的选择。这里的名称是很宽泛的，可以是指集群的机器名，也可以是提供的服务地址，进程对象等。我们都可以称他们为名字。较为常见的就是一些分布式服务框架中的服务地址列表。通过调用 zookeeper 提供的创建节点 API，能够很容易创建一个全局唯一的 path，这个 path 就可以作为一个名称。Name Service 已经是 zookeeper 内置的功能，你只要调用 zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。</p><h3 id="配置管理-Configuration-Management"><a href="#配置管理-Configuration-Management" class="headerlink" title="配置管理 (Configuration Management)"></a>配置管理 (Configuration Management)</h3><p>配置管理在分布式应用环境中非常常见，例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。</p><p>像这样的配置信息完全可以交给 zookeeper 来管理，将配置信息保存在 zookeeper 的某个节点中，所有用到该配置信息的节点都监控配置信息的状态，一旦配置信息发生变化，每个节点就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p><h3 id="集群管理-Cluster-Management"><a href="#集群管理-Cluster-Management" class="headerlink" title="集群管理 (Cluster Management)"></a>集群管理 (Cluster Management)</h3><p>有多台机器组成一个集群，必须有一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它机器必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台机器，同样也必须让“总管”知道。</p><p>zookeeper 可以帮我们在集群中选出这样的“总管”，同时，当这个总管挂掉，zookeeper 可以在剩余的机器上，选择另一个替代的总管。避免总管挂掉导致整个集群不可用。这就是 zookeeper 的<strong>选主功能</strong>。选主是 zookeeper 最重要的功能之一。</p><h3 id="分布式锁-Distribute-Lock"><a href="#分布式锁-Distribute-Lock" class="headerlink" title="分布式锁 (Distribute Lock)"></a>分布式锁 (Distribute Lock)</h3><p>我们知道，单个节点上的多进程同步，可以使用互斥锁。进程要进入临界代码，先获得锁，然后才能操作临界区中的代码，没有获得锁的进程，必须等待锁。而在分布式系统中，情况就不同了。没有这么一个可以供多个节点上多个进程共享的锁。zookeeper 提供了一个解决方案，我们可以使用可排序的 znode 来实现。</p><p>原理很容易理解，我们可以先创建一个 <code>/leader</code> 的节点，然后让所有进程都尝试在 <code>/leader</code> 下创建 <code>lock</code> 临时节点，由上文得之，有且只有一个进程能创建成功。其他进程均创建失败。那么创建 <code>lock</code> 节点成功的进程，即表示获得了锁，可以做临界操作。以后，除非该进程主动释放锁，或者该进程崩溃，由于 <code>lock</code> 是临时节点，因此进程崩溃后，会自动删除，那么其他进程就又可以去竞争创建锁了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>zookeeper 作为 Hadoop 项目中的一个子项目，在分布式系统中，承担着重要的角色，它解决的是分布式系统中遇到的一类典型问题，很多分布式系统中，都会用到 zookeeper 来保证系统运行。 如在 hadoop 集群管理中，它主要用来控制集群中的数据，如管理 hadoop 集群中的 NameNode，还有 Hbase 中 Master Election、Server 之间状态同步等。</p><p>本文介绍的 zookeeper 的基本知识，以及介绍了几个典型的应用场景。这些都是 zookeeper 的基本功能，最重要的是 zoopkeeper 提供了一套很好的分布式集群管理的机制，就是它这种基于层次型的目录树的数据结构，并对树中的节点进行有效管理，从而可以设计出多种多样的分布式的数据管理模型，而不仅仅局限于上面提到的几个常用应用场景。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></li><li><a href="https://www.cnblogs.com/sunddenly/p/4138580.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunddenly/p/4138580.html</a></li><li>《ZooKeeper分布式过程协同技术详解》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学上的一些经典片段</title>
      <link href="//2018/03/22/about-mathematical-formula.html"/>
      <url>//2018/03/22/about-mathematical-formula.html</url>
      
        <content type="html"><![CDATA[<p>最近看的几本书里，都有提到一些数学方面的知识，有些符号和公式，放在现在，可能觉得没什么，一个小学生都能看懂，但却鲜有人知道，普及这些理论，需要几代人的不懈努力和探索。有些公式和推导，都堪称数学史上的经典，这里摘取一些片段，体会下数学的美妙，也让我们看看人类的智慧是无穷的<br><a id="more"></a></p><h2 id="质数是有限个吗？"><a href="#质数是有限个吗？" class="headerlink" title="质数是有限个吗？"></a>质数是有限个吗？</h2><p>质数是一个很古老的的概念，是数论中一个很重要的研究对象，大家在小学都学过。所谓质数，就是不能用两个或两个以上较小整数的乘积来表示的数，如2，3，5，7，11，13，17，等等。而 12 可以写成 2×2×3，所以就不是质数，我们称 12 这样的数为合数。显而易见，一个自然数，要么是质数，要么是合数。</p><p>关于质数，最初产生的一个问题就是：质数的个数是否是无限的呢？还是说存在一个最大的质数，即凡是比这个最大质数还大的数都可以表为几个质数的乘积呢？这个问题最初是由欧几里得提出的，同时他也给出了此问题的回答。现在我们知道，问题的答案是：<strong>有无穷多个质数。</strong></p><p>欧几里得关于质数有无限多个的证明，至今仍然是数学推理的一个典范。他用的方法，就是现在所熟知的<strong>反证法</strong>。我们从一个尝试下的假设出发，即认为质数是有限多个，比如有 $n$ 个。即，其他任何一个数都是合数，且在 $p_1$, $p_2$ 中至少有一个能整除它。现在构造一个数 $A$ $$A={p_1} \ast {p_2} \ast \cdots  \ast {p_n} + 1$$ 现在这个 $A$ ，比任何一个质数都大，因而是合数，但是我们用 $p_1$ , $p_2$ 等去除 $A$ 总是又余 1，因此这些 $p$ 不是 $A$ 的因子。这是由我们当初的假设（仅有有限个质数）而导致的矛盾，因而这个假设是不成立的，从而它的反面必然是正确的，即质数有无限多个。</p><p>以上证明说明，想找一个最大的质数是不现实的。<strong>事实表明，即使找一个很大的质数，也是相当困难，现在计算机领域中广泛使用的非对称加密RSA的数学原理，就是基于这个事实。</strong>迄今为止，我们找到的最大的质数是 $2^{74207281}-1$，这个数字已经很大了，长达 2233 万位！</p><p>以上即是反证法的一个经典案例，至今该方法仍然是数学家们手中论证命题的一个强有力武器。</p><h2 id="质数的分布"><a href="#质数的分布" class="headerlink" title="质数的分布"></a>质数的分布</h2><p>质数这么多，有没有一个产生质数的通用公式呢？遗憾的是，人们做了很多次尝试，但都失败了。并没有一个公式可以做到这一点。那么，质数的分布有什么规律呢？我们用 $A_n$ 表示自然数 $1,2,3,…,n$ 中的质数个数，比如 8 以内的质数为 2，3，5，7，因此$A_8=4$, 我们查出，在 1 000 之内有 168 个质数，在 1 000 000 之内有 78 498 个，在 1 000 000 000 之内有 50 847 478 个。 我们令比值 ${A_n \over n}$ 表示前 $n$ 个自然数中质数的<strong>“密度”</strong>，可以得出如下表:</p><table><thead><tr><th>数值范围 1~n</th><th>质数个数</th><th>质数密度</th><th>1/${\ln{n}}$</th><th>偏差(%)</th></tr></thead><tbody><tr><td>1 ~ 100</td><td>26</td><td>0.260</td><td>0.217</td><td>20</td></tr><tr><td>1 ~ 1000</td><td>168</td><td>0.168</td><td>0.145</td><td>16</td></tr><tr><td>1 ~ ${10^6}$</td><td>78498</td><td>0.078498</td><td>0.072382</td><td>8</td></tr><tr><td>1 ~ ${10^9}$</td><td>50847478</td><td>0.050847478</td><td>0.048254942</td><td>5</td></tr></tbody></table><p>在自然数中，单个质数的分布式不规则的，但如果把注意力集中到由比值${A_n \over n}$给出质数的分布时，会发现这种不规则消失了，这个比值所服从的简单规律，是整个数学中最著名也最值得称道的发现之一。该规律表述为：<strong>从 1 到任何自然数 $n$ 之间，所含质数的百分比，近似由 $n$ 的自然对数的倒数表示</strong>，写成数学语言，可以有以下描述:</p><p><center>当 $n$ 足够大时，${A_n \over n} \sim {1 \over \ln{n}}$</center><br>白话一点，就是当 $n$ 增加时，$A_n/n \over 1/{\ln{n}}$ 趋近与 1。</p><p>质数分布的平均状态，可以用对数来描述，这是一个很引人注目的发现，两个似乎完全无关的数学概念，在事实上竟有如此紧密的联系！不得不说很令人奇怪。</p><p>这个发现，最初是由伟大的数学家高斯发现的，他当时也只是猜想，而要给出证明，他那个时代的数学是远远不够的，这个定理虽然只涉及最基本的概念，但其证明，必须用到近代数学中最有力的方法。从高斯猜想后的 100 多年，到 19 世纪末，该定理才得以完整证明。由于证明太繁琐，这里就不介绍了。</p><h2 id="勾股定理和无理数"><a href="#勾股定理和无理数" class="headerlink" title="勾股定理和无理数"></a>勾股定理和无理数</h2><p>勾股定理，是数学中一个老少皆知的定理，在西方也叫毕达哥拉斯定理，这是一个很古老的定理，说的是在一个直角三角形中，两条直角边的平方之和，与斜边的平方相等。根据这一定理，毕达哥拉斯的一个弟子——希帕索斯，在求正方形的对角线长度时，却发现无法用一个数，或者说无法用一个等价的分数来表示它。而按照毕达哥拉斯的理论来说，世间万物的关系都可以用整数或者正数之比来表达。现在却发现，无法找到一个可以表达正方形对角线长度的数。同时，希帕索斯还用上面提到的反证法，证明了边长为 1 的正方形对角线无法用两个整数之比表示，这里给出用现代算数的一个证明。</p><p>选定正方形的边长为1，而对角线的长为$x$，根据勾股定理，有$$x^2=1^2+1^2=2$$如果现在假设可以找到两个整数 $p$ 和 $q$，使 $x={p \over q}$，则<br>$$p^2=2q^2$$我们假设 ${p \over q}$ 已经是不可约的，因为分子和分母的任意公因子在一开始就可约去。由于2是上式等号右边的一个因子，所以左边的 $p^2$ 是偶数，故 $p$ 本身是偶数，因为奇数的平方只能是奇数，于是我们可以写出 $p=2r$，其中 $r$ 为整数。这时上式变为<br>$$4r^2=2q^2，或 2r^2=q^2$$由于 2 是左边的因子，则 $q$ 必须为偶数，这样一来 $p$ 和 $q$ 同时可以被 2 整除，和 $p$, $q$ 没有公因子的假设矛盾，因此 $p^2=2q^2$ 不成立，且 $x$ 不能是有理数。</p><p>无理数的发现，是数学史上最惊人的发现之一，现在任何一个中学生都会用根号表示无理数，这个看似很普通的记法，直到近代 16 世纪才被引入!</p><p>另外一个关于无理数的有趣的结论：<strong>无理数比有理数多得多，在数轴上随便选一个点，几乎不可能选到有理数！</strong></p><h2 id="神秘的圆周率"><a href="#神秘的圆周率" class="headerlink" title="神秘的圆周率"></a>神秘的圆周率</h2><p>第一次看到圆周率这个名词，还是读小学三年级时，教室外面的墙上，挂着各种名人照片，其中就有祖冲之，有这么一段话，大致内容就是他把圆周率精确到了小数点后面第7位，当时还不太懂什么是圆周率。这里不说 π 是什么，我们从另外一个问题，来看看这个神奇的 π。</p><p>18 世纪，数学领域开始出现一个新的分支，概率。有个法国科学家，提了一个概率问题，为了实验这个概率问题，需要有一面美国国旗，即红白条相 间的旗子。如果没有这种旗子，在一大张纸上画上若干道等距的 平行线也可以。再要一盒火柴——什么火柴都成，只要短于平行线间的距离就可以。现在把旗子铺在桌子上，扔出一根火柴，让它落在旗子上，如下图 1。它可能完全落在一条带子里，也可能压在两条带子上。 这两种情况发生的机会各为多大呢?<br><img src="/images/about-math/pic-1.png" alt="图 1 "><br>初一看，这是求概率问题，因此无非就是讨论下两种情况下的可能性，然后给个比值就行了。直觉上看，一般的概率应该都是一个确定的数，或者说有理数。然而事实真的是这样吗？</p><p>仔细考虑一下，火柴落在条带上的情况， 可由火柴中心点到最近条带边界的距离以及火柴与条带走向所成 的角度来决定，如图 2。图中给出了三种基本类型。为了简便起见，把火柴长度与条带宽度取相同数值，就说都为 2 英寸吧。如果火柴中点离边界很近，角度又较大(如例 a)，火柴便与边界相交。 如果情况相反，或者角度小(如例 b)，或者距离大(如例 c)，火柴就全部落在一条带子里。说精确些，如果火柴的一半长度在竖直方向的投影大于从火柴中点到最近边界的距离，则火柴与边界相交(如 a)，反之则不相交(如 b 和 c)。这句话可用图 2 下半部的图形表示出来。横轴以弧度为单位表示火柴落下的角度，纵轴是火柴的半长在竖直方向上的投影长度，在三角学中，这个长度叫做给定角度的正弦。显然，当角度为零时，正弦值也为零，因为这时火柴呈水平方向。当角度为 ${π \over 2}$ 即直角时，火柴取直立位置，与其投影重合，正弦值就是 1。对于处于两者之间的角度，其正弦的值由大家所熟悉的正弦曲线给出。<br><img src="/images/about-math/pic-2.png" alt="图 2 "></p><p>有了这条曲线，要计算火柴与边界相交或不相交的两种机会 就很方便了。事实上，我们已经看到(再看图 2 上部的三个例 子 )， 火柴中点离边界的距离如果小于半根火柴的竖直投影，即小于此时的正弦值，火柴就会与边界相交。这时，代表这个距离和角 度的点在正弦曲线之下。与此相反，火柴完全落在一个条带内时， 相应的点在曲线之上。</p><p>按照计算概率的规则，相交机会与不相交机会的比值等于曲 线下的面积与曲线上的面积的比值。也就是说，两个事件的概率， 各等于自己的那一块面积除以整个矩形的面积。可以由数学上证明，图中正弦曲线下的面积恰好等于 1。而整个矩形的面积为 ${\pi \over 2}$$\times 1$= ${\pi \over 2}$。我们得出结论：<strong>火柴与边界相交的概率为 ${1 \over {π/2}}={2 \over π}$ </strong></p><p>最后，一个勤劳的意大利数学家，做了这件无聊的事，他扔掷了 3407 根火柴，数一数有 2169 根与边界相交。以这个真实数据代入布丰公式，π 就变成了 ${2 * 3407 \over 2169}$，即 3.1415929，与精确值比，一直到第七位才开始不同！</p><p>这个例子对概率定律的实用性无疑是一个极有趣的明证。一个概率实验，居然能和 π 撤上关系！一方面证明了概率理论是正确的，因为由概率推出的数据和事实相符，另一方面，如果我们的祖先知道还能这么玩，根本不用掌握什么高深的技巧，直接扔针或者扔火柴，扔个十天半月的，只要扔的次数足够多，即可精确的估算出 π 的大小！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文仅仅摘取了几个很小的关于数学的片段，让大家体会下数学的魅力和美妙。也许有些理论或定理，我们在小学都学过，有的证明，我们也都能一看就懂，这里面都包含着严密的逻辑和推理过程，任何一条公式，理论，绝不是某个人上帝附体，或者灵光一闪而提出的，都是一个不断探索和积累的过程。人类的这种推理和思考过程，使我们和一般的动物有着本质的区别。这种能动性，让我们了解世界，进而改变世界。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>《什么是数学》</li><li>《从一到无穷大》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 公式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMQ 的简单使用</title>
      <link href="//2018/03/16/start-rabbitmq.html"/>
      <url>//2018/03/16/start-rabbitmq.html</url>
      
        <content type="html"><![CDATA[<p>在高性能，高可用，解耦的系统中，消息队列 ( Message Queue) 组件是少不了的。现在市面是有各种流行的 MQ 框架，比如 kafka，rabbitmq，roketmq，zeromq等。各个公司为了适应自己业务的发展，有的会自己造轮子，而有的则在开源消息队里的基础上，做了进一步的改造和优化。本文使用 rabbitmq，作为消息队列的入门使用。<br><a id="more"></a></p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>使用 rabbitmq 之前，先说说什么是消息队列。我们为什么要用消息队列呢？可以用日常网购的场景来做对比。如我们在网上下了个单，我们不会坐着等商品到达。而商家发货后，也不会坐着等我们收到商品的消息。商家会把你的商品，发给快递公司，然后继续接收其他用户的订单。对于商家来说，他的工作已经做完了。而快递公司，则会把我们的商品准确发给我们。这样的方式，使商家和我们买家之间解耦，对于商家来说，他能处理更多的订单请求，而我们消费者，则可以在收到快递到达的通知时才去取。</p><h2 id="rabbitmq-中的几个概念"><a href="#rabbitmq-中的几个概念" class="headerlink" title="rabbitmq 中的几个概念"></a>rabbitmq 中的几个概念</h2><p>rabbitmq 也是类似的原理，在 rabbitmq 中，有几个重要的组件，<code>publisher</code>，即生产者，是产生消息的一方，类似于商家，<code>exchange</code>，交换器，生产者会把消息发往<code>exchange</code>，作用相当于快递公司，<code>queue</code>，队列，接收<code>exchange</code>发过来的消息，相当于运输快递的交通工具，<code>consumer</code>，消费者，消息的接收方，也就是我们买家。在这个里面可以看到，生成者并不是直接将消息投到队列中的，需要经过一个交换器，交换器负责把消息路由到某个或者多个队列。</p><p>另一个比较重要的概念就是交换器类型，可以这么理解，中通快递公司，只会把商品放到中通快递的运输车上传递，而不能放到其他公司的运输车上。各个快递公司，也都只能把商品放到各自公司的车上。rabbitmq 中的交换器做的也是类似的事，它定义了一些规则，根据规则，rabbitmq就会把消息投递到指定的队列。这些规则称为路由键。交换器有四种类型：<code>direct</code>, <code>topic</code>, <code>fanout</code>，<code>headers</code>，每种类型实现了不通的路由算法。</p><ul><li><code>direct</code>: 这种交换器比较简单，它的路由规则是一个完全匹配模式，当它绑定了A队列，那么以后这个交换器中的消息，都会投递到A队列中。</li><li><code>topic</code>: 这种交换器的路由规则，可以使来自不同源头的消息到达同一个队列。比如不同级别的日志消息(info-log, warn-log, error-log) 都投递到 log 队列。</li><li><code>fanout</code>: 这种交换器类似广播模式，它会把收到的信息，广播到绑定到它身上的所有队列中。</li><li><code>header</code>: 匹配 AMQP 消息的 header 而非路由键，不太实用，或者基本不使用。</li></ul><p>有了以上概念，我们就可以搞一些事了。</p><h2 id="rabbitmq-的安装"><a href="#rabbitmq-的安装" class="headerlink" title="rabbitmq 的安装"></a>rabbitmq 的安装</h2><p>首先是安装，在 CentOS 上安装 rabbitmq 非常简单，一行命令搞定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install rabbitmq-server</span><br></pre></td></tr></table></figure></p><p>安装完毕后，直接启动服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure></p><p>启动完毕，就可以使用<code>rabbitmqctl</code>命令，对 rabbitmq 进行一系列操作，如查看 rabbitmq 的状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>考虑下有这样一个应用：它允许用户上传图片，当用户上传图片后，可以获得一定的积分，同时用户的好友，可以收到收到通知。你可以把这样的功能写成一个流程<br>upload_img -&gt; add_user_point -&gt; notify_others -&gt; success<br>形如<br><img src="/images/rabbitmq/p1.png" alt="方式1"></p><p>但这样带来的坏处是，当需求变更，不得不直接修改你的业务逻辑。如 pm 认为上传原始图片太占带宽，让你在上传图片前，先做压缩处理。或者在后面，添加记录日志的操作。每次修改，都不得不修改原来的代码。最终变得不可维护。另一方面就是性能问题，当有大量用户上传图片时，你的系统可能就不堪承受，最终服务不可用。问题就出在，这样的设计是强耦合的，增加积分，通知好友这些操作，不应该依赖于上传图片。需要把上传图片、增加积分、通知好友当做三个独立的服务，然后用一个桥梁，把三者再结合起来，达到解耦的目的，如下图所示。<br><img src="/images/rabbitmq/p2.png" alt="方式2"><br>这样，首先可以把工作量拆分，一个人写上传图片服务，一个人写增加用户积分服务，当有其他新增服务时，简单的接入即可。另一方面，当你的某个服务压力过大时，粗暴的继续加机器部署服务即可解决。下面通过一个简单的例子，来看看如何使用 rabbitmq 来拆分完成上述上传图片的需求。</p><ol><li><p>首先写上传图片服务，注释已经说明了问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//命令行参数，模拟用户上传图片的请求</span></span><br><span class="line">$image_id = $argv[<span class="number">1</span>];</span><br><span class="line">$user_id = $argv[<span class="number">2</span>];</span><br><span class="line">$image_path = $argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接到rabbit</span></span><br><span class="line">$conn = <span class="keyword">new</span> AMQPConnection(HOST, PORT, USER, PASS, VHOST);</span><br><span class="line"><span class="comment">//指定一个信道</span></span><br><span class="line">$channel = $conn-&gt;channel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个名为 upload-pictures 的交换器，类型是 fanout 模式, 后面的参数请参考api</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'upload-pictures'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将用户请求组装成一个消息</span></span><br><span class="line">$metadata = json_encode(<span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'image_id'</span> =&gt; $image_id,</span><br><span class="line">        <span class="string">'user_id'</span> =&gt; $user_id,</span><br><span class="line">        <span class="string">'image_path'</span> =&gt; $image_path</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage($metadata,</span><br><span class="line">                <span class="keyword">array</span>(<span class="string">'content_type'</span> =&gt; <span class="string">'application/json'</span>,</span><br><span class="line">                        <span class="string">'delivery_mode'</span> =&gt; <span class="number">2</span>));</span><br><span class="line"><span class="comment">//投递消息到 upload-pictures 交换器</span></span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">'upload-pictures'</span>);</span><br><span class="line"></span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>增加用户积分的服务，注释已经说明了问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="comment">//获得rabbit连接和信道</span></span><br><span class="line">$conn = <span class="keyword">new</span> AMQPConnection(HOST, PORT, USER, PASS, VHOST);</span><br><span class="line">$channel = $conn-&gt;channel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟增加用户积分的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_points_to_user</span><span class="params">($user_id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> sprintf(<span class="string">"Adding points to user: %s\n"</span>, $user_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明交换器</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'upload-pictures'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//声明了一个 add-user-point 的队列</span></span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'add-user-point'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//绑定队列到交换器</span></span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'add-user-point'</span>, <span class="string">'upload-pictures'</span>);</span><br><span class="line"><span class="comment">//创建回调函数</span></span><br><span class="line">$consumer = <span class="function"><span class="keyword">function</span><span class="params">($msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($msg-&gt;body == <span class="string">'quit'</span>)&#123;</span><br><span class="line">        $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;</span><br><span class="line">            basic_cancel($msg-&gt;delivery_info[<span class="string">'consumer_tag'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $meta = json_decode($msg-&gt;body, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    add_points_to_user($meta[<span class="string">'user_id'</span>]);</span><br><span class="line"></span><br><span class="line">    $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;</span><br><span class="line">        basic_ack($msg-&gt;delivery_info[<span class="string">'delivery_tag'</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//准备消费者</span></span><br><span class="line">$channel-&gt;basic_consume($queue,</span><br><span class="line">    $consumer_tag,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    $consumer);</span><br><span class="line"><span class="comment">//等待消息到达</span></span><br><span class="line"><span class="keyword">while</span>(count($channel-&gt;callbacks)) &#123;</span><br><span class="line">    $channel-&gt;wait();</span><br><span class="line">&#125;</span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建通知朋友的服务，类比于增加用户积分</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$conn = <span class="keyword">new</span> AMQPConnection(HOST, PORT, USER, PASS, VHOST);</span><br><span class="line">$channel = $conn-&gt;channel();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notify_friend</span><span class="params">($user_id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> sprintf(<span class="string">"notified user's %s friend: %s\n"</span>,</span><br><span class="line">        $user_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'upload-pictures'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'notify-user'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'notify-user'</span>, <span class="string">'upload-pictures'</span>);</span><br><span class="line"></span><br><span class="line">$consumer = <span class="function"><span class="keyword">function</span><span class="params">($msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($msg-&gt;body == <span class="string">'quit'</span>)&#123;</span><br><span class="line">        $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;</span><br><span class="line">            basic_cancel($msg-&gt;delivery_info[<span class="string">'consumer_tag'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    $meta = json_decode($msg-&gt;body, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    notify_friend($meta[<span class="string">'user_id'</span>]);</span><br><span class="line">    $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;</span><br><span class="line">        basic_ack($msg-&gt;delivery_info[<span class="string">'delivery_tag'</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">$channel-&gt;basic_consume($queue,</span><br><span class="line">    $consumer_tag,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">false</span>,</span><br><span class="line">    $consumer);</span><br><span class="line"><span class="keyword">while</span>(count($channel-&gt;callbacks)) &#123;</span><br><span class="line">    $channel-&gt;wait();</span><br><span class="line">&#125;</span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>很明显，上述中，上传图片服务是生产者，增加用户积分，通知消息两个是消费者。当后续有更多的服务需要加入时，只需要依葫芦画瓢，继续添加到 rabbitmq 中消费即可。而假如某个服务负载较高，需要更多的计算能力，也不必修改代码，只需要启动更多的消费者进程即可，而 rabbitmq 会负责对消息进行分发。</p><h2 id="组建-rabbitmq-集群和镜像队列"><a href="#组建-rabbitmq-集群和镜像队列" class="headerlink" title="组建 rabbitmq 集群和镜像队列"></a>组建 rabbitmq 集群和镜像队列</h2><p>加入了 rabbitmq 的系统架构，系统的稳定性也同样依赖消息队列。如果消息系统挂了，整个系统也不可用，组建集群是解决方法之一。rabbitmq 组建集群也非常容易，假如有两台机器：srv01（192.168.1.10），srv02（192.168.1.11）。</p><ul><li>分别在两台机器上安装 rabbitmq 并成功启动</li><li><p>为了让两台机器的 rabbitmq 正常通信，拷贝 srv01 的 erlang cookie 到 srv02，一般在<code>/var/lib/rabbitmq/.erlang.cookie</code>，重启 srv02 上的 rabbitmq 进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service rabbitmq-server restart</span><br></pre></td></tr></table></figure></li><li><p>停止 srv02 上的 rabbitmq 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure></li><li><p>重设 srv02 上的元数据和状态为清空状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl reset</span><br></pre></td></tr></table></figure></li><li><p>将 srv02 节点加入到第一个节点，<strong>这里需要注意，@ 后面写的是节点的 hostname，但实际 rabbit 是通过 IP 和节点通信的，因此，需要将 hostname 和 IP 做映射，在 srv02 机器上的 /etc/hosts 文件中，追加 192.168.1.10 srv01。 如果直接在 @ 后面写 srv01 的 IP 是无效的</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl join_cluster rabbit@srv01</span><br></pre></td></tr></table></figure></li><li><p>重新启动 srv02 节点的 rabbit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li><li><p>查看 rabbitmq 集群状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li></ul><p>如果在 nodes 节点信息中，看到有 rabbit@srv01, rabbit@srv02 字样，说明两个节点的集群已经配置完毕。</p><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>有了 rabbitmq 集群后，消息系统就高可用了吗？并不是，rabbitmq 集群只是一种伪高可用，实际上，集群中的多个节点之间，只会同步元数据，比如 exchange 元数据，queue 元数据等，但并不会同步队列的内容，一般情况下，很少单纯的使用集群模式，而是用镜像队列。这种方式下，每个节点都保存有所有的队列，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 rabbitmq 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据。写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上，生产环境下，都会用镜像队列模式。</p><p>配置镜像队列也不困难，接着上面集群模式，执行一条命令即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy mirror_queue <span class="string">"^"</span> <span class="string">'&#123;"ha-mode":"all","ha-sync-mode":"automatic"&#125;'</span></span><br></pre></td></tr></table></figure></p><p>这是给 rabbitmq 增加了一条策略，其中，mirror_queue 是起的名字，可任意，<code>^</code>是匹配规则，表示对匹配这些规则的 queue 做操作，操作就是后面的字符串，字符串是 k-v 形式，详细含义，可以参考 rabbitmq <a href="https://www.rabbitmq.com/ha.html" target="_blank" rel="noopener">官方链接</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上的简单例子可以看出，使用消息队列，可以很方便的将系统解耦，使系统有良好的扩展性。rabbitmq 是一个高性能的消息队列组件，使用和搭建集群也是非常方便的。<br>本文完整的实例代码，可以在<a href="https://github.com/hbxjw119/learnbylearn/tree/master/rabbitmq/php/img-upload" target="_blank" rel="noopener">这里</a>找到。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>《RabbitMQ 实战》</li><li><a href="https://www.rabbitmq.com/ha.html" target="_blank" rel="noopener">https://www.rabbitmq.com/ha.html</a></li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSDN 的困境</title>
      <link href="//2018/01/22/about-csdn.html"/>
      <url>//2018/01/22/about-csdn.html</url>
      
        <content type="html"><![CDATA[<p>前两天在微博上，看到CSDN的创始人发了这样一条微博，内容如下<br><a id="more"></a></p><p><img src="/images/csdn/csdn1.png" alt="蒋涛博客"></p><p>在他的微博里，他把目前CSDN的现状和困境，都罗列了出来。看得触目惊心<br><img src="/images/csdn/csdn.png" alt="csdn的困境"></p><p>这些问题，可以说大公司基本多多少少都有，具体到我们个人开发者，也是需要深刻反思的，毕竟</p><blockquote><p>当雪崩发生时，没有一片雪花认为自己有责任</p></blockquote><p>这里，我不打算谈软件架构之道，因为我经验尚欠，也只是一个小螺丝钉，达不到高屋建瓴的视角，这里只是想说下我看这几年 CSDN 的兴衰，以及用 CSDN 给我带来的感受。</p><p>记得之前还在学校时，CSDN 还是程序员讨论技术和写博客的圣地，调试代码时，遇到问题，都习惯在 CSDN 上寻找答案，因为那上面代码清晰，高亮设计，而且感觉答案的质量也高，基本都解决了我学习 C/C++ 时的问题。各路技术大牛纷纷在 CSDN 写博客，我记得印象较深的有 <a href="http://my.csdn.net/v_JULY_v" target="_blank" rel="noopener">JULY</a>， <a href="http://blog.csdn.net/MoreWindows" target="_blank" rel="noopener">MoreWindows</a>， <a href="http://blog.csdn.net/hackbuteer1" target="_blank" rel="noopener">buteer1</a>, 当时找工作时，没少看这几个牛人的博客。</p><p>JULY 在 CSDN 上算是一位很知名的博主了，写的程序员面试题系列，阅读量破千万，帮助不少小白入了码农的坑，现在他在北京已经创业三年，开了公司，当了 CEO。</p><p>MoreWindows 和我一样，都是成电毕业，是我的学长，当时在计算机学院，在学校论坛上，也小有名气，毕业去了微软亚洲研究院，他在 CSDN 上写的排序算法系列，多线程系列堪称经典，找工作时没少看。现在时常感慨，都是一个学校毕业的，人与人的差别，咋就这么大捏~</p><p>另外一个 butter1，也是一个大牛，博客上各种算法题，编程题，代码写得详细规范，记得当时太原出差，在城中村，住出租屋，条件艰苦，异常孤独，经常大半夜里，用 ipad 看他写的博客，受益匪浅，于是毕业进了互联网，而他毕业去了谷歌。。。</p><p>随着移动互联网带来的变革，以及各种自媒体创业，segmentdfault、简书、公众号、知乎专栏等纷纷崛起，从流量、定位、以及用户体验上，现在 CSDN 上的博客质量，已经明显不如从前，那些大牛们的 CSDN 博客，也鲜有更新。从百度里搜一个程序问题，排名靠前的几个链接，虽然大概率都是 CSDN，然而得到的内容，要么是大同小异，要么是抄袭、转载成风，一个错误的，或者没有说明原理的答案，一传十，十传百，根本不 work。博客几经改版，而体验却是越来越差。写博客的作者，偏低龄化，感觉是在校学生偏多，没有技术沉淀，在写每一篇文章时，对问题本质的分析较少，没有严谨态度，格式、文字等随意发挥，看起来比较费劲。而反观github，简书等，作者明显要更耐心，书写更仔细，该格式化的格式化，该高亮的高亮，读者看着也赏心悦目。CSDN的定位和风格，在这些兴起的高逼格产品面前，显得有些力不从心。</p><p>而另一方面，随着github pages，code pages兴起，建站变得越来越容易，个人的文章博客，有更好的托管平台，和更好的自定义方式，也不必受第三方平台的格式约束。CSDN、博客园这类产品也进一步失去空间和用户。</p><p>感觉 CSDN，已经不是从前的 CSDN 了，再也找不到我想要的答案了。也许，CSDN 博客没有变，变的只是我自己吧</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csdn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 vps 和 shadowsocks 梯子</title>
      <link href="//2018/01/20/about-vps.html"/>
      <url>//2018/01/20/about-vps.html</url>
      
        <content type="html"><![CDATA[<p>近几年国内互联网“整风运动”愈演愈烈，各种翻墙服务都相继倒下，走丢的国外网站和服务也一个接一个，好在公司可以随意访问 Google，而回到家里，就没法用了，因此，为了科学上网，迫切需要有新的梯子，去看看外面的世界。俗话说，授人以鱼不如授人以渔，与其找梯子，不如自己建梯子。国外的 vps 给我们提供了一个理想的建梯子环境。本文使用亚马逊的 EC2 vps，使用著名的 shadowsocks 来自建一个梯子。<br><a id="more"></a></p><h2 id="申请亚马逊-EC2"><a href="#申请亚马逊-EC2" class="headerlink" title="申请亚马逊 EC2"></a>申请亚马逊 EC2</h2><p>之前用的是阿里云，但机房在国内，还是受到监管，没法搭建梯子，最近在亚马逊 <a href="https://amazonaws-china.com/cn/" target="_blank" rel="noopener">AWS</a> 上，开了一台云主机，新用户，免费使用1年，想着不用白不用。申请过程还是比较容易的，跟着步骤来，中间有两个地方可能稍微有点麻烦，一个是绑定信用卡，要准确填写信用卡的到期时间，不然验证会失败，然后就是在验证过程中，会给你打电话，让你按照电话提示，在手机上输入屏幕上的验证码，我接到电话时，电话里悄无声息，啥都没听到，不过还是把屏幕上的验证码输入了，然后就通过了，神奇。。。</p><p>申请成功后，就可以像阿里云那样使用了，需要注意的是，阿里云和亚马逊对于云主机的安全非常看重，因此有安全组的概念，防止用户的云主机被不法分子利用，沦为肉鸡。初始状态下，云主机除了 22 端口开放供 SSH 登录，其他端口都是不开的，当时在阿里云主机上 <a href="https://xujimmy.com/2017/12/01/https-blog.html">启用HTTPS</a> 服务时，就因为没开放指定端口，导致不成功。所以在亚马逊云的安全组配置中，我有了提防，然并卵，还是躺枪了。刚开始配置时，在安全组的页面上配置，死活没生效，后来看一篇文章，才知道，需要在实例面板，拖到最右边，有个安全组选择，只有这个安全组才是生效的，如下图，坑爹啊。。。根据选择的安全组配置下端口，比如下面要用的8388，保持，然后就OK了。在本地电脑上，尝试可否通过<code>telnet your_ip port</code>连到vps的指定端口。<br><img src="/images/vps/anquanzu.jpg" alt="安全组配置"></p><h2 id="使用-shadowsocks"><a href="#使用-shadowsocks" class="headerlink" title="使用 shadowsocks"></a>使用 shadowsocks</h2><p>vps 准备工作做好后，就可以用 shadowsocks 搭建梯子工具了。首先要明白 shadowsocks 的工作原理，简单的说，shadowsocks 分为客户端和服务端，客户端装在你的电脑或手机上，服务端装在 vps 上。shadowsocks 客户端会把你发出去的敏感的数据包，做一个加密，然后发到你国外的 vps 上，由于已经加密，墙不知道你发出去的是什么数据，也就没法封了，国外的 vps 装有 shadowsocks 服务端程序，它接收到你发的数据，解密，然后去请求指定网站，拿到响应，再加密，传给你的客户端，解密后，你就能看到想要的内容了。</p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>首先在 vps 上装服务端程序，有 Python 基础的话，很简单，先装好Python的<code>pip</code>包管理器，如果是 ubuntu，可以使用下面命令安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure></p><p>装好<code>pip</code>后，再来安装 shadowsocks，很简单，也一条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>没报错的话，说明安装成功，然后可以开始准备配置文件了，用任意编辑器，写一个名为 config.json 文件，文件内容如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,  </span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">8388</span>, </span><br><span class="line">    <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>, </span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,  </span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"password"</span>, </span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">600</span>,   </span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>, </span><br><span class="line">    <span class="attr">"fast_open"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>退出保存，然后就可以启动 shadowsocks 服务了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -c /path/to/config.json -d start</span><br></pre></td></tr></table></figure></p><p>其中，<code>-c</code> 参数后面接的是你的配置文件所在路径。启动完后，查看对应的进程是否存在<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep ssserver</span><br></pre></td></tr></table></figure></p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>服务端准备好后，再准备客户端，在 <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">github</a> 上下载对应的 shadowsocks 安装，win，mac，andriod都有，iOS在app store 下wingy+，8块钱，各平台配置大同小异，如在 mac 下，配置服务器如下图所示<br><img src="/images/vps/shadowsocks-client.jpg" alt="shadowsocks配置"></p><p>模式选择自动代理模式，配置好后，客户端的工作也基本做完了，但还别急着打开浏览器访问墙外的网站，因为浏览器出去的流量，还没有经过客户端的 shadowsocks 加密，需要下个chrome插件 : switchyOmega，填写代理规则，具体配置，可以<a href="https://glorystar.me/archives/chrome-use-switchyomega-autoproxy.html" target="_blank" rel="noopener">看这篇文章</a>，非常详细。打不开的朋友也没关系，我导出了一份配置，一键导入，非常方便，具体操作步骤：在下载完插件后，浏览器启用插件，然后点插件图标，进入设置菜单，在插件的设置页，选择导入导出子菜单，在在线恢复输入框中，输入我的备份地址：<a href="https://xujimmy.com/OmegaOptions.bak">https://xujimmy.com/OmegaOptions.bak</a> ,如下图<br><img src="/images/vps/switchomega.png" alt="恢复设置"><br>恢复完后，点击插件图标，选择自动切换模式，插件图标会变绿，完成以上步骤，应该就可以愉快科学上网了~</p><p>如果发现还是不行，就需要查原因，首先，确认 vps 上 ssserver 服务的端口是否可达，检查安全组，其次，确认请求是否到达 vps，检查 ssserver 访问日志，在 /var/log/shadowsocks.log，再然后，检查客户端配置。确认按上述方式配置正确。</p><h3 id="开启BBR，让网速更快"><a href="#开启BBR，让网速更快" class="headerlink" title="开启BBR，让网速更快"></a>开启BBR，让网速更快</h3><p>虽然上面可以正常上网，但速度还是让人捉急，我试过在 youtube 上看视频，卡成 ppt，下面开启 BBR，优化下网速，该方法适用范围：</p><ul><li>系统：CentOS 6+，Debian 7+，Ubuntu 12+</li><li>vps虚拟架构： KVM、Xen、VMware</li><li>内存：&gt;128M</li></ul><p>BBR是<a href="https://github.com/google/bbr" target="_blank" rel="noopener">Google开源的一个TCP网络拥塞控制算法</a>，其主要解决两个问题：</p><ol><li>充分利用宽带</li><li>降低网络延迟</li></ol><p>根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。这里不打算说该算法的原理，有兴趣的可以看知乎上这个<a href="https://www.zhihu.com/question/53559433" target="_blank" rel="noopener">回答</a>。这里主要记录下，怎么使用这个黑魔法。其实很简单，已经有大神给我们写了一键开启脚本，以root用户，运行命令如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure></p><p>这个命令先升级你的内核版本，然后开启BBR。运行完后，会提示重启机器，重启完后，登录，看看是否开启BBR，运行以下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>如果以上几个命令返回的结果里，都有bbr，则说明开启成功，再访问下youtube，看看网速是不是像施了魔法样，一点都不卡呢？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>自Google提出云计算以来，该领域已经得到长足发展，云计算，从一个概念，到现在各大厂商开始涉足，并出现丰富的产品线，让广大的用户，不用自己购买昂贵的物理主机服务器，通过按需付费的方式购买虚拟主机(vps)，即可快速使用，确实是一种重大创新。作为一个今年才开始使用云主机的码农来说，确实太晚了，目前从事的工作，也是和云计算相关。从使用云主机到现在，我已经深深喜欢上了这种产品，一度到处找便宜的 vps。目前国内比较著名，有口碑的就是阿里云和腾讯云。国外比较知名的 vps 厂商有vultr，bandwagon，linode，aws等。作为学计算机码农和学生，都建议尝试使用下 vps。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://teddysun.com/489.html" target="_blank" rel="noopener">https://teddysun.com/489.html</a></li><li><a href="https://glorystar.me/archives/Speed-up-shadowsocks.html" target="_blank" rel="noopener">https://glorystar.me/archives/Speed-up-shadowsocks.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
            <tag> shadowsocks </tag>
            
            <tag> bbr </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>本博客的一些插件和使用方法</title>
      <link href="//2018/01/06/blog-update.html"/>
      <url>//2018/01/06/blog-update.html</url>
      
        <content type="html"><![CDATA[<p>用hexo写博客已经有一段时间了，这里把本博客的一些觉得有意思的插件和优化整理出来，方便新手配置和学习。<br><a id="more"></a></p><p>本博客使用的hexo主题为<a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">maupassant</a>，符合宣传所说，<strong>大道至简</strong>的定位。在此基础上，我做了一些插件补充，主要有：</p><ul><li>本地搜索</li><li>文章字数统计，年度文章数量统计</li><li>leadcloud增加pv统计</li><li>文章版权</li></ul><p>下面分别介绍下，这几个插件的使用方法。</p><h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><p>本地搜索是主题自带的功能，如本博客右侧栏所示，输入关键词，即可在站内搜索博文信息。要使用此功能，首先需要在主题的<code>_config.yml</code>文件中，设置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self_search:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>然后，安装搜索插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p><p>这样，当你每次<code>hexo g</code>时，此插件都会在你博客的根目录，生成一个<code>search.xml</code>的文件，该插件就是根据此文件来做全文检索的。</p><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>如你所见，本博客的每篇文章，都有字数统计，以及阅读时长。也是通过插件方式实现，估计此插件作者应该是受简书启发而开发的。安装插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>安装好后，在主题的配置文件<code>_config.yml</code>中开启该功能<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>然后就可以在文章中使用了，使用方法是在主题的文章模板文件：<code>themes/maupassant/layout/_widget/post.pug</code>，在该文件适当位置，加入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if theme.wordcount == true</span><br><span class="line">    span= &apos; | &apos;</span><br><span class="line">    span</span><br><span class="line">      i.fa.fa-file-word-o</span><br><span class="line">    span.post-count=&apos; &apos; + wordcount(page.content) + &apos; 字&apos;</span><br><span class="line">    span= &apos; | &apos;</span><br><span class="line">    span</span><br><span class="line">      i.fa.fa-clock-o</span><br><span class="line">    span.post-count=&apos; 阅读约需 &apos; + min2read(page.content) + &apos; 分钟&apos;</span><br></pre></td></tr></table></figure></p><p>然后再部署时，就可以看到效果。此外，你还可以使用该插件的<code>totalcount</code>方法，来统计所有博文的总字数，比如：<code>totalcount(site, &#39;0,0&#39;)</code>。</p><h2 id="leadcloud-PV统计"><a href="#leadcloud-PV统计" class="headerlink" title="leadcloud PV统计"></a>leadcloud PV统计</h2><p>对于统计功能，其实可以使用更轻量级的工具，不蒜子。我抱着不折腾就手痒的心态，自己搞的，用的是<a href="https://leancloud.cn/" target="_blank" rel="noopener">leadcloud</a>。leadcloud的存储产品是一个云存储的解决方案，相比于自己维护一个数据库，用云存储的好处就是省心，但缺点也显而易见：数据的安全与隐私性。不过对于博客这样的统计功能，用云存储还是比较合适，只是希望厂家不要跑路。。。<br>要在博客中开启统计功能，需要以下几个步骤：</p><ol><li>在leadcloud官网申请一个账号，并建立一个新应用，主要是存储产品，然后新建一个叫<code>total_pv</code>的class，然后在此class下，添加一行数据，这个数据至少有一个<code>pv</code>的number字段。这里假设你已经看过官方的sdk，所有工作已经做好。</li><li><p>在应用的设置页面，拿到APP ID 和APP KEY，以及上面添加的数据的objectID，填入到主题的<code>_config.yml</code>文件中</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## visitor-count</span></span><br><span class="line"><span class="attr">visitor:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  APP_ID:</span> <span class="string">your</span> <span class="string">APP</span> <span class="string">ID</span></span><br><span class="line"><span class="attr">  APP_KEY:</span> <span class="string">your</span> <span class="string">APP</span> <span class="string">KEY</span></span><br><span class="line"><span class="attr">  OBJ_ID:</span> <span class="string">objectID</span></span><br></pre></td></tr></table></figure></li><li><p>在模板文件<code>themes/maupassant/layout/_partial/footer.pug</code>最后，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">  i.fa.fa-eye</span><br><span class="line">    span.visitors</span><br></pre></td></tr></table></figure></li><li><p>在模板文件<code>themes/maupassant/layout/_partial/after_footer.pug</code>最后，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if theme.visitor.enable == true</span><br><span class="line">    - var app_id=theme.visitor.APP_ID</span><br><span class="line">    - var app_key=theme.visitor.APP_KEY</span><br><span class="line">    - var obj_id=theme.visitor.OBJ_ID</span><br><span class="line">    script(type=&apos;text/javascript&apos;, src=&apos;//cdn.bootcss.com/jquery/3.2.1/jquery.min.js&apos;)</span><br><span class="line">    script(type=&apos;text/javascript&apos;, src=&apos;//cdn1.lncld.net/static/js/3.4.2/av-min.js&apos;)</span><br><span class="line">    script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/leandcnt.js&apos; + &apos;?v=&apos; + theme.version)</span><br><span class="line">    script.</span><br><span class="line">       visitorCount(&apos;#&#123;app_id&#125;&apos;, &apos;#&#123;app_key&#125;&apos;, &apos;#&#123;obj_id&#125;&apos;)</span><br></pre></td></tr></table></figure></li></ol><p>这里要注意的是，如果你的hexo模板渲染引擎无法解析<code>&#39;#{app_id}&#39;</code>变量，就去掉引号和<code>#</code>。我的机器上因为无法解析<code>pug</code>引擎中的变量，因此我换成了<code>jade</code>的方式。关于<code>pug</code>和<code>jade</code>，你只要知道这是两种模板渲染引擎即可，使用方式基本相似。文末我会说为何需要换。</p><ol start="5"><li>在<code>themes/maupassant/source/js</code>目录，添加<code>leadcnt.js</code>文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visitorCount = <span class="function"><span class="keyword">function</span>(<span class="params">app_id, app_key, obj_id</span>) </span>&#123;</span><br><span class="line">    AV.init(&#123;<span class="attr">appId</span>:app_id, <span class="attr">appKey</span>: app_key&#125;);</span><br><span class="line">    <span class="keyword">var</span> cnt=AV.Object.createWithoutData(<span class="string">'total_pv'</span>,obj_id);</span><br><span class="line">    cnt.increment(<span class="string">'pv'</span>,<span class="number">1</span>);</span><br><span class="line">    cnt.save();</span><br><span class="line">    cnt.fetch().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pv = cnt.get(<span class="string">'pv'</span>);</span><br><span class="line">        $(<span class="string">'.visitors'</span>).html(<span class="string">' | '</span> + pv);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;<span class="built_in">console</span>.log(error);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>添加完上述步骤，应该就可以在博客的footer部位，看到有pv数据了，每刷新一次，pv+1。</p><h2 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h2><p>为了显得专(zhuang)业(bi)，我给文章末尾添加了版权说明。使用方法如下：</p><ol><li><p>在主题配置文件<code>_config.yml</code>中开启</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copyright:</span> </span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  author:</span> <span class="string">author_name</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>themes/maupassant/layout/_widget/</code>目录下，添加<code>article_copyright.pug</code>模板文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div.article-footer-copyright</span><br><span class="line">  p= &apos;本文由 &apos; + theme.copyright.author + &apos; 发表，采用&apos;</span><br><span class="line">    a(href=&apos;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh&apos;) 署名-非商业性使用</span><br><span class="line">-禁止演绎4.0</span><br><span class="line">    | 进行许可</span><br><span class="line">  p=&apos;非商业转载请注明作者及出处，商业转载请联系作者本人&apos;</span><br><span class="line">  p=&apos;本文标题: &apos;+ page.title</span><br><span class="line">  p=&apos;本文链接: &apos;</span><br><span class="line">    a(href=url)= url</span><br></pre></td></tr></table></figure></li><li><p>在上级目录，<code>post.pug</code>文件中，在适当位置，引入<code>article_copyright.pug</code>文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">if</span> <span class="string">theme.copyright.enable</span> <span class="string">==</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">include</span> <span class="string">_widget/article_copyright.pug</span></span><br></pre></td></tr></table></figure></li><li><p>最后，根据审美，在<code>themes/maupassant/source/style.css</code>文件中，给版权信息添加css样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* article-footer-copyright */</span></span><br><span class="line"><span class="selector-class">.article-footer-copyright</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.8em</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f8f8f8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article-footer-copyright</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#01579f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本博客的配置，都放在的<a href="https://github.com/hbxjw119/blog" target="_blank" rel="noopener">github</a>上，只要你安装了hexo，以及必要的插件，都可以运行。综合来讲，hexo的自由配置度还是很高的。由于hexo最后会根据模板引擎，生成html静态文件，因此，基本不用担心插件过多而给性能带来损耗。对普通用户来讲，自由配置的基本门槛，就是了解一点模板引擎的知识。本博客的主题引擎，最开始是采用<code>jade</code>，由于商标问题，<code>jade</code>模板在去年已经切换为<code>pug</code>，因此maupassant主题的维护者也进行了更新，但变化基本不大，用户需要做的，就是安装<code>pug</code>模板引擎，然后将模板文件后缀改为<code>pug</code>。模板中变量的使用方式，也需要做细微调整，比如<code>#{variable}</code>，现在直接用<code>variable</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> maupassant </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用微信公众号记账</title>
      <link href="//2017/12/29/weixin-account.html"/>
      <url>//2017/12/29/weixin-account.html</url>
      
        <content type="html"><![CDATA[<p>之前申请了个微信公众号，完成了一些小功能后，就一直没怎么玩了，由于今年下半年开始，和女票住一起了，开销骤增，于是决定开始记录下每田的开支情况，统计我们的消费习惯。<br><a id="more"></a></p><h2 id="选择一个记账工具"><a href="#选择一个记账工具" class="headerlink" title="选择一个记账工具"></a>选择一个记账工具</h2><p>其实在刚开始工作那会儿，也记过一段时间的帐，当时的做法是直接在一个纸质日历上，用笔写下当天的花销。到月底，再统计各类别和总的开销。这种方式可以说是非常原始了，至少有以下几个问题：</p><ul><li>首先不美观，一本制作精良的台历，用笔在上面写写画画的，美感顿无。</li><li>统计困难，月底还要一个一个用计算器算，非常麻烦。</li><li>记账体验不好，虽说我也算是爱洁人士，但有时要记账时，笔又不知道跑哪去了。于是当天就没法记。</li></ul><p>由于以上几个问题，我没记几个月就放弃了这个很美好的习惯，然后，就没有然后了。。。</p><p>现在既然记账的事又重新提上日程，所以当女票郑重的在一个纸质笔记本上记下第一笔帐时，我就觉得这样不靠谱，开始寻找其他记账方式。首先想到的是用记账app，说到这种记账方式，可以选择的范围就很多了，各家各户，xxx记，xxx帐啥的，琳琅满目，简直逼死困难选择户，虽说各大厂家都在吹嘘自家的产品如何强大如何贴心，但对于我来说，只需要一个核心功能：<strong>记账 + 统计</strong>，所以那些自带理财、新闻、信息流，各种看似全，然并卵的app，没用几分钟就卸载了。后来又看到有部分记账的微信小程序，使用了下，也还行，符合用完即走的理念，但对于这种小程序，有的不是界面太丑，就是没法满足分类统计。其实还有一个比较重要的原因，那就是不知道哪天万一开发者跑路，数据全没，那就坑爹了。后来找到一个腾讯系的记账工具，可以直接在公众号里完成记账。受此启发，我也在自己的公众号上做了一个类似的功能。</p><h2 id="使用公众号来记账"><a href="#使用公众号来记账" class="headerlink" title="使用公众号来记账"></a>使用公众号来记账</h2><p>我记账的思路很简单，比如今天吃饭，花了10块，那么我直接给公众号发送消息：吃饭10，即完成记账，公众号返回成功消息，并分类为餐饮；发送消息：地铁4，完成记账，返回消息，并分类为交通。要统计的话，直接点击公众号返回的消息，即可查看当月消费，以及各个分类的具体消费占比。</p><p>要完成这些功能，基本可以归结为以下几个问题：</p><ol><li>用户系统，即每个人都有自己的账单，不同用户的账单是不同的</li><li>理解用户的输入，比如输入吃饭22，要能区分这条账单是属于餐饮，而不是交通；对于不能理解的分类，不能记录，并要返回提示消息</li><li>统计月份消费总额和各分类消费占比</li></ol><p>对于第一个问题，很简单，用户给公众号发消息时，公众号后台可以获得该用户的一个 id，这个 id 是由微信生成，具有唯一性。公众号就是根据这个id，来给用户回复消息的。</p><p>第二个问题看起来比较复杂，这涉及到一个语义理解和分类的问题，用官方话说，属于自然语言处理范畴。对于记账这个简单功能，其实可以简化，再粗暴点，直接用枚举。对于我这个弱鸡，当然怎么简单怎么来，我选择先用枚举。。。</p><p>第三个问题，也简单，直接从数据库中查该用户的数据，返回，前端用绘图工具画个折线图、饼图完事。对于这个问题，在最开始，我想的是用户输入“统计”，微信返回当月消费总额的文本消息，这样虽然简单，但不直观，也不简洁，有输入成本，因此改为：当用户每记录一笔账时，返回一条图文类型的消息，当然没有图，当点击时，直接跳转到图形统计页面。正好我有个云服务器和公网域名，可以直接写页面。</p><p>有了思路，实现起来也不复杂，三下两下就做完了，这里就不上代码了，效果如下图：<br><img src="/images/wx-account-1.png" alt="记账效果"><br><img src="/images/wx-account-2.png" alt="账单统计"></p><p>代码放在了 <a href="https://github.com/hbxjw119/weixin" target="_blank" rel="noopener">github</a> 上，有兴趣的朋友也可以关注公众号体验下<br><img src="/images/wx-gzh.jpg" alt="公众号"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先不用说，统计界面丑我承认，但基本的功能还是满足的，后面应该会加入账单的详情列表。现在只有综合统计，看不到每天的消费记录。第二个就是分类不智能，输入吃饭、地铁、打车、房租等还能分分类，如果输入唱歌、大保健等就扑街了。毕竟只是枚举分类。。。另外就是后台的数据存储，设计初期，建了三张表，一个用户表、一个消费分类表，一个账单表。其实在用户不多、且访问量不大时，一张账单表就可以。如果记录多，用户多，分类也多，就得考虑分表了。</p><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>开发过程中，遇到一个手残操作事故：在mv一个文件时，本意时想做个备份，结果按tab键，直接mv成一个已经存在的文件，于是这个文件很安静的就被覆盖了。。。覆盖那一刻，简直一万头艹泥马飞过。查了下，没有办法恢复，老老实实重写吧。然后把mv、cp等命令，果断做了个alias，这样再如果出现覆盖等情况，就会出现是否确认操作的提示了。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公众号 </tag>
            
            <tag> 记账 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 monitor 命令查看 redis 请求日志</title>
      <link href="//2017/12/13/redis-request-log.html"/>
      <url>//2017/12/13/redis-request-log.html</url>
      
        <content type="html"><![CDATA[<p>redis 是一个高性能、使用方便的非关系型数据库，我们在使用 redis 时，基本只需要关注存数据，取数据的功能，即 set，get，非常适合用作缓存服务器，降低后端数据库压力。有时，想确认下数据是否是从 redis 里读的，以及 redis 是怎么取得数据，这时就可以使用 monitor 功能了。<br><a id="more"></a></p><p>一个典型的功能场景：前台用户请求一条数据，后端拿到用户 id 后，在 redis 缓存中查找该用户数据，没有找到，于是从 db 中拿，找到后，返回给前台，并在 redis 里存放该用户的数据，下次有请求后，就可以直接从 redis 里拿，返回给前台，怎么确认数据是从 redis 里取的？当然，如果数据量大，查询时又没索引，从数据库里取，和从 redis 里取的时间消耗是不一样的。从时间消耗上，就基本可以判断数据是从哪里取的。但如果数据量不大，无法从时间消耗上判断，就需要查看 redis 的请求日志，要注意的是，<strong>单纯从 redis.conf 中配置 logfile，loglevel 选项，是看不到 redis 请求和操作日志的</strong>，打印的都是些无关紧要的信息，这时可以用 monitor 命令来完成。</p><p>使用方法：<br>登录 redis-cli 命令行，输入<code>monitor</code>，即可进入到 redis 监控模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; monitor</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>随后即可看到，当有请求时，redis 具体都做了什么，我们另外打开一个 redis-cli，随便插入一条数据，比如<code>set &quot;hello&quot; &quot;world&quot;</code>，monitor 监控到<br><img src="/images/redis-monitor.png" alt="redis-monitor"></p><p>再模拟下上面的那个用户请求数据的功能场景：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_info</span><span class="params">(uuid)</span>:</span></span><br><span class="line">    <span class="comment">#如果redis中存在该用户的信息，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> REDIS.exists(uuid):  </span><br><span class="line">        <span class="keyword">return</span> REDIS.get(uuid)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#否则从mysql中取，并在redis中设置该信息</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        info = mysql_op.query(uuid)</span><br><span class="line">        <span class="keyword">assert</span> info <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">        REDIS.set(uuid,info,ex=<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception,e:</span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line">    <span class="keyword">return</span> info</span><br></pre></td></tr></table></figure></p><p>首次运行后，对应到 redis 的监控如下，可以看到，redis 里没有找到，然后从 mysql 中查找，并做了 set 操作将信息存起来，再次运行后，发现 redis 里存在，因此直接从 redis 里 get 数据。<br><img src="/images/redis-request-log.png" alt="redis请求日志"><br>可见，monitor 命令可以让我们清楚的看到 redis 是怎么处理每个请求的，这对于调试阶段非常方便。</p><p>当然，为了演示，上面只是一个简单的例子，并没有考虑连接性能问题，实际上，使用 monitor 是会降低 redis 的性能的，适合开发调试使用，线上环境应该禁止使用 monitor 命令。上述例子也没有考虑数据更新，比如用户是做一个更新或者删除操作，则相应的也要把 redis 里的信息更新或者直接使缓存失效。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monitor </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTPS 的握手过程</title>
      <link href="//2017/12/11/https-handshakes.html"/>
      <url>//2017/12/11/https-handshakes.html</url>
      
        <content type="html"><![CDATA[<p>在之前 <a href="https://xujimmy.com/2017/12/01/https-blog.html">给博客启用 HTTPS</a> 的博文中，我们知道了怎么给自己的博客开启 HTTPS，本篇简要介绍下，HTTPS 连接与 HTTP 连接的不同。<br><a id="more"></a></p><p>首先看下 HTTPS 握手的流程，归纳起来，有以下几个步骤：</p><ol><li>浏览器将自己支持的一套加密规则发给服务器</li><li>服务器从中选出一组加密算法和 HASH 算法，将自己的身份信息，以证书的形式发回给浏览器</li><li>浏览器获得证书后，要做以下工作<ul><li>校验证书的合法性，如果证书受信任，会在浏览器地址栏显示一个绿色的锁，否则给出证书不受信提示</li><li>如果证书受信，或者接受了不受信的证书，浏览器会生成一串随机数密码，并用证书中提供的公钥加密</li><li>使用约定的 HASH 算法计算握手消息，并使用生成的随机数对消息加密，然后将之前生成的所有信息发给服务器</li></ul></li><li>服务器接收到浏览器发来的数据，要做以下工作<ul><li>使用自己的私钥将信息解密，取出密码，使用密码解密浏览器发出的握手消息，并验证 HASH 是否与浏览器发来的一致</li><li>使用密码加密一段握手消息，发送给浏览器</li></ul></li><li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密</li></ol><p>画成时序图如下：<br><img src="/images/https-handshakes.png" alt="HTTPS握手过程"></p><p>综合本篇和之前的那篇，可以总结出 HTTPS 和 HTTP 的区别：</p><ul><li>HTTPS 协议需要到 CA 申请证书</li><li>监听端口不同，HTTP 监听 80 端口， HTTPS 监听 443 端口</li><li>HTTP 中，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输，比 HTTP 更安全</li><li>建立 HTTPS 需要客户端和服务器交换公钥，然后每次传输都需要加密，在性能上，HTTPS 要比 HTTP 差</li></ul><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li><a href="https://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html" target="_blank" rel="noopener">https://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给博客启用 HTTPS</title>
      <link href="//2017/12/01/https-blog.html"/>
      <url>//2017/12/01/https-blog.html</url>
      
        <content type="html"><![CDATA[<p>在几个月前，当博客放到阿里云时，就想尝试下开启 HTTPS，在尝试之前，我读了几篇启用 HTTPS 的经验文章，发现现在有了很方便的工具：<a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">acme.sh</a>。基本不用你做太多额外操作，即可开启 HTTPS。<br><a id="more"></a></p><p>在我严格按照 acme.sh 项目的<a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">wiki</a>操作完成后，发现始终无法使用 HTTPS 访问我的博客，当时实在百思不得其解呀。奈何身边又没有玩 HTTPS的同事，遂放弃了。后来过了几个月，我突然想起，会不会是端口没打开？于是登录阿里云，在安全组里，开启了443端口，再配置一遍 ssl，重启 nginx，访问。duang，终于出现了绿色小锁标志。看来就是这个原因了！困扰我这么久。</p><p><strong>所以如果你的 blog 用的是阿里云，或者是其他云厂商，在开启 HTTPS 时，请留意下，443 端口是否开启，以及应该注意是否有安全组，要使用指定端口，必须得在安全组中配置。</strong></p><p>另外一个可能需要注意的地方是，在用 acme.sh 安装证书步骤中，有一个自动更新证书的命令，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --reloadcmd <span class="string">"service nginx force-reload"</span></span><br></pre></td></tr></table></figure></p><p>如果提示force-reload命令不存在，那么需要更新下 nginx 的操作脚本。或者直接把<code>force-reload</code>换为<code>restart</code>，效果是一样的。</p><p>这里贴上我的 nginx 中与 HTTPS 有关的配置<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> xujimmy.com www.xujimmy.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> HTTPS://xujimmy.com<span class="variable">$request_uri</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2 fastopen=<span class="number">3</span> reuseport;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> xujimmy.com www.xujimmy.com;</span><br><span class="line">    <span class="attribute">root</span> /home/jimmy/git_project/blog/public;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.shtml index.php;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains; preload"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中间证书 + 根证书</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /usr/local/nginx/ssl/fullchain.cer;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 CSR 文件时用的秘钥</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /usr/local/nginx/ssl/xujimmy.key;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># openssl dhparam -out dhparams.pem 2048</span></span><br><span class="line"><span class="comment"># 如果没有下面这个DHE参数，ssl评分不会到A+，证书生成过程较长</span></span><br><span class="line">    <span class="attribute">ssl_dhparam</span> /usr/local/nginx/ssl/dhparam.pem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">50m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># RSA + ECDSA 双证书</span></span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 其他配置</span></span><br></pre></td></tr></table></figure></p><p>简单解释下配置中的几个选项</p><h3 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h3><p>即配置中的<code>Strict-Transport-Security</code>( HTTP 严格传输安全，简称 HSTS )，在访问网站时，用户很少直接在地址栏输入<code>https://</code>，总是通过点击链接，或者 3xx 重定向，从 HTTP 页面进入 HTTPS 页面。攻击者完全可以在用户发出 HTTP 请求时，劫持并篡改该请求。另一种情况是恶意网站使用自签名证书，冒充另一个网站，这时浏览器会给出警告，但是许多用户会忽略警告继续访问。</p><p>HSTS 的作用，就是强制浏览器只能发出 HTTPS 请求，并阻止用户接受不安全的证书。所以加上这段头信息，有以下两个作用：</p><ol><li>在接下来的一年(即31536000秒)中，浏览器只要向<code>xujimmy.com</code>或者其子域名发送 HTTP 请求时，必须采用 HTTPS 来发起连接，用户点击超链接或者直接在地址了输入<code>http://xujimmy.com</code>，浏览器将自动在本地将 HTTP 转写为 HTTPS，然后向<code>https://xujimmy.com</code>发送请求。</li><li>在接下来的一年中，如果<code>xujimmy.com</code>服务器发送的证书无效，用户不能忽略浏览器警告，将无法继续访问该网站。</li></ol><h3 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h3><p>即配置中以 ssl 开头的选项，是启用 HTTPS 后，服务器需要配置的，这样才能发挥 HTTPS 最大价值。</p><p>关于<code>ssl_dhparam</code>，可以参考这篇<a href="https://weakdh.org/sysadmin.html" target="_blank" rel="noopener">文章</a>。</p><p>将<code>ssl_prefer_server_ciphers</code>配置为 on，可以确保在 TLSv1 握手时，使用服务端的配置项，以增强安全性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果已经用 acme.sh 工具成功生成证书，并安装到指定位置，那么重启 nginx，访问你的博客，即可看到，页面自动跳转到 HTTPS，well done！</p><p>最后，你可以在<a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">这里</a>测试下你的博客的 ssl 评级。填写你的博客地址，过一会儿就会出结果。经过一番折腾，我的评级为A+，如果你的配置我和一样，也应该是A+。</p><p>需要注意的是，如果博客里有采用 HTTP 协议访问的静态资源，需要统一换到 HTTPS。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> acme </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的书单</title>
      <link href="//2017/11/25/books.html"/>
      <url>//2017/11/25/books.html</url>
      
        <content type="html"><![CDATA[<p>小时候的我就特别喜欢看书，不过那时都是课外儿童读物，也包括一些科技方面的书，当时班上流行读书文化，我们有自己的圈子，常常是每人买一本书，然后交换着看，交流心得。记得小时候最喜欢的是郑渊洁的童话书，第一次看鲁西西传时，惊为神书，怎么会有这么引人入胜的故事啊，废寝忘食的看。现在想想，非常怀恋，那些儿时的书友们，你们现在还好吗？<br><a id="more"></a></p><p>这里就不聊儿时看的书了，上学时代，我们有大把的时间可以看书，上课，自习，回家，放假等。工作后，读书的时间就少了很多，没有了在学校时读书的那种氛围。也没有了以前那些出高质量书籍的作者，现在成了全民写书的时代，是个网红，大V，都跟风出书，但写的内容质量又参差不齐，然后让一些狂热的粉丝为这些口水书买单。看过之后，留下不了什么印象，最后用来垫桌子。好的书，是可以让人反复阅读，反复揣摩的。每读一遍，都让人有新的体会。这里列点我读过的比较好的书，或者正在读，准备读的书。</p><p>计算机</p><ul><li>《c++ primer》这本书是当时找工作时读的，对C++的来龙去脉讲的一清二楚，找工作必备</li><li>《STL源码剖析》另一本非常经典的书籍，源码面前，毫无秘密</li><li>《编程之美》选取的例子来源于生活，很接地气，面试找工作必备</li><li>《redis设计与实现》要了解redis内部细节，这本书非常好</li><li>《redis实战》另一本很好的关于redis的书</li><li>《高性能MySQL》MySQL是互联网企业使用最广泛的数据库，后端码农应该要了解的，讲得很完整，书有点难，也许是我水平不够吧</li><li>《现代PHP》一本很薄的书，并不深入PHP的实现，而是讲了一些PHP开发中的最佳实践</li><li>《PHP与MySQL》一本很基础的书，上手PHP可以看，很有好处</li><li>《JavaScript权威指南》学习js很好的一本书，很全，也很好读</li><li>《深入理解nginx+模块开发与架构解析》讲解nginx服务器最经典教材之一</li><li>《算法导论》剖析了计算机中经典的一些算法，以及复杂度推导，有一定难度，找工作必备</li><li>《现代操作系统》很厚，关于操作系统比较经典的一本书</li><li>《rabbitMQ实战》看的第一本消息队列的书，适合消息队列入门者</li><li>《ZooKeeper 分布式过程协同技术详解》分布式系统中的很重要的一个组件，写的应该不错，但中文翻译实在不敢恭维</li><li>《Java 核心技术》java 的经典之作，比较好读，和Think in java 齐名。分上下两卷，比较厚，已经出到第10版，建议看最新版</li><li>《Java 并发编程实战》Java进阶必然少不了并发，看这本书就够了，有一定深度和难度，一上来就看，会撕书的，进阶时看</li><li>《深入理解JVM虚拟机》难得的一本国人写的好书，对理解Java底层技术和调优很有帮助，强烈建议看</li><li>《Docker——容器与容器云》浙大出版，同样是难得的国产良心之作，容器技术必看的一本书</li><li>《Spring 实战》学习 Spring 框架的一本好书，也是程序员网红耗子叔鼎力推荐的，建议读</li></ul><p>科技读物</p><ul><li>《从一到无穷大》不得不提这本科普读物，此书的内容涵盖极广，数学、物理、天文、生物等，语言精练，高中理科生都可以读。</li><li>《数学之美》非常好看的一本书，很合我的胃口，将数学中的原理和计算机中的应用结合起来</li><li>《浪潮之巅》讲了当今科技史上，最强大几个公司的新陈代谢，并有作者自己的见解</li><li>《大数据时代》学习大数据的第一本科普读物</li><li>《腾讯传》</li><li>《上帝掷骰子吗》关于物理和量子论的史话读物，从<strong>光的本质</strong>这个古老的问题入手，经过几百年的探索，最终孕育出了量子论。语言精练，就算物理小白也可以看</li><li>《什么是数学》一本古老的关于数学理论的书，看着高深，实际很多都是中学时代所学的理论。</li></ul><p>历史</p><ul><li>《人类简史》角度独特，从动物进化，分析了人类社会发展的几次革命，以及给社会带来的巨大变化和影响</li><li>《激荡三十年》改革开放，给中国社会，经济带来的巨变，读起来荡气回肠</li><li>《沸腾十五年》</li></ul><p>小说</p><ul><li>《围城》读完后，给我的感受就是，诙谐的文笔，超越了那个封闭，物质匮乏的年代</li><li>《活着》很薄的一本书，一口气读完，人生的苦难再多，只要活着，都会过去</li><li>《黄金时代》对现实社会的思考，摆脱俗套</li><li>《追风筝的人》友情与救赎</li><li>《平凡的世界》朴实的文字，但对现在纸醉金迷，金钱至上的价值观是一次洗涤</li><li>《人生》人，一定要明白我们到底需要什么</li><li>《枪炮，病菌与钢铁》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 命令之--find</title>
      <link href="//2017/11/19/linux-find.html"/>
      <url>//2017/11/19/linux-find.html</url>
      
        <content type="html"><![CDATA[<p><code>find</code>命令也是 linux 环境下使用频繁、功能强大的查找命令，基本每天的工作都会用到它，这里对<code>find</code>命令做个总结，作为备忘<br><a id="more"></a></p><p>首先看下<code>find</code>命令的基本结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find path -option [ -print ] [-exec -ok command] &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>其中<code>path</code>就是要查找的路径，如<code>~</code>表示在自己个人目录查找，<code>.</code>表示在当前目录查找，而且查找是递归查找的。</p><p><code>option</code>是比较有用的一个参数，指定了查找的方式，方式可以多种多样，如按命名，按创建时间，按大小，按类型等。</p><p><code>-print</code> 表示将匹配到的文件输出</p><p><code>-exec</code> 表示对匹配到的文件，执行该参数后面的shell命令。相应的，后面就需要跟上<code>{} \;</code>，注意<code>{}</code>和<code>;</code>之间有空格。</p><p><code>-ok</code> 和<code>-exec</code>作用相同，只是会让用户决定是否执行</p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在家目录中查找.log结尾的文件</span></span><br><span class="line">find ~ -name <span class="string">"*.log"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找5天前的log文件，并显示</span></span><br><span class="line">find ~ -mtime +5 -name <span class="string">"*.log"</span> -<span class="built_in">exec</span> ls -l &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找3天内修改过的log文件，并显示</span></span><br><span class="line">find ~ -mtime -3 -name <span class="string">"*.log"</span> -<span class="built_in">exec</span> ls -l &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找1天内被访问过的文件</span></span><br><span class="line">find ~ -atime -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找log目录下，更改时间在7天前的文件，并删除</span></span><br><span class="line">find <span class="built_in">log</span>/ -<span class="built_in">type</span> f -mtime -7 -<span class="built_in">exec</span> rm -f &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>注意<code>find</code>的时间类型，有三种，分别是<code>mtime</code>,即modified time，当对文件进行写入操作时，会改变，它跟踪的是文件中数据的改变；<code>atime</code>,即access time, 当对文件读取或被执行时，会改变；<code>ctime</code>,即change time，当对文件写入、更改所有者、权限、链接设置时，会改变。我们常常使用的<code>ls -l</code>，看的都是<code>mtime</code>，要看<code>atime</code>,<code>ctime</code>，可以分别使用<code>ls -lu</code>,<code>ls -lc</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找大于512k的文件</span></span><br><span class="line">find ~ -size +512k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找大于1M的文件</span></span><br><span class="line">find ~ -size +1M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找大于1G的文件，并删除</span></span><br><span class="line">find ~ -size +1G -<span class="built_in">type</span> -f -<span class="built_in">exec</span> rm -f &#123;&#125; \;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找属于 www 用户的文件</span></span><br><span class="line">find /etc -user www</span><br></pre></td></tr></table></figure><p>以上就是<code>find</code>命令的一些基本使用方法。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go语言中的数组(array)和切片(slice)</title>
      <link href="//2017/11/15/go-arr-slice.html"/>
      <url>//2017/11/15/go-arr-slice.html</url>
      
        <content type="html"><![CDATA[<p>刚开始学习go，里面有两个类型，常常容易让人弄混：array和slice，这里对这两个类型做个总结<br><a id="more"></a></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>数组的声明，语法格式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr_name [size] arr_type</span><br></pre></td></tr></table></figure></p><p>如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age [<span class="number">10</span>] <span class="keyword">int</span></span><br></pre></td></tr></table></figure></p><p>而切片的声明，不需要说明长度：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sli_name []<span class="keyword">type</span></span><br></pre></td></tr></table></figure></p><blockquote><p>slice和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>数组初始化：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">20</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">29</span>,<span class="number">23</span>&#125;</span><br></pre></td></tr></table></figure></p><p>切片初始化，一般有两种：<br>(1) 通过数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> myslice []<span class="keyword">int</span> = arr[:<span class="number">3</span>]</span><br><span class="line"><span class="comment">//或者简写</span></span><br><span class="line"><span class="keyword">var</span> slice := [] <span class="keyword">int</span> &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure></p><p>(2) 通过make 语法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, capacity) <span class="comment">//其中capacity可以省略</span></span><br></pre></td></tr></table></figure></p><p>如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>对于切片，比较重要的特性就是，切片的长度可变，通过<code>append</code>方法完成，如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// [1, 4, 5]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">6</span>)  <span class="comment">// [1, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>在遍历数组和切片时，二者都类似，可以通过<code>for</code>语法，也可以通过<code>range</code>表达式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr or slice); i++ &#123;</span><br><span class="line">fmt.Println(arr[i])</span><br><span class="line">fmt.Println(slice[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">fmt.Println(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://blog.csdn.net/crawler_star/article/details/50354276" target="_blank" rel="noopener">http://blog.csdn.net/crawler_star/article/details/50354276</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在回京之前</title>
      <link href="//2017/11/02/back-to-beijing.html"/>
      <url>//2017/11/02/back-to-beijing.html</url>
      
        <content type="html"><![CDATA[<p>东西都已经打包好了，马上要离开武汉，返回北京，想想这几个月在武汉的生活和工作，可以用碌碌无为来形容<br><a id="more"></a></p><p>硕士毕业两年了，和当时去北京时的自己相比，有了很多成长和想法。毕业那会儿，拒绝了武汉的国企，毅然去了北京，就是因为不甘心，当时的想法是无论好坏，干两年就回去。没想到，就在去年，国内的房价暴涨，重要城市还限购，北京是不指望了，武汉也从均价1万不到，涨到2万还不一定能买不到，限购开启后，我不是武汉户口，没有买房资格，要落户必须在武汉就业，看来这是逼迫我回去了。于是从今年年后，一直就在留意武汉的机会，奈何武汉的公司确实少，还都不咋地，猎聘刷来刷去，就那么几个公司，艰难得很。一晃时间到了6月份，拿到几个offer，挑了个还算有名气的公司，打算回去。当我向leader和经理提离职时，我的心情是很难过的。回想起从毕业到进入数字公司的这两年，数字公司把我从一个传统通信的毕业生，领入到互联网行业，让我熟悉了互联网产品的工作模式，给了我一个很好的职业生涯起点，我心存感激。公司的各项制度和福利我都觉得很满意，年假多，病假多，身边的同事都很厉害，也很友好。我在这里成长，学到了很多东西，仍然觉得没有学够。要说离开，真的是十分不舍，可是为了不漂泊，着急买房，我还是选择了回去。走前经理给我说了很多话，其中一句是：你去了二线，基本就废了。我当时不以为然，没想到真的给后来的几个月工作埋下了伏笔。</p><p>整理好自己的衣物，在6月中旬，我踏上火车，离开了北京。回去的路上，心情随着轨道的响声，心情也是起伏不定。我想我仍然是恋恋不舍的，但在那时，我还不知道自己恋恋不舍的是什么。</p><p>回到武汉，找了房子住下，开始上班。从签劳动合同起，看着这个公司的一些制度，以及办公环境，员工精神风貌，我隐约觉得自己会干不长，期间北京的高德给我offer，我很无奈说自己要在二线买房，要结婚，所以不能回北京。高德HR问我是想奋斗还是宁愿干着一份自己不喜欢的工作时，我真的很痛苦，和妈妈打电话，泪水忍不住流了下来。这时我还是不敢重新回去，继续忍了。</p><p>武汉的夏天是炎热的，而我的心却是冰冷的。新公司总部在合肥，武汉属于分公司，做的东西都是政府保密的项目，其实说白了，就是外包，由于到国家安全，一般的外包公司无法招标，而这个公司有保密资质，因此可以做。套路就是一套系统，部署在这个地方政府，效果可以，然后再换个省份重新部，项目里没啥技术含量。没域名，没性能优化，毫无用户体验可言。办公电脑网速慢，发任何文件，都要先加密再发，收到后再解密，和总部那边整天开QQ视频会议，严重影响沟通效率，公司还鼓励加班，有的员工工作时间都12小时，关键给的钱还少！时常让我怀疑工作是否有所值，每天都会时不时冒出辞职走人的想法。我现在才想起离开北京时，经理跟我说的话：你去了二线，基本就废了。果真如此啊。。下班回到家，刷微博看到关于北京的新闻，总是会想起在北京的日子，时常失眠，而租的房子所在的小区，也是人多且杂，33层，每层20多户，只有3部电梯，房子朝西，夏天，太阳会把窗户烤得滚烫，小区下面，是个垃圾桶收集地，整个小区的垃圾都会集中在这里，垃圾车会在每天早上，或者是半夜在这里呜呜的粉碎垃圾，还有挖掘机在这里运装修垃圾，每天叫醒我的不是闹钟，而是噪音。工作上，生活上，两方面的不如意，让我对武汉这个城市失望透顶，对回来的决定后悔不已，这样的日子，每天过得真的好痛苦。我时常想如果我还在北京，如果我没有离职，那该多好。</p><p>8月份，女朋友也把家当全寄回来了，找了两个月的工作，仍然没找到满意的。于是放弃，提前过起家庭主妇角色，买菜做饭，打扫卫生，照顾我的生活起居，把屋子收拾得紧紧有条。给我痛苦的内心带来了一丝宽慰。有时吃完晚饭，我们会去旁边的大学里转悠，讨论下人生和未来。羡慕那些还在学校读书的孩子们。</p><p>9月份，终于把户口落了，这时前同事问我想不想回去，其实我是想回去的，哪怕受到同事的猜疑和议论。但后来得知，公司有个规定，离职半年内不能重新入职，且一年内重新入职，薪资不变。我顿时打消了这个念头，因为我等不了那么久。十一过后，和女朋友说了我想回一线的想法，不管是北京还是深圳，其实我知道，对于互联网行业，大概率会是北京。女朋友表示理解，愿意跟着我回去。于是提离职，投简历。北京的机会很多，各大公司都有坑，基本简历一放出去，电话就不断。相对来说，深圳就少很多。最后约了北京的几个大厂面试。请了两天假，买票上京。回京时间还是挺坑爹的，因为正好遇到19大，去京的安检措施很严，单独入口，层层检查，翻包开箱，还好把那个最重的行李快递了，不然真上不了车。</p><p>面试第一天的过程很紧凑，下了火车就直奔面试地点，一天跑了三个公司，每个公司都是3论技术面，平均3小时，等于说我要把自己的个人经历，项目经验给9个人重复9遍，说到自己都要吐了，午饭和晚饭都没有好好正经吃。面试完，赶最后一班地铁回去，住在女朋友姐姐那里。过了个周末，周一继续面，然后回武汉。</p><p>最后，面的几个大厂，基本都拿到了offer，由于要的薪资都差不多，到底去哪家，也纠结了下，不过现在基本确定了。快速和同事交接完工作，同时电话催着走离职流程。离职过程真是冗长，平均需要经过30个节点审批。拿到离职证明的那刻，感觉真是一种解脱。在今天，我算是彻底要结束在武汉的整整4个月的生活。</p><p>回头看看在武汉的这几个月，我想了很多，把过去的人生都梳理了一遍，同时反复问自己一个问题：到底想要什么，武汉是否能满足我。对于现在，我需要的是成长和积累，而不是安逸，离开北京后，我才发现，生活在哪里都是相似的，而工作和人，却是迥然不同的，我可以在武汉生活，却没法在这里工作。现在的我，对技术和视野，有着深深的渴望，而武汉现在的公司，是给不了我的。在这里呆下去，我的视野得不到开阔，内心越来越焦虑，而解决这些问题，我就得去一线，去最前沿的公司，跟着厉害的人，见贤思齐。同时，我也知道，在北上深，我可能一辈子都买不起房，在二线或许还有机会，但是，对比房子，我宁愿选择事业，也许几年后，我的想法会变，但当下，趁现在还没结婚没孩子，更需要拼搏，努力学习，提升自己的技术和能力，丰富自己的阅历，这就是我要去一线的主要原因。</p><p><strong>既然选择拼搏，就要去风口浪尖！</strong></p><blockquote><p>ps: 前几天，得知武汉政策又放开了：拿毕业证就可以落户，不需要就业证明。也就是说，我晚几个月回来，根本就不需要辞职回来就能落户。what the fuck！这种感觉，真的想是被玩弄了一样！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北京 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一道面试题：随机洗牌法和蓄水池算法</title>
      <link href="//2017/10/15/shuffle.html"/>
      <url>//2017/10/15/shuffle.html</url>
      
        <content type="html"><![CDATA[<p>面试时，遇到这么一个问题，觉得比较有意思，可惜我答得不好，特记录下。<br><a id="more"></a></p><p>面试官：请设计一个扑克牌发牌的程序<br>我：最初回答的很简单：先生成一副牌，再将牌随机打乱，然后平均分给4个数组<br>面试官：怎么将牌随机打乱呢？<br>我：Python 中有个 shuffle 函数，可以随机打乱<br>面试官：如果不用 shuffle 函数呢？<br>我：想了会儿，用随机数生成器，随机生成两张牌的索引，然后交换。<br>面试官：需要交换多少次？<br>我：懵逼+黑人问号脸。。。</p><p>后来查了下，其实这是一个经典的算法题：随机洗牌法。该算法要保证：任何一张牌，在所有的位置上的概率相同，或者说，有 N 张牌，遍历这 N 张牌，使得每张牌出现在任何位置的概率都为 1/N。具体操作如下：</p><p>这将扑克牌看做一个数组，依次遍历数组，对第 n 个元素，随机生成一个 0 到 n 之间的数 r，然后与第 r 个 个位置上的元素互换，最后生成的序列，即可满足要求。具体 python 版本实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle_poker</span><span class="params">(poker_list)</span>:</span></span><br><span class="line">    l = len(poker_list)</span><br><span class="line">    <span class="keyword">for</span> i,pk <span class="keyword">in</span> enumerate(poker_list):</span><br><span class="line">        idx = random.randint(<span class="number">0</span>, i)</span><br><span class="line">        poker_list[idx], poker_list[i] = poker_list[i],poker_list[idx]</span><br></pre></td></tr></table></figure></p><p>可以看到，代码写出来十分简洁，那是不是符合要求的呢？下面我们来证明下，证明需要用到数学归纳法。</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>先考察只有几个元素时的情况：</p><ol><li>当 n=1 时，一个元素放在一个位置的概率为1 </li><li>当 n=2 时，根据算法，第一个位置已经暂且定下位置。第二个元素只能随机两个数字，概率均为 1/2，第一个元素要么和第二个元素置换，要么位置不变，两个元素在任意这两个位置的概率都是 1/2。 </li><li>当 n=3 时，根据算法，前两个元素已经暂且定下位置。我们来看看第 3 个元素在任意位置的概率是多少？根据算法，此时随机数的区间是 [0,3]，任一数字的概率都为 1/3。在没有第 3 个元素和第 3 个位置时，由第 2 步知，前两个元素的任意位置概率是 1/2，那现在有3个位置，自然概率就要变化，假设第一个位置的元素值是 a，那么这个 a 现在只有两种情况，要么保持位置不变，要么和第 3 个位置交换。<br>1）保持位置不变的概率是 a 在前两个位置的概率乘以新随机的数不是该位置的概率，即 1/2×(1−1/3)，结果是1/3。<br>2）与第 3 个位置进行交换的概率是 a 在第一个位置的概率乘以随机出第一个位置数的概率加上 a 在第二个位置的概率乘以随机出第二个位置数的概率，即 1/2×1/3+1/2×1/3，结果为 1/3。<br>综上，当 n=3 时，即发完第 3 张牌后，第一个位置上的元素出现在任意位置的概率为 1/3。第二个位置也可以这么证明。</li></ol><p>下面给出严谨证明，用到数学归纳法：<br>基础步骤： 当 n=1 时，第一位置元素只能随机出1，概率为1，定理成立。<br>归纳步骤： 当 n=k，k 个元素在任 k 个位置的概率均为$\frac {1}{k}$成立。<br>那么，当 n=k+1,第 k+1 位置的元素在任 k+1 个位置的概率是$\frac {1}{k+1}$，因为随机出 k+1 个数概率是一样的。前 k 个元素的概率发生了变化，任意一元素保持位置不变的概率为$\frac {1}{k}$ × ($1-\frac {1}{k+1}$),结果为$\frac {1}{k+1}$;任意一元素与第 k+1 元素进行置换的概率为$\frac {1}{k} × (\sum_{1}^{k}\frac {1}{k}× \frac {1}{k+1})$ ,结果为$\frac {1}{k+1}$,综上，前 k 个元素在任意位置的概率为$\frac {1}{k+1}$。<br>定理成立，证毕。</p><blockquote><p>其实，上面的这种方法，就是 python random 包中的 shuffle 方法的实现，即 shuffle 方法就是用随机洗牌法来打乱一个序列的。</p></blockquote><h2 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h2><p>其实此算法可以进一步推广，即不限定元素的个数为一副牌的数量，可以认为数量非常大，我们暂把它记为序列 N，直到处理完 N 之前，我们不知道这个 N 有多大，现在需要对这样的一个序列 N 抽样，样本个数为 m，要求只遍历一遍，有什么办法保证抽样的公平性？</p><p>这就要用到蓄水池算法，这种算法过程其实和前面的随机洗牌法类似。</p><ol><li>首先构建一个大小为 m 的数组，然后将序列前 m 个元素放入数组中。</li><li>然后从第 m+1 个元素开始，对第 k 个元素（k &gt;= m+1），把它记为当前元素，仍然先随机生成一个 [0, k] 之间的数 r，如果 r &lt; m，则将数组中第 r 个位置的数替换为当前元素。</li><li>遍历完该序列，数组中的 m 个数即为满足要求的抽样。</li></ol><p>参考代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 构造长度为 m 的 list</span><br><span class="line">sample_list = [<span class="keyword">None</span>] * m</span><br><span class="line">l = len(sample_list)</span><br><span class="line">// N 的前 m 个元素填充 list</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">sample_list = N[i]</span><br><span class="line"></span><br><span class="line">// 从 m+<span class="number">1</span> 个元素起，随机替换 list</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(l, len(N)):</span><br><span class="line">idx = random.randint(<span class="number">0</span>, i)</span><br><span class="line"><span class="keyword">if</span> idx &lt; m:</span><br><span class="line">sample_list[idx] = N[i]</span><br></pre></td></tr></table></figure></p><p>证明过程，依然用到数学归纳法，这里不打算给出了，有兴趣的朋友可以看下面的参考链接，或者《编程珠玑》这本书。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="http://blog.csdn.net/crawler_star/article/details/50354276" target="_blank" rel="noopener">http://blog.csdn.net/crawler_star/article/details/50354276</a></li><li><a href="https://www.cnblogs.com/HappyAngel/archive/2011/02/07/1949762.html" target="_blank" rel="noopener">https://www.cnblogs.com/HappyAngel/archive/2011/02/07/1949762.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> algorithm </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>php-fpm 子进程的数量，是越大越好吗？</title>
      <link href="//2017/10/11/fpm-conf.html"/>
      <url>//2017/10/11/fpm-conf.html</url>
      
        <content type="html"><![CDATA[<p>我们知道，在 Linux 环境下，处理php脚本的进程是<code>php-fpm</code>。<code>php-fpm</code>的允许方式有两种：</p><ul><li>static ：表示在 <code>php-fpm</code> 运行时直接 <code>fork</code> 出 <code>pm.max_chindren</code> 个子进程，</li><li>dynamic：表示，运行时 <code>fork</code> 出 <code>start_servers</code> 个进程，随着负载的情况，动态的调整，最多不超过 <code>max_children</code> 个进程。<a id="more"></a></li></ul><p>一般推荐用 <code>static</code>。</p><p>优点是不用动态的判断负载情况，提升性能；<br>缺点是多占用些系统内存资源。</p><p><code>php-fpm</code> 子进程数量，是不是越多越好？</p><p>当然不是，<code>pm.max_chindren</code>进程多了，增加进程管理的开销以及上下文切换的开销。</p><p>更核心的是，能并发执行的 <code>php-fpm</code> 进程不会超过 cpu 个数。</p><p>如何设置，取决于你的代码</p><ul><li>如果代码是 CPU 计算密集型的，<code>pm.max_chindren</code> 不能超过 CPU 的内核数。</li><li>如果不是，那么将 <code>pm.max_chindren</code> 的值大于 CPU 的内核数，是非常明智的。</li></ul><p>国外技术大拿给出这么个公式：</p><p>在 <code>N + 20%</code> 和 <code>M / m</code> 之间。</p><blockquote><p>N 是 CPU 内核数量。<br>M 是 PHP 能利用的内存数量。<br>m 是每个 PHP 进程平均使用的内存数量。<br>适用于 <code>dynamic</code> 方式。</p></blockquote><p><code>static</code>方式： M / (m * 1.2)。如假设每个 PHP 进程使用的内存在 20M - 30M 左右（具体消耗可能有差异，如果要上传文件，处理图像，或者允许的是内存集中型应用，得到的消耗会高些）。而为整个 php-fpm 环境配置了 512 M 内存，那么可以设置为 17-25 中间值。</p><p>当然，还有一种保险的方式，来配置 max_children。适用于 <code>static</code> 方式。</p><ul><li>先把 <code>max_childnren</code> 设置成一个比较大的值。</li><li>稳定运行一段时间后，观察 <code>php-fpm</code> 的 <code>status</code> 里的 <code>max active processes</code> 是多少</li><li>然后把 <code>max_children</code> 配置比它大一些就可以了。</li></ul><p>参考：</p><ul><li><a href="https://segmentfault.com/a/1190000004190979" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004190979</a></li><li><a href="https://segmentfault.com/a/1190000000630270" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000630270</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> fpm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>有一条查询很慢的sql语句，怎么优化它</title>
      <link href="//2017/09/20/slow-mysql.html"/>
      <url>//2017/09/20/slow-mysql.html</url>
      
        <content type="html"><![CDATA[<p>做服务端或后台岗位面试时，有些面试官会问这样的一个问题：有一条sql语句很慢，怎么去优化它。这个问题很有难度，能很好考察求职者对于mysql掌握的程度，以及思考问题的广度。此问题也没有标准的答案，答得越多越好。<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由 lnmp 一键安装脚本所引发的错误</title>
      <link href="//2017/09/12/lnmp-debug.html"/>
      <url>//2017/09/12/lnmp-debug.html</url>
      
        <content type="html"><![CDATA[<p>在装<a href="https://lnmp.org/" target="_blank" rel="noopener">lnmp</a>全家桶时，有时为了方便，会直接用一键安装脚本，一条命令，就把所有的环境都装好了，简单省事，但有时出现配置错误，也不太好排查，分享一个遇到的问题。<br><a id="more"></a></p><p>我安装好 lnmp 环境后，启动一个简单的 php 框架项目时，却报错，错误如下图所示<br><img src="/images/error-log.jpg" alt="报错log"><br>大意就是 web 目录被限制，不能访问。查了下 php.ini，里面并没有配置<code>open_basedir</code>选项，按理说应该没问题。找了很久都没有找到是在哪里配置了这个。最后<a href="http://www.xujimmy.com/blog/2016/11/16/linux-grep.html" target="_blank" rel="noopener">grep</a>了下,发现是在装lnmp时，一键安装脚本自作主张，在两个地方，设置了该配置:</p><ol><li>脚本在web根目录新建了个<code>.user.ini</code>的隐藏文件，里面配置了<code>open_basedir</code>，如图：<br><img src="/images/user-ini.jpg" alt="user.ini"></li><li>另外一个是在nginx的fastcgi.conf中，配置了一个变量，如下：<br><img src="/images/fastcgi-conf.jpg" alt="fastcgi.conf"></li></ol><p>正因为这两个配置，导致出现开头所见的问题。</p><p>解决办法就是去掉这两个配置，删第二个地方的配置简单，直接删除<code>open_basedir</code>那行，然后重启fpm和nginx即可。第一个地方删除.user.ini文件时比较奇怪，我直接用root账户去删，仍然提示无权限，google查了下，发现是文件属性被改变了，具体点就是用<code>chattr</code>命令改变文件或目录的属性，使之不得以任意方式删除或更新。哪怕是root用户，这个跟<code>chmod</code>命令改变文件权限功能类似，<code>chmod</code>命令只是改变文件的读写、执行权限，而<code>chattr</code>命令则是更彻底的改变文件属性。<code>chattr</code>使用方式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...]</span><br></pre></td></tr></table></figure></p><p>参数：<br>　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。<br>　　-v&lt;版本编号&gt; 设置文件或目录版本。<br>　　-V 显示指令执行过程。<br>　　+&lt;属性&gt; 开启文件或目录的该项属性。<br>　　-&lt;属性&gt; 关闭文件或目录的该项属性。<br>　　=&lt;属性&gt; 指定文件或目录的该项属性。</p><p>其中属性参数如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a：让文件或目录仅供附加用途。</span><br><span class="line">b：不更新文件或目录的最后存取时间。</span><br><span class="line">c：将文件或目录压缩后存放。</span><br><span class="line">d：将文件或目录排除在倾倒操作之外。</span><br><span class="line">i：不得任意更动文件或目录。</span><br><span class="line">s：保密性删除文件或目录。</span><br><span class="line">S：即时更新文件或目录。</span><br><span class="line">u：预防以外删除。</span><br></pre></td></tr></table></figure></p><p>举个例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#防止系统中某个关键文件被修改</span></span><br><span class="line">chattr +i /etc/resolv.conf</span><br></pre></td></tr></table></figure></p><p>这样root用户都改不了resolv.conf文件了，查看下该文件的属性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr /etc/resolv.conf</span><br></pre></td></tr></table></figure></p><p>会显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">----i-------- /etc/resolv.conf</span><br></pre></td></tr></table></figure></p><p>回到之前的问题，查看下.user.ini文件的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr .user.ini</span><br></pre></td></tr></table></figure></p><p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">----i------e- .user.ini</span><br></pre></td></tr></table></figure></p><p>看到文件确实是被锁定了，修改如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr -i .user.ini</span><br></pre></td></tr></table></figure></p><p>然后再删除就成功了。为什么该文件会被锁定？答案在lnmp安装脚本中：<br><img src="/images/chattr.jpg" alt="install.sh"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>安装一个软件，要知道安装过程中，那些脚本到底是做了什么，这样出了问题才好找</li><li>网上的一键安装脚本，可以用，但要慎重</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> php </tag>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>当你在浏览器中输入网址，到看到网页，发生了什么</title>
      <link href="//2017/09/10/http.html"/>
      <url>//2017/09/10/http.html</url>
      
        <content type="html"><![CDATA[<p>这是一道经典的面试题，不光是前端面试会问到，后端也会，此题没有标准的答案，但在你了解的范围内，当然是答得越详细越好，这里就简单记录下几个关键流程吧。<br><a id="more"></a></p><p>当你在浏览器中输入<a href="http://www.xujimmy.com/about" target="_blank" rel="noopener">http://www.xujimmy.com/about</a>时，至少会经过以下几个步骤：</p><ul><li>浏览器从url中解析出主机名，如这里的就是<code>www.xujimmy.com</code></li><li>DNS解析主机对应的IP，就是解析<code>www.xujimmy.com</code>对应的IP地址，如果本地hosts文件中，有主机名和ip的映射关系，就直接用这个ip，完成解析，如果没有，则查找本地DNS解析器缓存，如果最近没有对该主机进行访问，那么浏览器就得去DNS解析服务器去找IP，然后缓存起来，可能会花费数秒时间</li><li>根据IP和端口，与服务器建立TCP连接（三次握手）</li><li>一旦连接建立，浏览器就通过该连接来发送HTTP请求</li><li>服务器处理请求，并返回HTTP响应包</li><li>浏览器接收到来自服务器的响应后，开始解析渲染包中的主体，组织成页面</li><li>连接结束</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP 和 HTTP</title>
      <link href="//2017/09/10/tcp-http.html"/>
      <url>//2017/09/10/tcp-http.html</url>
      
        <content type="html"><![CDATA[<p>在经典的计算机网络 ISO 七层模型中，最接近用户的，是应用层，其次是传输层。应用层中，HTTP 是最重要的协议之一，而 TCP，则是传输层中最重要的协议之一，这两类协议可以说是现代互联网的基石。无论是组网，编码，网络故障定位，面试，这两类协议都是相当重要的，网上已经有很多相关的分析文章，这里也整理下我关于这两个协议的相关理解。<br><a id="more"></a></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 在传输层中实现，它是一个面向连接的协议，面向连接是相对于 UDP 这种无连接而言，具体说来，就是客户端和服务端传数据之前，会经过一个称为三次握手的过程。由于 TCP 是传输层协议，因此三次握手也是发生在传输层，<strong>传输层利用网络层提供的功能，向上层提供可靠的服务，注意这个可靠二字。TCP 通过一系列的措施，如确认号，重传等机制，处理传输过程中丢失、超时、数据错误的问题，保证了可靠二字。</strong></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>先来看看建立 TCP 时发生的三次握手示意图，这里需要说明下，网上已经有很多类似的关于 TCP 三次握手的图了，基本样式都是画两条竖线，竖线两边标识 TCP 状态，竖线中间画几个箭头，但很少指明竖线代表什么，而且把状态标识在了箭头的起始点和终点，个人认为这种方式不严谨，因此本文没有照搬网上的那些图，而是自己画了两张图。重点是为了说明：<br><strong>两条竖线代表着客户端和服务器的时间轴，从上往下看，以时间为参照；每一个状态对应着一个时间段，而不是对应报文的发送和接收时刻，把状态标识在箭头的起始位置和终点位置，是不严谨的，因此我以不同的颜色标识时间段，并把状态标识在时间段中间位置</strong><br><img src="/images/tcp-three-handshakes.jpg" alt="三次握手"></p><p><strong>第一次握手</strong>：建立 TCP 连接的发起者是客户端，客户端 TCP 先将 SYN 同步序列号置 1，说明这是一个连接请求，并随机选择一个初始序号（client_isn）并将其放置在起始的TCP SYN报文段的序号字段中（seq），然后客户端进入到 SYN-SENT 状态。</p><p><strong>第二次握手</strong>：服务器收到了 TCP SYN 报文段，会为该 TCP 分配 TCP 缓存和变量,首先，服务端也将自己的 SYN 置为 1，然后，该 TCP 的首部确认字段（ACK）被置为 client_isn+1，也就是告诉客户端：“我收到了，你能收到我的吗？”。最后，服务器也选择自己的初始序号（server_isn），并将其放在 TCP 报文段首部的序号字段中，一并发给客户端，这时服务器进入到 SYN_RCVD 状态。</p><p><strong>第三次握手</strong>：客户端在收到服务器的 SYN ACK 报文段后，客户端也给该连接分配缓存和变量。客户端首先会将 server_isn+1,放置到 TCP 报文段首部来确认服务器的允许连接（ack=server+1）。因为连接实际已经建立了，因此 SYN 被置 0。同时也置 ACK=1，这个报文发出去后，客户端进入到 ESTABLISHED 状态。服务端收到报文，也进入到 ESTABLISHED 状态。</p><p>三次握手完成后，客户端和服务器就已经建立了一条可靠的 TCP 连接信道，双方可以正常收发数据了。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>说完了建立连接时的三次握手，再来看下断开连接时的四次挥手,先看下图，需要注意的是，不同于上面的客户端和服务器，<strong>TCP 的建立时，都是由客户端主动发起连接请求的，而 TCP 的断开，可以是任意一方发起，也就是说服务端也可以主动要求关闭，即只有主动关闭和被动关闭</strong>，网上很多博客文章里，草草的把挥手时的发起方写为客户端，会让人以为只有客户端才能关闭连接，有很大的误导性。为了消除这种误导，下面在说明断开连接时，只写主动关闭方和被动关闭方。<br>先看下四次挥手示意图，从上往下看，以时间轴为参照。<br><img src="/images/tcp-four-handshakes.jpg" alt="四次挥手"></p><p><strong>第一次挥手</strong>：当要断开 TCP 连接时，主动关闭方会发 FIN=1，seq=u（相当于前面已经传过去的最后一个字节的序号+1）的报文，表示自己已经没有数据需要发送，想关闭 TCP 连接了，然后自己进入 FIN-WAIT-1 状态，等待对方确认。</p><p><strong>第二次挥手</strong>：被动关闭方收到报文后，马上发出确认 ACK=1，这个报文段自己的序号 seq=v（相当于服务端前面已经传送过的最后一个字节的序号+1），但发出去 ACK 后，它还不能马上就关闭连接，因为虽然对方没有数据要发了，但可能自己还有数据要发。因此当发完 ACK 后，被动关闭方会进入 CLOSE-WAIT 状态，表示“我知道你要关闭连接了，稍等下，我还有点数据要发”。<br>主动关闭方收到来自对方的 ACK 后，就进入了 FIN-WAIT-2 状态。</p><p><strong>第三次挥手</strong>：若被动关闭方已经没数据要发了，那么它就要发 FIN=1 的连接释放报文，假定当前最后一次确认发送的序号为w（seq=w），并且需要重复发送上次确认过的确认号 ack=u+1。这时它就进入 LAST-ACK 状态，等待对方最后确认。</p><p><strong>第四次挥手</strong>：主动关闭方收到对方的连接释放 FIN 后，在确认号中把 ACK 置为1，确认号是 ack=w+1，而自己的序号仍然是 seq=u+1。发出去后，它就进入 TIME-WAIT 状态。为了保证对方收到这个报文，它会等待一段时间，被称为 2MSL，一般是 30 秒，之后进入 CLOSED 状态，并且释放 TCP 所有资源，而被动关闭方收到 ACK 报文后，也进入到 CLOSED 状态。至此，TCP 连接完全断开。</p><p>在网络编程时，主动关闭方调用 close 函数，发送 FIN，进入到 FIN-WAIT-1，被动关闭方收到后，read 函数返回 0， 知道对方要关闭，发送 ACK，进入 CLOSE-WAIT。然后被动关闭方也调用 close 函数，发送 FIN 给对方，进入 LAST-ACK。可以看到，如果被动关闭方如果没调 close 或者忘了调用，那么 TCP 连接就不会关闭，CLOSE-WAIT 状态会一直持续下去。</p><blockquote><p>对于刚学网络编程的同学来说，都知道 TCP 会有三次握手四次挥手，但实际编程时，似乎代码中也没有处理 SYN ACK 握手之类的，仅仅调用 connect，close 等函数，这是因为握手挥手这些动作都是由<strong>操作系统内核协议栈</strong>完成的，我们不用关心，当我们程序中调用 connect 时，就是告诉操作系统，我想建连接，那么操作系统内核就会帮我们完成三次握手的操作，如果成功，则 connect 返回，因此我们不需要关心握手的过程，close 也类似，同理，像那些给数据包加 TCP 头，IP 头的动作，也不是我们需要关心的，这个操作系统内核会帮我们处理好。</p></blockquote><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><h4 id="1-为什么要-4-次挥手呢"><a href="#1-为什么要-4-次挥手呢" class="headerlink" title="1. 为什么要 4 次挥手呢?"></a>1. 为什么要 4 次挥手呢?</h4><p>被动关闭方收到 FIN 请求后，并不会马上关闭连接，因为它可能还有数据要发送，所以不能和建立连接时那样，直接发送 ACK 和 SYN，只能先回复一个 ACK，表示你的关闭请求（FIN）已经收到了，让我把剩下的东西传完。传完后，才能发送 FIN 报文，从而关闭 TCP 连接。</p><h4 id="2-为什么-TIME-WAIT-状态需要等-2MSL-后才能到-CLOSED-状态？"><a href="#2-为什么-TIME-WAIT-状态需要等-2MSL-后才能到-CLOSED-状态？" class="headerlink" title="2. 为什么 TIME-WAIT 状态需要等 2MSL 后才能到 CLOSED 状态？"></a>2. 为什么 TIME-WAIT 状态需要等 2MSL 后才能到 CLOSED 状态？</h4><p>这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，主动关闭方不能保证最后发送的 ACK 报文会一定被对方收到，假如这个 ACK 真的丢了，那么被动关闭方会因为没收到 ACK，而重发 FIN 报文，假如主动关闭方没有 TIME-WAIT，而是发完 ACK 就直接关闭，那这时对方重发过来的 FIN 就无法再收到了，因为连接都关了。所以这个 TIME-WAIT 状态的作用就是保证最后的这个 ACK 能被对方收到，万一这个 ACK 丢失了，因为连接还没断，所以还可以用来重发这个丢失的 ACK 报文。</p><p>另一方面，假如主动关闭方立刻进入 CLOSED，马上应用程序又用这个端口建立了新的连接，也建立成功了，但现在网络中，可以有上一个连接的数据包，这样就会让接收方迷惑：这个数据包到底是上一个 TCP 连接的呢？还是这个 TCP 连接的呢？为了避免这种情况发生，因此先等待 2MSL，让网络中属于这个连接的包都消失（2MSL 是一个包在网络中生存的最大时间），这样再用这个端口建连接时，就不会有上面的问题。</p><h3 id="Linux-下查看-TCP-状态"><a href="#Linux-下查看-TCP-状态" class="headerlink" title="Linux 下查看 TCP 状态"></a>Linux 下查看 TCP 状态</h3><p>在 Linux 环境，我们经常要看网络相关状态，可以通过<code>netstat</code>命令。比如查看 nginx 服务的网络状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p 表示打印进程</span></span><br><span class="line">netstat -anp | grep nginx</span><br></pre></td></tr></table></figure></p><p>执行结果中，有一列展示了网络连接的状态，如 LISTEN，ESTABLISHED 等。</p><p>统计当前系统各个 TCP 状态的总数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 tcp 开头，awk 默认以空格分割，$NF 表示最后一个字段，即连接状态，存入到 S 中，S 类似于哈希表，键为 TCP 状态，值为数量</span></span><br><span class="line">netstat -n | awk <span class="string">'/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'</span></span><br></pre></td></tr></table></figure></p><p>某机器执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CLOSE_WAIT 22</span><br><span class="line">ESTABLISHED 208</span><br><span class="line">FIN_WAIT2 1</span><br><span class="line">SYN_SENT 1</span><br><span class="line">TIME_WAIT 8</span><br></pre></td></tr></table></figure></p><p>如果你看到你的机器 CLOSE_WAIT 状态很多，那么基本可以肯定是代码代码出了问题，要么是忘了 close 相应的 socket，要么是出现死循环，导致 close 一直没有被调用。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面介绍了 TCP 的建立和关闭握手过程，以及发送的报文和对应的状态，重点需要关注的是它们的状态流转过程。<br>可能有同学跟我一样，觉得这些报文和状态流转太难记了。我们始终抓住一点，TCP 保证可靠性的重要机制是<strong>确认</strong>，什么是确认？就是说你发了一个报文（SYN，FIN），我必须对这个报文进行确认（ACK）。只有双方都确认了，才能后续工作。建立连接时，客户端发了 SYN 报文，因此服务端就发 ACK 确认，同时也发 SYN，客户端收到后，发 ACK 确认，双方都 ACK 了。断开连接时，主动关闭方发了 FIN，被动关闭方发 ACK 先确认，然后再发 FIN，主动关闭方发 ACK 确认，双方也都 ACK 了。</p><blockquote><p>还有一点，TCP 连接是一个<strong>逻辑</strong>上的概念，通信双方通过状态机来标识连接的建立，如果双方的状态都是 ESTABLISHED，那么就认为连接已建立，可以收发数据。如果双方都不收发数据，那么系统会一直维持这个连接，及时你把网线拔了，双方也是感知不到的。只有当某一方发数据，却没有收到对方的 ACK，重试了几次后（重试次数可以通过内核参数修改），仍然没收到 ACK，那么这时发数据的一方就感知到，这个 TCP 连接可能断了，于是状态变更为 CLOSED。但如果在重试过程中，又把网线插好，对方收到数据后，回复 ACK，那么这个连接仍然是有效的。</p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>上面讲完了 TCP 的连接和断开握手挥手过程，再来看下 HTTP。我们知道，HTTP 是一个应用层协议，它基于 TCP，客户端每发一次向服务器发 HTTP 请求之前，都需要完成上述的 TCP 三次握手，断开连接，也需要经过 四次挥手。我们用浏览器访问各种网页，发的每个请求，都是 HTTP。如果你使用的是 google Chrome 浏览器，按 F12 打开开发者模式窗口，然后再打开网页，就可以看到浏览器发了哪些请求了。但为啥我们看不到 TCP 呢？那是因为浏览器是用户软件，运行在应用层，使用的是应用层协议 HTTP，是看不到传输层 TCP 的，按照 ISO 标准来说，下层协议向上层提供服务，上层不用感知下层。因此，HTTP 不用关注传输数据的正确性和顺序等，因为传输层的 TCP 已经保证了，HTTP 也看不到三次握手的过程。</p><p>我们来看下一次完成的 HTTP 请求和响应过程，这里推荐大家下载一个 HTTP 神器：<a href="https://httpie.org/" target="_blank" rel="noopener">httpie</a>，一个完全可以替代 Linux 下 curl 的工具，可以大大简化我们发 HTTP 请求的繁琐方式，而且更加友好美观。本文不打算详细介绍它的使用，具体的使用方法直接在官网查看即可，我们先来试用下，如向本文章的 url 发一个请求，并打印 HTTP 请求和响应头<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http https://xujimmy.com/2017/09/10/tcp-http.html -v</span><br></pre></td></tr></table></figure></p><p>输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">GET /2017/09/10/tcp-http.html HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Host: xujimmy.com</span><br><span class="line">User-Agent: HTTPie/0.9.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Age: 0</span><br><span class="line">Cache-Control: max-age=600</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 10207</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Date: Mon, 17 Jun 2017 11:11:57 GMT</span><br><span class="line">ETag: W/&quot;5d063c9c-701a&quot;</span><br><span class="line">Expires: Mon, 17 Jun 2017 11:21:57 GMT</span><br><span class="line">Last-Modified: Sun, 16 Jun 2017 12:57:00 GMT</span><br><span class="line">Server: GitHub.com</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Via: 1.1 varnish</span><br><span class="line">X-Cache: MISS</span><br><span class="line">X-Cache-Hits: 0</span><br><span class="line">X-Fastly-Request-ID: 1808fe2ed24a2bed619246226e75770b090d255f</span><br><span class="line">X-GitHub-Request-Id: C03E:0521:11A7ECB:12EDDF4:5D07757D</span><br><span class="line">X-Served-By: cache-hnd18747-HND</span><br><span class="line">X-Timer: S1560769917.195156,VS0,VE103</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>由上面可以看到，一次完整的 HTTP 过程，包括两个部分：<strong>请求</strong>和<strong>响应</strong>。<br><img src="/images/http-request-response.jpg" alt="请求和响应"></p><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>HTTP 请求由三部分构成：请求行，请求头，请求正文</p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>请求行用来说明请求类型，要访问的资源，以及使用的 HTTP 版本。基本格式如下：Method URI Http-version<br>如上面的请求行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /2017/09/10/tcp-http.html HTTP/1.1</span><br></pre></td></tr></table></figure></p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>紧挨着请求行（即第一行）之后的部分，用来说明服务器需要使用的附加信息，例如Host,User-Agent,Accept,Cookie等信息，每行都是以一个<code>k: v</code>的形式组成。服务器可以通过这些信息，来判断客户端的来源以及做些身份鉴别等。如上面的请求头为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Host: xujimmy.com</span><br><span class="line">User-Agent: HTTPie/0.9.4</span><br></pre></td></tr></table></figure></p><p>上面的请求头中，有个叫<code>Connection: keep-alive</code>的东西，这个很有意思，它是告诉服务器：<strong>请维护这个连接不要关闭，我后面还要用</strong>。注意这句话，<strong>这里并不是说维护这个 HTTP 连接，而是维护这个 HTTP 下面的 TCP 连接</strong>，这种连接也称为长连接，这样带来的好处是可以将一个 TCP 连接信道复用，发多个 HTTP 请求。在 http1.1 中，长连接这个选项是默认开启的。关于长连接，可以看看本文底部的几个参考链接。</p><h4 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h4><p>在请求行和请求头完了后，空两行，就是请求正文了，包括要传递给服务器的各种参数等，上面的请求没有请求正文。</p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>HTTP 响应也由三部分构成：状态行，响应头，响应体</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>状态行由 HTTP 协议版本号， 状态码， 状态消息三部分组成，如上面的状态行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure></p><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>用来说明客户端需要的一些附加信息，如 Content-Length，Date，Server 等，格式也是以<code>k: v</code>形式返回，如上面的响应头为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Age: 0</span><br><span class="line">... //中间的省略</span><br><span class="line">X-Timer: S1560769917.195156,VS0,VE103</span><br></pre></td></tr></table></figure></p><h4 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h4><p>这部分为服务器返回的响应正文，如上面的响应正文为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...  //省略</span><br></pre></td></tr></table></figure></p><p>综上，可以看到，请求和响应的基本格式，除了起始行有所不同外，其余的头部，正文两部分格式是相同的。</p><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>来看下响应状态行中的状态码，状态码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><p>1xx：指示信息–表示请求已接收，继续处理</p><p>2xx：成功–表示请求已被成功接收、理解、接受</p><p>3xx：重定向–要完成请求必须进行更进一步的操作</p><p>4xx：客户端错误–请求有语法错误或请求无法实现</p><p>5xx：服务器端错误–服务器未能实现合法的请求</p><p>常见状态码：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>客户端请求成功</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久跳转，如将 80 端口的 http 请求永久跳转到 443 端口的 https</td></tr><tr><td>302</td><td>Moved Temporarily</td><td>临时跳转</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求有语法错误，不能被服务器所理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </td></tr><tr><td>403</td><td>Forbidden</td><td>服务器收到请求，但是拒绝提供服务</td></tr><tr><td>404</td><td>Not Found</td><td>请求资源不存在，eg：输入了错误的URL</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器发生不可预期的错误</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关的服务器，如nginx，从后端服务收到一个无效响应</td></tr><tr><td>503</td><td>Server Unavailable</td><td>服务不可用，服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td></tr><tr><td>504</td><td>Gateway time-out</td><td>作为网关服务器，如nginx，请求后端服务超时 </td></tr></tbody></table><p>### </p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="http://blog.csdn.net/hjtl1992/article/details/68944455" target="_blank" rel="noopener">http://blog.csdn.net/hjtl1992/article/details/68944455</a></li><li><a href="https://jiajunhuang.com/articles/2017_10_14-web_dev_part2.md.html" target="_blank" rel="noopener">https://jiajunhuang.com/articles/2017_10_14-web_dev_part2.md.html</a></li><li><a href="https://blog.huoding.com/2016/01/19/488" target="_blank" rel="noopener">https://blog.huoding.com/2016/01/19/488</a></li><li><a href="https://zhuanlan.zhihu.com/p/61423830" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61423830</a></li><li><a href="https://www.imperva.com/learn/performance/http-keep-alive/" target="_blank" rel="noopener">https://www.imperva.com/learn/performance/http-keep-alive/</a></li><li><a href="http://www.firefoxbug.com/index.php/archives/2805/" target="_blank" rel="noopener">http://www.firefoxbug.com/index.php/archives/2805/</a></li><li>《http权威指南》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> TCP </tag>
            
            <tag> HTTP </tag>
            
            <tag> httpie </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手动编译安装nginx</title>
      <link href="//2017/08/20/install-nginx.html"/>
      <url>//2017/08/20/install-nginx.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://nginx.org/" target="_blank" rel="noopener">Nginx</a>是一个高性能的HTTP和反向代理服务器，目前已经成为Web开发部署的标配了，基本拿到一台机器或者vps，都要装上nginx，但由于很多Linux发行版的包管理里面的源没有nginx，导致用<code>yum</code>或者<code>apt</code>都无法安装，需要手动配置，这里记录两种方法安装nginx<br><a id="more"></a></p><h2 id="用yum安装"><a href="#用yum安装" class="headerlink" title="用yum安装"></a>用yum安装</h2><p>既然基础的包管理中没有nginx，那么我们自己手动添加一个nginx的源，方法如下，（注意，以下是在centOS环境下测试过，其他发行版不保证成功）</p><ol><li>在<code>/etc/yum.repos.d</code>目录下，新建一个配置文件nginx.repo，填写如下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure></li></ol><p>保存，这样我们就有了nginx的源</p><ol start="2"><li>现在可以用yum安装了，执行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install nginx</span><br></pre></td></tr></table></figure></li></ol><p>喝口水，nginx就已经装好了，用此种方法安装的nginx，在<code>/usr/sbin/nginx</code>下，配置在<code>/etc/nginx/</code>目录下，且已经加入到系统服务中，要启动，直接执行<code>service nginx start</code>即可。</p><h2 id="手动编译安装"><a href="#手动编译安装" class="headerlink" title="手动编译安装"></a>手动编译安装</h2><p>有时候遇到非常蛋疼的场景，公司机器不能上外网，这时候就得手动编译安装了，但你要确保有可以编译的软件源码包，如果这个都没有，又不能下，那洗洗睡吧。<br>编译安装nginx需要准备<a href="http://www.pcre.org/" target="_blank" rel="noopener">pcre</a>,<a href="http://www.zlib.net/" target="_blank" rel="noopener">zlib</a>,<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">openssl</a>库，下完安装包侯，开始安装了，安装的方法，基本都如出一辙<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf xxx.tar.gz</span><br><span class="line"><span class="built_in">cd</span> xxx</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>注意的是，openssl库配置编译选项，是<code>./config</code>，而不是<code>./configure</code><br>现在开始安装nginx了，一样的套路<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf nginx-1.12.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.1</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>安装完后，直接运行<code>./usr/local/nginx/sbin/nginx</code>，没意外的话，nginx已经启动，如果提示找不到libpcre.so之类的错误，如<code>error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory</code>，<br>解决办法，则直接建个软链吧<br>32位系统，执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/lib/libpcre.so.1 /lib</span><br></pre></td></tr></table></figure></p><p>64位系统，执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/lib/libpcre.so.1 /lib64</span><br></pre></td></tr></table></figure></p><p>然后再启动，就OK了</p><p>最后，直接访问<a href="http://your_ip" target="_blank" rel="noopener">http://your_ip</a><br>没问题的话，可以看到nginx的欢迎页面</p><p>后面有时间，再整理个nginx配置的文档</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信公众号开发初探</title>
      <link href="//2017/08/11/weixin-dev.html"/>
      <url>//2017/08/11/weixin-dev.html</url>
      
        <content type="html"><![CDATA[<p>最近利用空闲时间，申请了个微信公众号，完成一些小功能练练手，本文总结下开发公众号期间的一些步骤，心得和体会吧。<br><a id="more"></a></p><h2 id="申请微信公众号"><a href="#申请微信公众号" class="headerlink" title="申请微信公众号"></a>申请微信公众号</h2><p>要开发微信公众号，首先得有一个吧，直接在<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">官网</a>申请，记住是新申请，不是用你原来的QQ或微信登录，申请过程中，要注意的是，我们申请的是订阅号，用于个人开发。申请完毕，并成功后，登录到公众号后台，左侧有丰富的菜单供你使用，可以选择傻瓜式，就是不用写一行代码，通过在左侧菜单配置，自己填写欢迎语，给用户发消息等，也可以选择开发者模式，在左侧最下面。<br>申请好后，当然是第一时间关注这个公众号，成为自己的第一个粉丝。</p><h2 id="开始撸代码"><a href="#开始撸代码" class="headerlink" title="开始撸代码"></a>开始撸代码</h2><p>在撸代码前，要明白公众号和用户打交道的流程，下图简单展示了这个流程。<br><img src="/images/wx-dev.jpg" alt="微信开发流程"><br>我们要开发的，就是这个回调地址，也可以说是自己的服务，简单点的话，就是一个php脚本。接收微信后台转发过来的请求。回调地址必须是微信后台可以访问的，也就是一个外网地址，你拿个内网ip肯定是不行的。所以你得有一台有外网IP的服务器，可以去买个阿里云，腾讯云，京东云等。申请好后，装个lnmp全家桶吧，开启nginx服务，在web目录，写个main.php，main.php中的代码如下所示，这段代码也可以在<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319" target="_blank" rel="noopener">微信wiki</a>上找到。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSignature</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        $signature = $_GET[<span class="string">'signature'</span>];</span><br><span class="line">        $nonce = $_GET[<span class="string">'nonce'</span>];</span><br><span class="line">        $timestamp = $_GET[<span class="string">'timestamp'</span>];</span><br><span class="line">  </span><br><span class="line">        $arr = [$timestamp, $nonce, TOKEN];</span><br><span class="line">  </span><br><span class="line">        sort($arr);            </span><br><span class="line"></span><br><span class="line">        $arr = implode($arr);</span><br><span class="line"></span><br><span class="line">        $m_arr = sha1($arr);</span><br><span class="line">        <span class="keyword">if</span>($m_arr == $signature) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (checkSignature()) &#123;</span><br><span class="line">        $echostr = $_GET[<span class="string">'echostr'</span>];</span><br><span class="line">        <span class="keyword">if</span>($echostr) &#123;</span><br><span class="line">                <span class="keyword">echo</span> $echostr;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在微信后台配置回调地址，配置方法如<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5" target="_blank" rel="noopener">微信wiki</a>。<br>填好这个main.php的url,按微信提示的步骤测试回调，点击提交，如果提示成功，则说明微信后台访问到了你的地址，并认证成功，如果失败，则检查下你的代码吧。认证成功后，就可以把上面的代码删了，再写自己的服务。</p><h2 id="一个简单的天气、点歌、新闻查询服务"><a href="#一个简单的天气、点歌、新闻查询服务" class="headerlink" title="一个简单的天气、点歌、新闻查询服务"></a>一个简单的天气、点歌、新闻查询服务</h2><p>首先写一个天气查询服务，就是你给公众号发一个城市名，公众号给你返回该城市未来三天的天气。为了简单，我用的是<a href="https://www.seniverse.com/doc" target="_blank" rel="noopener">心知天气</a>提供的天气api。我们分两步来进行</p><h3 id="1、获得用户输入的城市名"><a href="#1、获得用户输入的城市名" class="headerlink" title="1、获得用户输入的城市名"></a>1、获得用户输入的城市名</h3><p>由上图我们知道，用户的输入，最终会由微信后台转发给我们，微信后台转发给我们的数据格式如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1348831860<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>因此，在main.php里，首先要获得这个数据，需要注意的是，如果PHP版本是5.x，可以直接使用<code>$GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;]</code>超全局变量来获得，如果是PHP7，<code>$GLOBALS</code>已经被取消，需要用下列方式来获取<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$wx_post = file_get_contents(<span class="string">"php://input"</span>)</span><br></pre></td></tr></table></figure></p><p>然后就是解析xml数据了，提取各类数据，如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$postObj = simplexml_load_string($wx_post, <span class="string">'SimpleXMLElement'</span>, LIBXML_NOCDATA);</span><br><span class="line">$fromUsername = $postObj-&gt;FromUserName;</span><br><span class="line">$toUsername = $postObj-&gt;ToUserName;</span><br><span class="line">$user_city = trim($postObj-&gt;Content);  <span class="comment">//提取用户发送的城市名</span></span><br></pre></td></tr></table></figure></p><h3 id="2、根据城市名，返回天气信息"><a href="#2、根据城市名，返回天气信息" class="headerlink" title="2、根据城市名，返回天气信息"></a>2、根据城市名，返回天气信息</h3><p>有了城市名，就可以通过api查询城市天气信息了，但有个问题需要解决：用户发的是中文，而通过api查询，需要的是城市的拼音，因此需要写一个中文-&gt;拼音的转换函数。在github上有很多这类项目，我用的是<a href="https://github.com/AlloVince/EvaPinyin" target="_blank" rel="noopener">这个</a>，查询完天气后，将数据简单解析，并封装成微信需要的格式，构造响应，假如要返回给微信的天气数据为<code>$weather_info</code>，那么代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$textTpl = <span class="string">"&lt;xml&gt;</span></span><br><span class="line"><span class="string">       &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">       &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">       &lt;CreateTime&gt;%s&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">       &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">       &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;</span></span><br><span class="line"><span class="string">       &lt;FuncFlag&gt;0&lt;/FuncFlag&gt;</span></span><br><span class="line"><span class="string">       &lt;/xml&gt;"</span>;</span><br><span class="line"><span class="keyword">return</span> sprintf($textTpl,$fromUsername,$toUsername,time(),$weather_info);</span><br></pre></td></tr></table></figure></p><p>如果没有错误，那么会看到下面的效果。<br><img src="/images/wx-weather.jpg" alt="天气查询"><br>如果微信返回类似“该公众号暂时无法提供服务”的提示，那就是说明你的代码有问题，检查下代码，或者看看nginx日志。一般都能找到原因。</p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>有了上面简单的实战，就可以再添加点其他功能，比如点歌、查快递，看新闻等，甚至是类似于小黄鸡的机器人，最终把公众号打造成一个万事通吧~</p><p>以上代码放在<a href="https://github.com/hbxjw119/weixin" target="_blank" rel="noopener">github</a>上，自行查看和扩展。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公众号 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 zsh，重新打造你的 Linux 工作环境</title>
      <link href="//2017/06/20/linux-zsh.html"/>
      <url>//2017/06/20/linux-zsh.html</url>
      
        <content type="html"><![CDATA[<p>对于经常在 Linux 环境下干活的码农们，shell 可以说是我们使用频率最高的程序了，shell 为我们和机器间建立了一个桥梁，它给我们提供一系列命令，我们就可以和机器进行愉快的交流了，比如写代码用<code>vim</code>命令，查找文件使用<code>find</code>,<code>grep</code>命令，版本控制使用<code>git</code>，查看机器性能使用<code>top</code>，bash 就是 shell 的一种，也是 Linux 下的默认 shell 程序，现在让我们使用 zsh，重新打造一个更加人性化的 shell<br><a id="more"></a></p><h2 id="zsh-是什么"><a href="#zsh-是什么" class="headerlink" title="zsh 是什么"></a>zsh 是什么</h2><p>zsh属于 shell 的一种，和 bash 一样，但比 bash 更好用，zsh 完全兼容 bash，其强大的自动补全参数、文件名、以及自定义功能，可以提高我们的效率。</p><h2 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h2><p>说了这么多，让我们安装个 zsh 尝尝鲜吧，安装 zsh 灰常简单，centOS 用户，只用下面一条命令即可安装成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zsh</span><br></pre></td></tr></table></figure></p><p>看下系统现在有哪些shell可以用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure></p><p><img src="/images/zsh.jpg" alt="安装zsh成功"><br>可以看到，zsh 已经被正确安装了</p><h2 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h2><p>zsh 虽然好用，但配置起来还比较麻烦，不过幸运的是，已经有大神给我们配置好了一个很棒的框架：<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a>，我们只需要安装使用就可以了，一条命令搞定：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure></p><p>没有意外的话，你会看到下面这张图字样，说明 oh-my-zsh 已经安装好了<br><img src="/images/oh-my-zsh.jpg" alt="oh-my-zsh安装成功"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>接下来简单配置和学习下 oh-my-zsh 的使用方式，就可以愉快玩耍（带你装B带你飞）了</p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>首先设置下主题吧，oh-my-zsh 提供了很多主题，主题的配置文件在<code>~/.zshrc</code>文件中可以看到，找到下面这行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;robbyrussel&quot;</span><br></pre></td></tr></table></figure></p><p>可以将值改为其他类型，oh-my-zsh 的主题可以在<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">这里</a>找到，当然，如果你再狂野点，直接改为”random”也是可以的…以后每次登陆，都能换个不同的口味，下面是我个人用的<code>agnoster</code>主题。<br><img src="/images/agnoster.jpg" alt="agnoster主题"></p><h3 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h3><p>虽然 bash 下，tab 是一个好用的补全命令，但 oh-my-zsh 提供了更加强大的命令补全工具，很多时候，你只需要输入一条命令，然后按 tab，oh-my-zsh 就可以自动给你补全该条命令其他的参数，比如你想进入到nginx，输入<code>cd /u/l/n</code>，按下 tab，系统自动帮你补全这条命令，变为<code>cd /usr/local/nginx</code>，再比如，输入<code>git</code>，按两下 tab，系统给你返回关于 git 的一些其他命令，具体的功能，读者可以在使用中慢慢尝试。也可以通过<code>alias</code>命令，查看所有命令的别名。</p><h3 id="在目录中穿越"><a href="#在目录中穿越" class="headerlink" title="在目录中穿越"></a>在目录中穿越</h3><p>我们经常会遇到先进入一个很深的目录，然后又换到另一个目录下的情况，如果要返回之前的某个目录，还会使用到<code>history</code>去查找，不过有了<code>d</code>命令，就可以简化这个步骤。<code>d</code>命令会列出你最近进入的目录，然后只需要输入对应目录的序号，即可重新进入该目录，如下图所示，<code>d</code>命令列出了我最近进入的几个目录，其中序号为3的目录是我的 nginx 目录，直接输入3，立马跳到 nginx 所在目录<br><img src="/images/d.jpg" alt="目录跳转"></p><p>oh-my-zsh还提供很多其他便捷的跳转命令，比如<code>..</code>，等同于bash中<code>../</code>，<code>...</code>，等同于<code>../..</code>。所有的这些<br>当然目录跳转还可以有其他工具，比如<a href="https://github.com/wting/autojump" target="_blank" rel="noopener">autojump</a>，就是一个非常好用的跳转插件。</p><h3 id="关于-git"><a href="#关于-git" class="headerlink" title="关于 git"></a>关于 git</h3><p>用 git 的同学，会经常需要对写的代码进行<code>status</code>，<code>add</code>，<code>commit</code>等操作，以及审视git仓库的提交状态，oh-my-zsh 天生带有 git 插件，如下图<br><img src="/images/git.jpg" alt="git插件"><br>其中的 master 表示当前目录是 git 仓库，且是在 master 分支下，如果当前分支有文件改动，master 背景颜色就会变化，且后面的小图标也会对应改变，如下图所示<br>修改了文件，但没进行<code>add</code><br><img src="/images/git_not_add.jpg" alt="add"><br>添加到暂存区，等待提交<br><img src="/images/git_add.jpg" alt="等待提交"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上可以看出，zsh 配合 oh-my-zsh，可以大大方便我们在 Linux 下敲命令的任务，以上只是 zsh 很少的一部分，oh-my-zsh 还有很多插件和使用方法，等待大家去发掘。</p><p><strong>update at 2018-01-20</strong></p><p>发现一个强大的终端命令提示补全插件，具体安装使用看<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">这里</a><br>之前看某些视频时，发现相似的效果，但没去找，现在偶然找到了，果断使用，效果不错~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> zsh </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dokcer的一些使用方法</title>
      <link href="//2017/04/10/docker.html"/>
      <url>//2017/04/10/docker.html</url>
      
        <content type="html"><![CDATA[<p>上半年也陆续使用了docker工具做开发部署，使用的经验还比较浅显，看到屈屈大神写的一篇文章不错，特转载过来，并加了点自己的心得<br><a id="more"></a></p><h1 id="开始使用-Docker"><a href="#开始使用-Docker" class="headerlink" title="开始使用 Docker"></a>开始使用 Docker</h1><p>一年前，我在《<a href="https://imququ.com/post/vagrantup.html" target="_blank" rel="noopener">开始使用 Vagrant</a>》一文中写到：使用虚拟化软件安装 Linux，有着「统一线下线上环境、不受升级宿主系统的影响、容易备份和恢复」等几大优点，非常适用于搭建 WEB 开发环境。</p><p>但 Vagrant 这种依赖 VirtualBox/VMWare/Parallels Desktop 等软件虚拟完整操作系统的方案有几个硬伤，例如占用大量系统资源、新建或启动虚拟机不够迅速等。Docker 是操作系统级虚拟化，它虚拟出来的环境一般被称为 Docker 容器，而不是虚拟机。Docker 容器直接运行在宿主系统的操作系统内核之上，启动一个新的 Docker 容器能在秒级完成。<!--more--></p><p>由于 Docker 轻量、快速和高效，除了用于搭建开发环境，Docker 容器也非常适合用来部署线上服务。最近我将本博客程序改用 Docker 部署，你现在看到的页面正是由 Docker 容器提供服务。本文介绍这一过程。</p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p><a href="https://www.docker.com/products/overview#/install_the_platform" target="_blank" rel="noopener">Docker 官方文档</a>详尽地列出了各个系统下的 Docker 安装说明，请直接点过去看，本文不做搬运。</p><p>对于 Windows/Mac 用户而言，推荐安装 Docker for Window/Mac，而不是 Docker Toolbox。前者可以直接利用宿主系统的虚拟化机制，拥有更好的性能；后者需要借助 VirtualBox 运行的 linux虚拟机。</p><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>Docker 基于 Docker 镜像运行容器，通常我们所需大部分镜像都可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a> 找到。</p><p>在装好 Docker 的终端中，运行以下命令就可以启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu uname -a</span><br></pre></td></tr></table></figure><p>不出意外，可以看到这样的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image &apos;ubuntu:latest&apos; locally</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">2f0243478e1f: Pull complete</span><br><span class="line">d8909ae88469: Pull complete</span><br><span class="line">820f09abed29: Pull complete</span><br><span class="line">01193a8f3d88: Pull complete</span><br><span class="line">Digest: sha256:8e2324f2288c26e1393b63e680ee7844202391414dbd48497e9a4fd997cd3cbf</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br><span class="line">Linux 99bebffc2678 4.4.16-moby #1 SMP Tue Aug 9 17:20:17 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p><code>docker run</code> 命令用来从指定镜像启动容器。由于我本地没有 ubuntu 镜像，Docker 首先会从官方 Hub 下载它；然后启动容器并执行 <code>uname -a</code> 命令。这个命令是在 Docker 容器内执行，输出的是容器系统信息。</p><p>查看和管理 Docker 镜像及容器，主要有这些命令：</p><ul><li><code>docker images</code>：查看本地已经存在的镜像，<code>-a</code> 列出所有（默认不包括中间镜像）；</li><li><code>docker rmi IMAGE</code>：删除指定的镜像，<code>-f</code> 强制删除，IMAGE为：resository:tag，  也可以通过image id删除；</li><li><code>docker ps</code>：查看运行中的 Docker 容器，<code>-a</code> 列出所有（默认不包括未运行的容器）；</li><li><code>docker rm CONTAINER</code>：删除指定的容器，<code>-f</code> 强制删除；<br>注意，当用<code>docker rmi  images</code>命令，如果镜像已经生成过容器，不管容器是不是在运行中，则都无法删除，需要先将容器删除，才可以删镜像。</li></ul><p>使用 Docker 的最佳实践是保持职责单一，一个容器只提供一个服务。我的博客主要有这些服务：</p><ul><li>Nginx（80/443）；</li><li>MySQL（3306）；</li><li>Memcached（11211）；</li><li>ElasticSearch（9200）；</li><li>ThinkJS（8085）；</li></ul><p>考虑到我经常折腾 Nginx，我选择把它留在宿主系统，剩余四个服务则改用 Docker 容器来运行。</p><p>当然如果要运行一个Nginx容器也简单，有几点注意：由于Nginx需要对外提供web服务，启动时，肯定要绑定端口，方式是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run nginx:tag -it -P --name webserver</span><br></pre></td></tr></table></figure></p><p>其中<code>-P</code>表示自动绑定端口，要想访问到该容器的Nginx，访问方式是本地的servername加被绑定到的端口<br>如上面所示，我启动了一个Nginx，绑定的本机的32771端口到容器的80端口，因此我的访问方式是<a href="http://servername:32771" target="_blank" rel="noopener">http://servername:32771</a></p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>我需要的 Mysql、Memcache、ElasticSearch 容器都可以使用官方镜像来运行。但我的博客系统，使用官方 Node.js 镜像存在两个问题：1）官方镜像中的 npm 是 v2，我希望换成 v3；2）官方镜像没有 libvips 库，无法安装本博客程序所依赖的 sharp npm 包。</p><p>遇到这种情况，可以在 Docker Hub 看看有无第三方 Docker 镜像能够满足需求，也可以构造自己的镜像。我选择后者。</p><p>要构建自己的 Docker 镜像，一般都会选定一个已有的镜像做为基础，再在上面增加自己的修改。我的 DockerFile 如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> marcbachmann/libvips</span><br><span class="line"><span class="keyword">MAINTAINER</span> quguangyu@gmail.com</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 修改时区</span></span></span><br><span class="line"><span class="bash">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装依赖</span></span></span><br><span class="line"><span class="bash">RUN apt-get install -y \</span></span><br><span class="line"><span class="bash">  python \</span></span><br><span class="line"><span class="bash">  curl \</span></span><br><span class="line"><span class="bash">  build-essential</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装 Node.js v4.x.x LTS</span></span></span><br><span class="line"><span class="bash">RUN curl -sL https://deb.nodesource.com/setup_4.x | bash -</span></span><br><span class="line"><span class="bash">RUN apt-get install -y nodejs</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装 npm v3 和 pm2</span></span></span><br><span class="line"><span class="bash">RUN npm install -g npm@3 pm2</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 解决 npm 在 docker 下经常 rename 失败的问题。详见：</span></span></span><br><span class="line"><span class="bash"><span class="comment"># https://forums.docker.com/t/npm-install-doesnt-complete-inside-docker-container/12640/3</span></span></span><br><span class="line"><span class="bash">RUN <span class="built_in">cd</span> $(npm root -g)/npm \</span></span><br><span class="line"><span class="bash">  &amp;&amp; npm install fs-extra \</span></span><br><span class="line"><span class="bash">  &amp;&amp; sed -i -e s/graceful-fs/fs-extra/ -e s/fs\.rename/fs.move/ ./lib/utils/rename.js</span></span><br></pre></td></tr></table></figure><p>这份 DockerFile 作用是在 <code>marcbachmann/libvips</code> 镜像上增加了我需要的 Node.js，将 npm 升级到了 v3，还安装了 pm2。</p><p>在 DockerFile 所在目录，执行以下命令就可以构建镜像，并将其推送至 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>（这里略过注册和登录过程）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t qgy18/node .</span><br><span class="line">docker push qgy18/node</span><br></pre></td></tr></table></figure><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>Docker Compose 是一个小工具。我们可以在一个文件里定义多个容器，使用 <code>docker-compose</code> 命令让它们全部运行就绪。Docker Compose 非常适合用来部署 WEB 系统这种需要多个容器配合工作的服务。</p><p>如果你使用的是 Docker for Windows/Mac，<code>docker-compose</code> 命令应该直接可用。对于 Linux 平台，请参考<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">官方文档</a>安装 Docker Compose。</p><p>当前，我的博客系统目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── blog</span><br><span class="line">│   ├── app</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   ├── package.json</span><br><span class="line">│   ├── pm2.json</span><br><span class="line">│   ├── view</span><br><span class="line">│   └── www</span><br><span class="line">├── db</span><br><span class="line">│   ├── ...</span><br><span class="line">│   ├── ququ_blog</span><br><span class="line">│   └── sys</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── esroot</span><br><span class="line">│   ├── config</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── plugins</span><br><span class="line">└── shell</span><br><span class="line">    ├── backup_blog_database.sh</span><br><span class="line">    └── install_blog_package.sh</span><br></pre></td></tr></table></figure><p>我将所有需要持久化存储的文件都放在了宿主系统，例如代码目录（blog），数据库文件（db），ElasticSearch 配置、插件及数据文件（esroot）。这样数据更加安全，也更易于管理。</p><p>shell 目录下的 <code>install_blog_package.sh</code> 用来安装博客 npm 依赖，我的宿主系统没有安装 Node.js，运行 <code>npm install</code> 也需要借助 Docker 容器，一行命令搞定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v "$PWD/../blog":/app -w "/app" qgy18/node npm install --registry=http://registry.npm.taobao.org --production</span><br></pre></td></tr></table></figure><p>这行命令首先基于前面构建好的镜像运行了一个拥有 Node.js 和 npm3 的容器；然后将宿主系统的 <code>blog</code> 目录映射为容器的 <code>/app</code> 目录；再将容器的工作目录设置为 <code>/app</code>；最后执行 <code>npm install</code> 安装依赖。最为神奇的是，由于指定了 <code>--rm</code> 参数，这个容器在完成工作之后就会被彻底销毁，不留任何痕迹。</p><p>类似的，由于宿主系统不再需要安装 MySQL，备份数据库也需要在容器内完成，这时候可以使用 <code>docker exec</code> 命令在已经运行的容器内执行指令。以下是 <code>backup_blog_database.sh</code> 文件的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec imququ_db mysqldump -uroot -p****** ququ_blog | gzip &gt; ../backup/ququblog.`date +%H`.sql.gz</span><br></pre></td></tr></table></figure><p><code>docker-compose.yml</code> 文件内容如下，它定义了每个容器基于什么镜像运行，映射哪些目录，开放哪些端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  es:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">elasticsearch:2.3.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">imququ_es</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./esroot/data/:/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./esroot/config/:/usr/share/elasticsearch/config</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./esroot/plugins/:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9200"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">memcached:1.4.29</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">imququ_cache</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"11211"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:5.7.14</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">imququ_db</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"./db:/var/lib/mysql"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">******</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3306"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"127.0.0.1:3306:3306"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  blog:</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cache</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">qgy18/node</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">imququ_blog</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./blog:/app</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    working_dir:</span></span><br><span class="line">      <span class="string">/app</span></span><br><span class="line"><span class="attr">    entrypoint:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">pm2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">start</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">pm2.json</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--no-daemon</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - es:</span><span class="string">es</span></span><br><span class="line"><span class="attr">      - cache:</span><span class="string">cache</span></span><br><span class="line"><span class="attr">      - db:</span><span class="string">db</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"127.0.0.1:8085:8085"</span></span><br></pre></td></tr></table></figure><p>在 blog 容器中，我通过 <code>links</code> 配置连接了前面几个容器。这样在代码中，就可以使用 <code>es</code> 做为 HOST 连接到 Elasticsearch 容器，使用 <code>db</code> 做为 HOST 连接到 MySQL，依此类推。</p><p>我定义了 db 容器的 <code>ports</code> 配置，将宿主系统的 3306 端口映射到了 db 容器内，这样我就可以在宿主系统管理 MySQL 服务。同样地，使用宿主系统的 8085 端口可以访问到 blog 容器提供的 WEB 服务。</p><p>通过 <code>docker-compose up -d</code> 命令就可以在后台启动所有容器。<code>docker ps</code> 可以用来查看各个容器的运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMAGE                 COMMAND                  PORTS                      NAMES</span><br><span class="line">qgy18/node            &quot;pm2 start pm2.json -&quot;   127.0.0.1:8085-&gt;8085/tcp   imququ_blog</span><br><span class="line">elasticsearch:2.3.0   &quot;/docker-entrypoint.s&quot;   9200/tcp, 9300/tcp         imququ_es</span><br><span class="line">mysql:5.7.14          &quot;docker-entrypoint.sh&quot;   127.0.0.1:3306-&gt;3306/tcp   imququ_db</span><br><span class="line">memcached:1.4.29      &quot;docker-entrypoint.sh&quot;   11211/tcp                  imququ_cache</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://imququ.com/post/use-docker.html" target="_blank" rel="noopener">https://imququ.com/post/use-docker.html</a>，<a href="https://imququ.com/post/use-docker.html#comments" target="_blank" rel="noopener">前往原文评论 »</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几条比较好用又经常忘记的 shell 命令</title>
      <link href="//2017/01/16/linux-command.html"/>
      <url>//2017/01/16/linux-command.html</url>
      
        <content type="html"><![CDATA[<p>linux命令行中，最常用的命令就那么几条，有时写了长长的一条命令，发现写错、漏写，想移动光标，如果直接按←，→，不仅慢，还不能体现出我们作为linux老鸟的优（zhuang）雅（bi），因此记下几个比较好用的命令，以作备忘<br><a id="more"></a></p><ul><li><p>ctrl + u – 剪切当前行内容<br>这个命令很有用，假如你在终端输入一个很长的命令，想删掉，一个一个字删除就很慢了，直接用ctrl+u搞定吧~</p></li><li><p>ctrl + r — 在历史命令中查找<br>也强烈推荐，有时想输入之前的某条命令，以前做法是 <code>history | grep command</code>，现在直接用ctrl + r，然后输入关键字，shell就自动给你搜索包含关键字的命令了。</p></li><li><p>ctrl + k – 剪切光标至行末的内容</p></li><li><p>ctrl + k – 粘贴</p></li><li><p>ctrl + e – 移动光标到行末</p></li><li><p>ctrl + a – 移动光标到行首</p></li><li><p>alt + f – 跳向下一个空格</p></li><li><p>alt + b – 跳回上一个空格</p></li><li><p>alt + Backspace – 删除前一个单词</p></li><li><p>ctrl + w – 剪切光标后一个单词</p></li><li><p>Shift + Insert – 向终端内粘贴文本</p></li><li><p>ctrl + l - 清屏</p></li><li><p>ctrl + d – 登出，替代exit或者logout命令</p></li><li><p>!num - 执行历史命令列表中的第num条命令</p></li></ul><h3 id="2017-12-13-添加："><a href="#2017-12-13-添加：" class="headerlink" title="2017-12-13 添加："></a>2017-12-13 添加：</h3><p>由于换了mac,没有win下的xshell终端连接神器了，只能用iTerm2之类的代替，这里也补上iTerm2的快捷键吧</p><ul><li><p>⌘ + d - 横着分屏 / ⌘ + shift + d 竖着分屏</p></li><li><p>⌘ + t - 新建标签</p></li><li><p>⌘  + w - 关闭标签</p></li><li><p>⌘  + 数字/方向键 - 切换标签</p></li><li><p>⌘  + ; - 查看历史命令</p></li><li><p>⌘  + d - 水平分屏</p></li><li><p>⌘  + option + 方向键 - 切换屏幕</p></li></ul><p>虽然有一系列快捷键，但总觉得没有xshell爽，试着适应吧</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 Cookie 和 Session 的几点问题</title>
      <link href="//2017/01/11/cookie-session.html"/>
      <url>//2017/01/11/cookie-session.html</url>
      
        <content type="html"><![CDATA[<p>咱做 web 开发的，任何时候都少不了要和 Cookie 以及 Session 打交道，我们平时主要用他们来实现用户的登陆和用户的信息存储。说到 Cookie 和 Session，我们一般会很简单地想到他们一个是客户端的存储机制，一个是服务器端的存储机制。然而，事实是否真的仅仅是这样的呢？<br><a id="more"></a></p><p>在聊之前，我们先一起思考如下几个问题：</p><ol><li>我们一般认为 Cookie 运行在客户端而 Session 运行在服务器端，所以当我们关闭浏览器（即将客户端和服务器端的链接断开）时，Session 一般就消失了而 Cookie 可以保留。这是真的吗？</li><li>浏览器禁止 Cookie，Cookie 就不能用了，但 Session 不会受到影响，这是真的吗？</li><li>Session 是否真的比 Cookie 更加安全呢？</li><li>我们发现，使用 IE 登陆腾讯网后，在同一台机子上使用 Firefox 打开腾讯的页面，发现已经有了登陆的状态，那么是否说明 Cookie 可以在不同浏览器之间共享呢？</li><li>如果把别人的 Cookie 复制到我的电脑上，假设我使用一样的浏览器，那么我是否可以直接登陆别人的账号呢？</li></ol><h2 id="什么是-Cookie？"><a href="#什么是-Cookie？" class="headerlink" title="什么是 Cookie？"></a>什么是 Cookie？</h2><p>cookie 是存储在客户端的一小段数据，客户端通过 HTTP 协议和服务器端进行 Cookie 交互。也就是说，Cookie 独立于任何语言存在，无论 PHP，JSP，ASP下的 Cookie，都是一样的，因为他们都能被 JavaScript 这种客户端脚本读取到。PHP 之类的语言通过发送 HTTP 指令，通过浏览器等客户端实现对 Cookie 的操作，其本身是无法设置或操作 Cookie 的。<br>Cookie 主要是参照 RFC2109 标准由客户端实现生成，使用等整个过程，服务器端则参照此标准实现和客户端之间的交互指令。<br>我们都知道 PHP 设置 Cookie 的函数 setcookie()。<br>我们来看看其在C解释器中的函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">setcookie</span><span class="params">(<span class="built_in">string</span> $name[,<span class="built_in">string</span> $value[,<span class="keyword">int</span> $expire = <span class="number">0</span>[,<span class="built_in">string</span> $path[,<span class="built_in">string</span> $domain[,<span class="keyword">bool</span> secure = <span class="literal">false</span>[,<span class="keyword">bool</span> $httponly = <span class="literal">false</span>]]]]]])</span></span></span><br></pre></td></tr></table></figure></p><p>对 web 开发有了解的朋友应该是很熟悉前面几个参数的，即 cookie 对应的键，值，有效时间，有效目录，作用域名。<br>对于第六个参数 $secure，它主要是用来设置是否对 cookie 进行加密传输，默认为 false，若设置为 ture，则只有在使用 HTTPS 的情况下，这个 cookie 才可以被设置。<br>第七个参数 $httponly，设置是否只使用 HTTP 访问cookie，若设置为 true，则客户端脚本（如JavaScript）将无法访问该 cookie，这个参数一定程度上可以降低 XSS 攻击的风险，但注意不是所有浏览器都支持该参数，而且只在PHP5.2.0以上版本有效。<br>好，现在让我们看一段PHP代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $cookie_1 = setcookie(<span class="string">"cookie1"</span>,<span class="string">"jimmy"</span>,time()+<span class="number">3600</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="number">1</span>);  </span><br><span class="line">    $cookie_2 = setcookie(<span class="string">"cookie2"</span>,<span class="string">"home"</span>);  </span><br><span class="line">    <span class="keyword">if</span>($cookie_1 &amp;&amp; $cookie_2)  </span><br><span class="line">       print_r($_COOKIE);</span><br></pre></td></tr></table></figure></p><p>直接在浏览器运行这个脚本，我们发现显示了一个空数组array()<br>而刷新一下页面，显示如下图：<br><img src="/images/cookie-session/cookie.jpg" alt="cookie"><br>这说明PHP在当前页设置的 cookie 不是立即生效的，需要等到下一个页面才能生效。这是由于设置在这个页面里的 cookie 命令由服务器传递给客户端浏览器，需要到下一个页面，即下一次连接，浏览器才能把 cookie 从机器里取出传递回服务器。但注意 JavaScript这类客户端脚本设置的 Cookie 是立即生效的。<br>然后，我们在控制台通过 JavaScript 获取 cookie，我们可以清楚地看到 js 只能获取到 cookie2，这是因为 cookie1 把 httponly 设置成了 ture，从而屏蔽了 js 脚本对 cookie 的读取。</p><h2 id="我们下面来聊聊-cookie-的存储机制。"><a href="#我们下面来聊聊-cookie-的存储机制。" class="headerlink" title="我们下面来聊聊 cookie 的存储机制。"></a>我们下面来聊聊 cookie 的存储机制。</h2><p>前面说到，cookie 是保存在客户端的一小段数据，那么它究竟保存在哪呢？<br>有两种情况，一种是保存在文件中，一种是保存在浏览器内存中。<br>对于第一种情况，不同浏览器有不同的管理机制，比如 IE 保存在每个域名下的文本文件，而 Firefox 和 Chrome 在 SQLite 数据库中进行管理。我们现在分别就第一，第二种情况进行一些讨论。<br>选择 Chrome开发者工具中的 Application，如下图<br><img src="/images/cookie-session/cookie-save.jpg" alt="cookie存储"><br>可以看到刚刚生成的两条 cookie。<br>现在重启浏览器，再次查询<br><img src="/images/cookie-session/cookie-second.jpg" alt="重启浏览器后的cookie"><br>我们发现 cookie1 还在而 cookie2 不见了，这是因为我们在设置 cookie 参数时把失效时间设置为空，也就是当浏览器关闭时失效，这时 cookie 存储在内存中，当 Chrome 进程终止，其系统资源被回收，这时存储于内存中的 cookie 自然也就被注销了。很容易理解，我们如果重新运行 PHP 脚本则 Cookie1 和 Cookie2 都会重新生成。</p><p>再用其他的浏览器，打开cookie管理器，会发现只有缓存文件而没有cookie。现在理解了吧，cookie是由浏览器等客户端完全独立管理的。因为不同浏览器的Cookie管理机制不同，所以cookie不可能在浏览器之间共享。对于第四个问题，其实是因为我们在安装腾讯QQ时自动安装了针对不同浏览器的插件，可以识别已经登陆的QQ号码而自动登陆。朋友们可以试试把QQ完全卸载再从网页登陆腾讯网，哈哈，所以这和Cookie共享是完全没有任何关系的。<br>刚刚聊到存在内存中的Cookie，有的朋友可能会问，这不就是Session么？关闭浏览器就失效。</p><h2 id="Session又是什么呢？"><a href="#Session又是什么呢？" class="headerlink" title="Session又是什么呢？"></a>Session又是什么呢？</h2><p>从性质上讲，Session即回话，指一种持续性的，双向的连接。对于web而言，Session指用户在浏览某个网站时，从进入网站到浏览器关闭这段时间的会话。所以，Session实际上是一个特定的时间概念。</p><h3 id="Session是如何工作的呢？"><a href="#Session是如何工作的呢？" class="headerlink" title="Session是如何工作的呢？"></a>Session是如何工作的呢？</h3><p>我们知道Session是用来存储客户端状态信息的，Session通过一个称为PHPSESSID的Cookie和服务器联系。Session是通过sessionID判断客户端用户的，即文件的文件名。php开启一个Session很简单，如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br></pre></td></tr></table></figure></p><p>刷新浏览器，如下，可以看到有个叫PHPSESSID的Cookie。<br><img src="/images/cookie-session/session.jpg" alt="img"></p><p>SessionID实际上是在客户端和服务器端之间通过HTTP Request和HTTP Response传来传去。sessionID按照一定算法生成，必须包含在HTTP Request里面，保证唯一性和随机性，以确保Session的安全。</p><h3 id="那么是不是关闭了浏览器，所有Session就都被注销了呢？"><a href="#那么是不是关闭了浏览器，所有Session就都被注销了呢？" class="headerlink" title="那么是不是关闭了浏览器，所有Session就都被注销了呢？"></a>那么是不是关闭了浏览器，所有Session就都被注销了呢？</h3><p>如果没有设置Session的生命周期，则SessionID存储在内存中，此时关闭浏览器Session自动注销。而我们已经知道，sessionID是通过PHPSESSID这个Cookie存储在本地的。那么在浏览器不禁用Cookie的前提下，当然可以通过setcookie()或者seession_set_cookie_params()函数设置Session的生存期，Session过期后，PHP会对其进行回收。所以，Session并非都是随着浏览器的关闭而消失的。</p><p>当然，如果你的浏览器禁用Cookie，那么所有所有Session的生存周期都是浏览器进程，关闭浏览器，再次请求页面又将重新生成Session。不过我们也有其他办法进行sessionID的传递，比如URL传参，但是这种方式极度危险，强烈不推荐。此外，还可以通过修改php.ini的session.use_trans_sid参数，实现连接时自己自己添加Session的ID这个在这里暂时不做讨论了，大家想玩就自己尝试吧。</p><p>好了，那么现在对于文章开头的几个问题，大家应该都有自己的答案了吧？</p><p>第一个问题，虽然Session的确是运行在服务器的，但是sessionID却通过Cookie保存在客户端，所以也不尽然。</p><p>第二题，禁止了Cookie，页面的SessionID将无法使用PHPSESSID进行传递，大家可以先登陆某一网站，然后删除浏览器数据，会发现刷新页面或切换页面后将丢失登陆状态，当然我们可以用其他方式替代Cookie进行Session传值，但是很明显，Session会受Cookie禁用的影响。</p><p>第三题，存在本地的 Cookie 确实存在一些不安全因素，但是没人会把安全验证完全放在前端，而且我们知道一般 Session 是通过 sessionID 和 Cookie 进行绑定的，客户端的 Cookie 一旦被劫持就相当与 Session 被劫持，服务器验证 Cookie 的同时将原封不动地完成对Session的验证，所以Session比Cookie安全纯属无稽之谈。</p><p>第四题前面讨论过，这里不废话了</p><p>第五题，原则上讲是可行的，我们将其称为 Cookie 劫持，然而我们可以通过在 Cookie 中加入基于IP等特定信息的参数优化 Cookie 的验证过程，从而避免这一危险。</p><p>转载自：<a href="http://blog.csdn.net/hjtl1992/article/details/26006867" target="_blank" rel="noopener">http://blog.csdn.net/hjtl1992/article/details/26006867</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP中的自动加载</title>
      <link href="//2017/01/08/php-autoload.html"/>
      <url>//2017/01/08/php-autoload.html</url>
      
        <content type="html"><![CDATA[<p>对于21世纪的phper来说，应该或多或少听说过<strong>自动加载器</strong>。自动加载，就是我们在new一个class前，不需要写require来包含这个class文件，由程序自动帮我们加载进来。<br><a id="more"></a></p><p><strong>自动加载器</strong>可以说现代PHP框架的根基，基本著名的框架或者架构都会用到它。它解决了什么问题呢？就是当项目很大时，不需要再一个一个require文件。在我们安装某个PHP框架或者包时，在下载的vendor目录下，很可能会有一个叫auto_load.php的文件。追踪源码下去，基本都会看到一个叫<code>spl_auto_register</code>的函数。这个函数做的事情就是你之前需要一个一个require的事情。</p><h2 id="先来看个简单的例子"><a href="#先来看个简单的例子" class="headerlink" title="先来看个简单的例子"></a>先来看个简单的例子</h2><p>如果你写了一个index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$db = <span class="keyword">new</span> DB();</span><br></pre></td></tr></table></figure></p><p>如果不导入DB类，则可能会报一个class not found的错误，那我们再写个函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$db = <span class="keyword">new</span> DB();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> $className;</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述的<code>_autoload($class_name)</code> 是PHP5.2版本后加入的魔术函数，他接收的参数是类名，有了这个函数，当PHP在找不到DB类，在报错前，会调用这个函数，上面传入的参数就是DB。因此上述代码会输出DB。<br>由此，我们可以在_autoload函数中，写要加载的类文件了。如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">require</span> $className . <span class="string">'.php'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然前提是你事先已经写了这个类，并且也放在了当前目录。</p><h2 id="spl-autoload-register的产生"><a href="#spl-autoload-register的产生" class="headerlink" title="spl_autoload_register的产生"></a>spl_autoload_register的产生</h2><p>当项目小时，可以把所有的类文件放在一个目录下面，然后在_autoload函数中，指定这个类库目录。但如果项目过大，或者需要不同的自动加载来加载不同路径的文件，这个时候_autoload就无法胜任，原因是一个项目中仅能有一个这样的 _autoload() 函数，因为 PHP 不允许函数重名，也就是说你不能声明2个_autoload()函数文件，否则会报致命错误，那怎么办呢？放心，你想到的，PHP开发大神早已经想到。</p><p><code>spl_autoload_register()</code>这样又一个牛逼函数诞生了，并且取而代之它。它执行效率更高，也更灵活</p><p>他的使用方式，要比_autoload函数要复杂得多。而且，该函数也是可以重复使用的。如果一个文件有多个该函数，则按照注册顺序，一个一个往下面找。<br>这里就不介绍spl_autoload_register函数的使用了，这个在大型的PHP框架中，都可以找到它的影子，也是学习自动加载的好机会。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP中的依赖注入是什么东西</title>
      <link href="//2017/01/02/php-di.html"/>
      <url>//2017/01/02/php-di.html</url>
      
        <content type="html"><![CDATA[<p>设计模式中，有一个叫控制反转（Inversion of Control），也叫依赖注入(Dependency Injection)，这种设计模式用来减少程序间的耦合，这篇文章不讲解概念性的东西，直接上代码，如果要深追理论，要看设计模式一书<br><a id="more"></a></p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>某网站在注册完后，要给用户发封邮件，发邮件的逻辑，你可以这么写：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Email.class.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//发送邮件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后有一个注册的类<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register.class.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> $_email;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//注册逻辑</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;_email = <span class="keyword">new</span> Mail();</span><br><span class="line"><span class="keyword">$this</span>-&gt;_email-&gt;send();  <span class="comment">//发邮件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后有用户开始注册了<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">'Email.class.php'</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">'Register.class.php'</span>;</span><br><span class="line">$reg = <span class="keyword">new</span> Register();</span><br><span class="line">$reg-&gt;doRegister();</span><br></pre></td></tr></table></figure></p><p>很快把这个功能上线了，看起来相安无事，xxx天过后，产品说发送邮件的不好，要使用发送短信的，然后你说这简单我把’Mail’类改下…</p><p>又过了几天，产品人员说发送短信费用太高，还是改用邮件的好…  此时心中一万个草泥马奔腾而过…</p><p>以上场景的问题在于，你每次不得不对’Mail’类进行修改，代码复用性很低，高层过度依赖于底层。那么我们就考虑<strong>依赖倒置原则，让底层继承高层制定的接口，高层依赖于接口</strong>。修改后的逻辑如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将mail写为接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Mail</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Email implements Mail()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//发送Email</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class SmsMail implements Mail()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//发送短信</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_mailObj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Mail $mailObj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_mailObj = $mailObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doRegister</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*这里是如何注册*/</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_mailObj-&gt;send();<span class="comment">//发送信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始发送信息<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 此处省略若干行 */</span><br><span class="line">$reg = <span class="keyword">new</span> Register();</span><br><span class="line">$emailObj = <span class="keyword">new</span> Email();</span><br><span class="line">$smsObj = <span class="keyword">new</span> SmsMail();</span><br><span class="line"></span><br><span class="line">$reg-&gt;doRegister($emailObj);<span class="comment">//使用email发送</span></span><br><span class="line">$reg-&gt;doRegister($smsObj);<span class="comment">//使用短信发送</span></span><br><span class="line"><span class="comment">/* 你甚至可以发完邮件再发短信 */</span></span><br></pre></td></tr></table></figure></p><p>上面的代码解决了’Register’对信息发送类的依赖，使用构造函数注入的方法，使得它只依赖于发送短信的接口，只要实现其接口中的’send’方法，不管你怎么发送都可以。上例就使用了”注入”这个思想，就像注射器一样将一个类的实例注入到另一个类的实例中去，需要用什么就注入什么。当然”依赖倒置原则”也始终贯彻在里面。</p><h2 id="再来看一个例子"><a href="#再来看一个例子" class="headerlink" title="再来看一个例子"></a>再来看一个例子</h2><p>假设我们这里有一个类，类里面需要用到数据库连接，按照最最原始的办法，我们可能是这样写这个类的<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> $_db;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="string">"./Lib/Db.php"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_db = <span class="keyword">new</span> Db(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"123456"</span>,<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_db-&gt;query(<span class="string">"......"</span>);<span class="comment">//这里具体sql语句就省略不写了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在构造函数里先将数据库类文件include进来；然后又通过new Db并传入数据库连接信息实例化db类；之后getList方法就可以通过$this-&gt;_db来调用数据库类，实现数据库操作。</p><p>看上去我们实现了想要的功能，但是这是一个噩梦的开始，以后example1,example2,example3….越来越多的类需要用到db组件，如果都这么写的话，万一有一天数据库密码改了或者db类发生变化了，岂不是要回头修改所有类文件？<br>ok，为了解决这个问题，工厂模式出现了，我们创建了一个Factory方法，并通过Factory::getDb()方法来获得db组件的实例：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getDb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="string">"./Lib/Db.php"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Db(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"123456"</span>,<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sample类变成：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> $_db;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_db = Factory::getDb();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_db-&gt;query(<span class="string">"......"</span>);<span class="comment">//这里具体sql语句就省略不写了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就完美了吗？再次想想一下以后example1,example2,example3….所有的类，你都需要在构造函数里通过Factory::getDb();获的一个Db实例，实际上你由原来的直接与Db类的耦合变为了和Factory工厂类的耦合，工厂类只是帮你把数据库连接信息给包装起来了，虽然当数据库信息发生变化时只要修改Factory::getDb()方法就可以了，但是突然有一天工厂方法需要改名，或者getDb方法需要改名，你又怎么办？当然这种需求其实还是很操蛋的，但有时候确实存在这种情况，一种解决方式是，我们不从example类内部实例化Db组件，我们依靠从外部的注入，什么意思呢？看下面的例子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_db;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_db-&gt;query(<span class="string">"......"</span>);<span class="comment">//这里具体sql语句就省略不写了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从外部注入db连接</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setDb</span><span class="params">($connection)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_db = $connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">$example = <span class="keyword">new</span> example();</span><br><span class="line">$example-&gt;setDb(Factory::getDb());<span class="comment">//注入db连接</span></span><br><span class="line">$example-&gt;getList();</span><br></pre></td></tr></table></figure></p><p>这样一来，example类完全与外部类解除耦合了，你可以看到example类里面已经没有工厂方法或Db类的身影了。我们通过从外部调用example类的setDb方法，将连接实例直接注入进去。这样example完全不用关心db连接怎么生成的了。<br>这就叫依赖注入，实现不是在代码内部创建依赖关系，而是让其作为一个参数传递，这使得我们的程序更容易维护，降低程序代码的耦合度，实现一种松耦合。</p><p>这还没完，我们再假设example类里面除了db还要用到其他外部类，我们通过：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$example-&gt;setDb(Factory::getDb());<span class="comment">//注入db连接</span></span><br><span class="line">$example-&gt;setFile(Factory::getFile());<span class="comment">//注入文件处理类</span></span><br><span class="line">$example-&gt;setImage(Factory::getImage());<span class="comment">//注入Image处理类</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>依赖注入也是现代PHP框架中广泛使用的思想，著名的Yii,Phalcon等框架中，都能找到依赖注入的影子</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://mengkang.net/790.html" target="_blank" rel="noopener">https://mengkang.net/790.html</a></li><li><a href="http://www.cnblogs.com/painsOnline/p/5138806.html" target="_blank" rel="noopener">http://www.cnblogs.com/painsOnline/p/5138806.html</a></li><li><a href="http://www.thinkphp.cn/topic/12180.html" target="_blank" rel="noopener">http://www.thinkphp.cn/topic/12180.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> design pattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>influxdb配合grafana的监控</title>
      <link href="//2016/12/21/influxdb-grafana.html"/>
      <url>//2016/12/21/influxdb-grafana.html</url>
      
        <content type="html"><![CDATA[<p>在大型公司，对于监管众多服务器的资源使用情况，是一项不可或缺的工作，随时了解每个服务器的运行状态，负载情况，对于发现线上问题，有着重要的参考价值。对于线上服务，监控和了解集群的工作状况，也是必不可少的环节。在机器监控方面，新兴的influxdb配合grafana，有如倚天屠龙，简单又好用。<br><a id="more"></a></p><h2 id="influxdb，grafana简介"><a href="#influxdb，grafana简介" class="headerlink" title="influxdb，grafana简介"></a>influxdb，grafana简介</h2><p>influxdb用Go语言编写的一个开源分布式时序、事件和指标数据库，和传统是数据库相比有不少不同的地方。首先它非常适合用于存储基于时序类的数据，这类数据有以下特点：</p><ul><li>数据量大，基于时序</li><li>很少有更新和删除操作</li></ul><p>因此，非常适合用于监控系统中的数据采集。</p><p>有了大量的数据，最好是可以把这些数据可视化的展示出来，这样我们可以观察数据的变化趋势，是升高还是降低。而且还要满足能动态的变化，如果有新的数据产生，则自动展示出来，不需要手动刷新。Grafana应运而生！</p><ul><li>grafana是用于可视化大型测量数据的开源程序，他提供了强大和优雅的方式去创建、共享、浏览数据。dashboard中显示了你不同metric数据源中的数据。</li><li>grafana最常用于因特网基础设施和应用分析，但在其他领域也有机会用到，比如：工业传感器、家庭自动化、过程控制等等。</li><li>grafana有热插拔控制面板和可扩展的数据源，目前已经支持Graphite、InfluxDB、OpenTSDB、Elasticsearch。<br>看下官方的demo<br><img src="/images/influxdb-grafana/grafana-demo1.png" alt="demo"></li></ul><p>是不是很酷炫！<br>个人觉得，grafana最大的好处就是，你只需要配置好数据源。不需要写一行代码，即可完成数据可视化。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>influxdb和grafana的安装灰常简单，在linux下(CentOS)，只要运行以下命令即可：<br>安装influxdb：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.1.1.x86_64.rpm</span><br><span class="line">sudo yum localinstall influxdb-1.1.1.x8664.rpm</span><br></pre></td></tr></table></figure></p><p>安装grafana：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://grafanarel.s3.amazonaws.com/builds/grafana-3.1.1-1470047149.x86_64.rpm</span><br><span class="line">sudo yum install initscripts fontconfig -y</span><br><span class="line">rpm -ivh grafana-3.1.1-1470047149.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>二者安装完毕后，就可以使用啦~</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="influxdb"><a href="#influxdb" class="headerlink" title="influxdb"></a>influxdb</h3><p>在使用之前，我们需要对软件简单做下配置，首先配置influxdb，influxdb1.1.1是默认不开启web端口查询的，需要打开，修改配置，在/etc/influxdb/influxdb.conf中，<br>找到[admin]，将下列的注释取消即可，如图<br><img src="/images/influxdb-grafana/influxdb-conf.png" alt="influxdb-conf"></p><p>修改完毕后，启动服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/influxdb start</span><br></pre></td></tr></table></figure></p><p>启动完毕后，即可在本机访问了influxdb了。直接命令行输入 influxdb，即可进入命令行模式<br><img src="/images/influxdb-grafana/influxdb-start.png" alt="influxdb-conf"><br>接下来的操作，就跟使用mysql一样了，如show databases，use testdb….和mysql有点不同的是，influxdb语句末尾要不要分号都无所谓。插入数据时，也只需要insert，而不需要insert into…由于influxdb是基于时序型的数据库，因此里面的每条数据都会有time这个字段，如果插入时不指定，则默认会用本机的unix时间戳。其他使用方法，请查看官方文档。</p><p>influxdb还提供了可视化的web端查询和插入。前提是你已经在配置中打开的了web端口的访问权限。直接在浏览器中输入你的主机名加端口，默认8083端口：<br><a href="http://127.0.0.1:8083" target="_blank" rel="noopener">http://127.0.0.1:8083</a><br><img src="/images/influxdb-grafana/influxdb-web.png" alt="influxdb-conf"></p><p>左上角的write data，直接可以写插入语句，query输入框，可以直接写查询语句，右上角选择数据库。使用起来，是不是很方便呢？</p><p>influxdb还提供了数据的失效性策略设置。选择一个数据库，命令行或者web界面，输入SHOW RETENTION POLICIES ON testdb，即可展示testdb数据库的策略情况，<br><img src="/images/influxdb-grafana/influxdb-rp.png" alt="influxdb-conf"></p><p>一个数据库可以有多条策略。每新建一个库，都会有一条称为autogen的默认策略，influxdb的数据实际是存在被称为shard的碎片中，在插入和查询数据时，也是根据策略名来操作的，如果你设置了多条策略，会有一条策略是默认的，当你查询和插入时，如果未指定策略，即访问的默认策略中的shard的数据。如果要查询其他策略中的数据，需要这样：SELECT * FROM “策略名”.表名。当然也可以修改默认策略为指定的策略。如ALTER RETENTION POLICY “策略名” ON “表名” DEFAULT。</p><p>关于influxdb的其他问题，可以查看官网</p><h3 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h3><p>学会了使用influxdb，下面我们来配置grafana，启动grafana:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/grafana-server start</span><br></pre></td></tr></table></figure></p><p>启动完毕后，在浏览器中输入<a href="http://hostname:3000" target="_blank" rel="noopener">http://hostname:3000</a><br>即可打开grafana的web页，账号名和密码默认均为admin。由于grafana只是一个读数据并显示数据的工具，因此首先要配置数据源，让它找到数据。在grafana主页面中，按照下图配置即可</p><ul><li><p>增加数据源，选择influxdb为数据源<br><img src="/images/influxdb-grafana/grafana-datasource.jpg" alt="influxdb-conf"><br><img src="/images/influxdb-grafana/grafana-data-source.png" alt="influxdb-conf"></p></li><li><p>数据源连接成功后，就可以开一个dashbord<br><img src="/images/influxdb-grafana/grafana-add-dashbord.png" alt="influxdb-conf"></p></li><li><p>填写参数<br><img src="/images/influxdb-grafana/grafana-graph.png" alt="influxdb-conf"></p></li><li><p>设置刷新时间，这里必须要在quick ranges里选择一个时间长度，如Last 1 hour<br><img src="/images/influxdb-grafana/grafana-refresh.jpg" alt="influxdb-conf"></p></li><li><p>最后保存<br><img src="/images/influxdb-grafana/grafana-save.jpg" alt="influxdb-conf"></p></li></ul><p>例子：<br><img src="/images/influxdb-grafana/grafana-demo.png" alt="influxdb-conf"><br>这里我展示的是本机的cpu和内存消耗情况，数据由<a href="https://www.influxdata.com/time-series-platform/telegraf/" target="_blank" rel="noopener">telegraf</a>采集而来</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> influxdb </tag>
            
            <tag> grafana </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux命令之--awk</title>
      <link href="//2016/11/16/linux-awk.html"/>
      <url>//2016/11/16/linux-awk.html</url>
      
        <content type="html"><![CDATA[<p><code>awk</code>命令是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。<br><a id="more"></a></p><h2 id="awk的基本结构"><a href="#awk的基本结构" class="headerlink" title="awk的基本结构"></a>awk的基本结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; print "start" &#125; pattern&#123; commands &#125; END&#123; print "end" &#125;'</span> file</span><br></pre></td></tr></table></figure><h2 id="awk的工作流程"><a href="#awk的工作流程" class="headerlink" title="awk的工作流程"></a>awk的工作流程</h2><p>awk语句可以分为三部分：BEGIN、command、END，其中 BEGIN 和 END 是可选项，要不要都无所谓，执行开始时，先执行 BEGIN，然后读取文件，读入有\n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0 则表示所有域,$1 表示第一个域,$n 表示第 n 个域,随后开始执行模式所对应的动作 action。接着开始读入第二条记录······直到所有的记录都读完，最后执行 END 操作。可以看出，BEGIN 和 END 域里的只在开始和结束时执行一次，中间的 command 是循环执行的。因此，一般可以在 BEGIN 域里放一些计数器变量，在循环中累计，最后在 END 域打印，这样就可以完成一些统计类的工作。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>最常用的方式是在命令行中，以一个输入，配一个管道，再跟一个 awk 命令，如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输出file的内容，以:为分隔符，打印第一列</span></span><br><span class="line">cat file | awk -F <span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输出file的内容，以:为分隔符，打印第一，第二列，并用,逗号分割</span></span><br><span class="line">cat file | awk -F <span class="string">':'</span> <span class="string">'&#123;print $1 “,” $2&#125;'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输出file的内容，只显示有gun关键字的所有列</span></span><br><span class="line">cat file | awk <span class="string">'/gun/&#123;print $1&#125;'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#求1+2+...+100的和</span></span><br><span class="line">seq 100 | awk <span class="string">'BEGIN &#123;sum=0&#125; &#123;sum+=$1&#125; END &#123;print "sum is:" sum&#125;'</span></span><br></pre></td></tr></table></figure><p>来个复杂点的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计某个目录下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹):</span></span><br><span class="line">ls -l | awk <span class="string">'BEGIN &#123;size=0&#125; &#123;if ($5!=4096) &#123;size=size+$5;&#125;&#125; END &#123;print "[end]size is ", size/1024/1024,"M"&#125;'</span></span><br></pre></td></tr></table></figure></p><p>可以看出，awk里还支持各种运算，这些运算与C语言提供的基本相同，可以放在BEGIN、command、END任意域中，再来个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计服务器某端口在当前时刻有多少个连接，并打印时间和连接数</span></span><br><span class="line">netstat -lanp| grep 8080 | grep ESTABLISHED | awk <span class="string">'&#123;print $5&#125;'</span>| awk -F <span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span>| sort | uniq | wc -l |awk <span class="string">'BEGIN&#123;a="'</span>$(date +%H:%M:%S)<span class="string">'";&#125;&#123;printf "%s,%d\n",a,$1&#125;'</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>awk编程的内容极多，这里只罗列简单常用的用法</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux命令之--grep</title>
      <link href="//2016/11/16/linux-grep.html"/>
      <url>//2016/11/16/linux-grep.html</url>
      
        <content type="html"><![CDATA[<p><code>grep</code>命令是linux环境下使用频繁、功能强大的查找命令，基本每天的工作都会用到它，这里对grep命令做个总结，作为备忘<br><a id="more"></a></p><p>首先看下grep命令有哪些选项吧</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-a 不要忽略二进制数据。 -A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。 </span><br><span class="line">-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。 </span><br><span class="line">-c 计算符合范本样式的列数。 -C&lt;显示列数&gt;或-&lt;显示列数&gt; 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。 </span><br><span class="line">-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。 </span><br><span class="line">-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。 </span><br><span class="line">-E 将范本样式为延伸的普通表示法来使用，意味着能使用扩展正则表达式。 </span><br><span class="line">-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。 -F 将范本样式视为固定字符串的列表。 </span><br><span class="line">-G 将范本样式视为普通的表示法来使用。 </span><br><span class="line">-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。 </span><br><span class="line">-H 在显示符合范本样式的那一列之前，标示该列的文件名称。 </span><br><span class="line">-i 忽略字符大小写的差别。 </span><br><span class="line">-l 列出文件内容符合指定的范本样式的文件名称。 </span><br><span class="line">-L 列出文件内容不符合指定的范本样式的文件名称。 </span><br><span class="line">-n 在显示符合范本样式的那一列之前，标示出该列的编号。 </span><br><span class="line">-q 不显示任何信息。 </span><br><span class="line">-R/-r 此参数的效果和指定“-d recurse”参数相同。 </span><br><span class="line">-s 不显示错误信息。 </span><br><span class="line">-v 反转查找。 </span><br><span class="line">-w 只显示全字符合的列。 </span><br><span class="line">-x 只显示全列符合的列。 </span><br><span class="line">-y 此参数效果跟“-i”相同。 </span><br><span class="line">-o 只输出文件中匹配到的部分。</span><br></pre></td></tr></table></figure><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找正在运行中的某个进程，忽略大小写</span></span><br><span class="line">ps aux | grep -i <span class="string">'some_process'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#支持正则查找</span></span><br><span class="line">ps aux | grep -E <span class="string">'^some_process'</span></span><br><span class="line">ps aux | grep -E <span class="string">'something|otherthing'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上面的命令会在结果中，混入grep进程，如果要过滤掉，则加-v参数，查找除之外的所有进程</span></span><br><span class="line">ps aux | grep <span class="string">'some_process'</span> | grep -v <span class="string">'grep'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#grep还可以在一个目录中，搜索含有某字符的文档，如在当前目录下，查找含有gun字符的文档，并标识出所在的行号</span></span><br><span class="line">grep <span class="string">'gun'</span> . -r -n</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找并打印目标的前后3行</span></span><br><span class="line">cat <span class="built_in">log</span> | grep -B3 -A3 <span class="string">'key'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使匹配到的字符高亮，更醒目</span></span><br><span class="line">grep <span class="string">'gun'</span> . -r -n --color=auto</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只在目录中所有的.php和.html文件中递归搜索字符gun</span></span><br><span class="line">grep <span class="string">"gun"</span> . -r --include *.&#123;php,html&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> grep </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>让你的 git 命令简化起来</title>
      <link href="//2016/10/18/git-alias.html"/>
      <url>//2016/10/18/git-alias.html</url>
      
        <content type="html"><![CDATA[<p>对于写代码的搬砖工来说，版本控制软件是日常工作中必不可少的工具。git 由于其强大的分布式管理、以及快速在版本间穿梭的功能，大有取代 svn 的趋势。对于使用 svn 的老一辈码农来说，那么怎么快速从 svn 切换到 git 呢？<br><a id="more"></a></p><h2 id="让我们从简化命令开始"><a href="#让我们从简化命令开始" class="headerlink" title="让我们从简化命令开始"></a>让我们从简化命令开始</h2><p>git 支持 Alias 别名，先在自己的目录中创建文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.gitconfig</span><br></pre></td></tr></table></figure><p>建立好后，拷贝下面内容到上述文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">  st = status</span><br><span class="line">  ci = commit</span><br><span class="line">  co = checkout</span><br><span class="line">  b = branch</span><br><span class="line">  cfg = config</span><br><span class="line">  r = remote</span><br><span class="line">  m = merge</span><br><span class="line">  pl = pull</span><br><span class="line">  ps = push</span><br><span class="line">  l = <span class="built_in">log</span></span><br><span class="line">  sb = show-branch</span><br><span class="line">  di = diff                                                                                                                                                                  </span><br><span class="line">  gl = <span class="built_in">log</span> --graph --pretty=format:<span class="string">'%h%Cred%d%Creset @%Cgreen%an%Creset %s [%ar]'</span> --abbrev-commit --color --decorate --date-order--date-order</span><br><span class="line">  dc = diff --color --cached</span><br></pre></td></tr></table></figure><p>保存后，以后输入 git 命令就方便多啦！试试吧~</p><h2 id="附其他常用的-git-命令及解释"><a href="#附其他常用的-git-命令及解释" class="headerlink" title="附其他常用的 git 命令及解释"></a>附其他常用的 git 命令及解释</h2><ul><li><code>git branch</code> 查看本地所有分支 其中带*号的是当前所在分支</li><li><code>git branch dev</code> 新建dev分支</li><li><code>git checkout dev</code> 切换到dev分支</li><li><code>git status</code> 查看当前git库的状态，会指出有哪些新文件，有哪些修改过的文件</li><li><code>git add file1 file2</code> 将文件添加到暂存区，如果要添加所有文件，则git add .(一个点)</li><li><code>git commit -m</code> “提交说明” 一次性将暂存区提交到版本库</li><li><code>git remote add origin http://github.com/ask/celery.git</code> 如果你新建了一个远程库，可以用词命令将本地库和远程库关联起来</li><li><code>git push origin master</code> 将本地的master分支，提交到origin主机的master分支，一般origin即指代远程版本库</li></ul><h4 id="更新-2017-08"><a href="#更新-2017-08" class="headerlink" title="更新(2017.08)"></a>更新(2017.08)</h4><p>实际当把 shell 换为 zsh 后，zsh 本身已经带有 git 插件，因此有了更多的简化命令操作，具体看这篇<a href="https://xujimmy.com/2017/06/20/linux-zsh.html">文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求两个文件的交集，并集，差集</title>
      <link href="//2016/10/11/linux-sort.html"/>
      <url>//2016/10/11/linux-sort.html</url>
      
        <content type="html"><![CDATA[<p>在 Linux下，有两个文件，分别记录了很多 ip 地址，怎么求得在两个文件中都出现的 ip？以及所有的不重复的 ip？<br><a id="more"></a></p><p>如 a 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10.10.1.101</span><br><span class="line">10.10.1.104</span><br><span class="line">10.10.1.102</span><br><span class="line">10.10.1.103</span><br></pre></td></tr></table></figure></p><p>b 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.10.1.101</span><br><span class="line">10.10.1.105</span><br><span class="line">10.10.1.103</span><br></pre></td></tr></table></figure></p><h3 id="交集（亦即-a-b-中都出现的-ip）"><a href="#交集（亦即-a-b-中都出现的-ip）" class="headerlink" title="交集（亦即 a,b 中都出现的 ip）"></a>交集（亦即 a,b 中都出现的 ip）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort a b | uniq -d</span><br></pre></td></tr></table></figure><h3 id="并集（a-b-中所有的-ip）"><a href="#并集（a-b-中所有的-ip）" class="headerlink" title="并集（a,b 中所有的 ip）"></a>并集（a,b 中所有的 ip）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort a b | uniq</span><br></pre></td></tr></table></figure><h3 id="差集（a-b）"><a href="#差集（a-b）" class="headerlink" title="差集（a-b）"></a>差集（a-b）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort a b b | uniq -u</span><br></pre></td></tr></table></figure><h3 id="相关命令和参数"><a href="#相关命令和参数" class="headerlink" title="相关命令和参数"></a>相关命令和参数</h3><p><code>sort</code>可以将文件进行排序，排序是为了通过管道交接<code>uniq</code>处理，因为<code>uniq</code>命令只能处理相邻的行，<code>sort</code>后面可以接多个文件，表示同时对多个文件进行综合排序。如上面的<code>sort a b</code>，表示同时排序 a,b 两个文件。<code>uniq</code>可以删除文件中重复的行，得到文件中唯一的行，<code>-d</code>参数表示输出出现次数大于1的内容；<code>-u</code>表示输出出现次数为1的内容；</p><p>知道上述参数后，求并，交都很easy了。关键是差集，如上，<code>sort a b b</code>，因为用了两个b，因此排序后，结果中，b的ip必然最少出现了两次，再<code>uniq</code>下，剩下的就是a中出现，而b中没出现的ip了。</p><p>经常有这样一个需求：从日志中找出访问量最多的前 10 个 IP，并统计次数，日志格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2 - - [01/Sep/2019:00:34:23 +0800] &quot;GET /phpmyadmin/ HTTP/1.1&quot;</span><br><span class="line">192.168.1.5 - - [01/Sep/2019:00:34:23 +0800] &quot;GET /robots.txt HTTP/1.1&quot;</span><br><span class="line">192.168.1.2 - - [01/Sep/2019:00:34:23 +0800] &quot;GET /robots.txt HTTP/1.1&quot;</span><br><span class="line">... 省略</span><br></pre></td></tr></table></figure></p><p>先对第一列做处理，然后用 sort<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | awk <span class="string">'&#123;print $1&#125;'</span> | sort | uniq -c | sort -nr | head 10</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用PhantomJS抓取js渲染的网页</title>
      <link href="//2016/08/22/python-PhantomJS.html"/>
      <url>//2016/08/22/python-PhantomJS.html</url>
      
        <content type="html"><![CDATA[<p>在用python抓取网页时，一般情况下，用urllib2，requests等库差不多够用，但是有的页面里的某些div里的元素，是由js动态渲染，或者某些div，是在window页面滑到该区域才开始加载的。对于这种网页，你直接抓取然后审查页面信息，会看到div为空，或者div的内容为”加载中…”。<br>那么怎么抓取这类动态页面呢，在window下，可以使用selenium，但在Linux平台，就需要用PhantomJS配合selenium来完成了。<br><a id="more"></a></p><p>selenium是一个可以调用浏览器的自动化测试套件，它提供了一组可以操作浏览器的API，比如模拟用户打开浏览器，填写表单，提交等动作，可以很方便的完成重复的测试工作，而PhantomJS是一个无界面的浏览器，因此在Linux环境下，二者配合起来，就可以很方便的模拟浏览器浏览行为了，也就可以抓取到由JS渲染的页面元素。</p><h2 id="安装PhantomJS"><a href="#安装PhantomJS" class="headerlink" title="安装PhantomJS"></a>安装PhantomJS</h2><p>直接在<a href="http://phantomjs.org/download.html" target="_blank" rel="noopener">官网</a>下载安装包</p><h2 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#确保你的python已经安装了pip包管理器</span></span><br><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>安装完毕后，就可以抓动态网页了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.PhantomJS(executable_path=<span class="string">'/bin/phantomjs/bin/phantomjs'</span>)  <span class="comment">#这里的executable_path填你phantomJS的路径</span></span><br><span class="line">driver.get(<span class="string">'http://www.example.com'</span>) <span class="comment">#对网页发请求</span></span><br><span class="line"><span class="keyword">print</span> driver.page_source <span class="comment">#获取网页html代码</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>上述代码中，driver对象的page_source就是该网页的内容，还有其他的属性，可以通过dir(driver)查看driver还有哪些其他方法和属性，按需求获取</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PhantomJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由 daemon 账户到 ssh 免密登录的一点思考</title>
      <link href="//2016/08/12/ssh-monitor.html"/>
      <url>//2016/08/12/ssh-monitor.html</url>
      
        <content type="html"><![CDATA[<p>最近项目上遇到一个这样的场景：<br>在A服务器上，我有一个监控脚本monitor.py，可以用来监控远程服务器的资源消耗情况，比如CPU,内存,IO等信息。<br><a id="more"></a></p><p>输入参数为服务器名hostname或ip，比如执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python monitor.py 198.111.11.11</span><br></pre></td></tr></table></figure></p><p>即可输出该远程机器资源消耗信息</p><p>既然要获得远程服务器的资源占用情况，我的做法是事先在A服务器上生成我自己的公密钥对，然后把公钥复制到所有监控的服务器上。达到在monitor脚本中，从A服务器免密登录到所有其他监控机器的目的。既然登录到指定机器了，那获得资源消耗情况就很简单了，一个top命令，然后正则提取出来想要的信息。</p><p>现在的问题是：我要从前端一个的URL提交监控参数hostname，调用后端的监控脚本。这种情况下，监控脚本就不能正常工作了，为什么呢？来分析下流程:</p><p>前端提交URL，比如输入<a href="http://xxx.net/monitor.php?p=hostname，后端monitor.php脚本接收到hostname参数，执行了" target="_blank" rel="noopener">http://xxx.net/monitor.php?p=hostname，后端monitor.php脚本接收到hostname参数，执行了</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(‘python monitor.py hostname’)</span><br></pre></td></tr></table></figure></p><p>该代码执行跟在命令行中执行python monitor.py hostname是一样的，但却无法成功，<strong>因为这行代码的执行者，是服务器而不是我本人</strong>，如果你给apache服务器起的名字为daemon，那么执行monitor.py脚本的就是daemon，而我monitor里免密登录到远程机器，用的是我自己的账户，daemon用户是个虚拟的，远程机器根本就不存在这个用户，就算存在，你不知道daemon的密码，也是没法登录的，执行monitor会得到一个超时或者请输入daemon的密码之类的错误。这种方式是不可行。</p><p>其实这里，如果在apache配置文件中，把apache用户改为我自己的用户，也是可以的，但这样影响面就有点大，因为这会改变这台机器web目录中所有文件的所有者为你自己的名字，可能影响到其他用户涉及到权限的操作。</p><p>后来换了个思路，不直接从前端启动脚本，而是通过写文件的方式，我把前端的参数写入到一个文件里，然后监控这个文件的变化，如果文件有新内容写入，把内容提取出来，然后去执行monitor脚本，这样我在后端必须要在起一个监控脚本，该脚本在后台一直运行着，用来监测文件变化，一旦文件变化，就执行monitor，由于这个监控脚本是我本人执行的，那么最后monitor当然也就是我执行的，问题解决。<br>监控文件或目录变化，python中有个库，叫pyinotify，用法如下，代码一看就懂，不解释了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pyinotify <span class="keyword">import</span> WatchManager, Notifier, ProcessEvent, IN_DELETE, IN_CREATE, IN_MODIFY</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span><span class="params">(ProcessEvent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_IN_CREATE</span><span class="params">(self, event)</span>:</span>  <span class="comment">#监控是否有文件创建，如果有，则进入该函数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Create file:%s."</span> %os.path.join(event.path,event.name)</span><br><span class="line">        os.system(<span class="string">'cp -rf %s /tmp/bak/'</span>%(os.path.join(event.path,event.name)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_IN_DELETE</span><span class="params">(self, event)</span>:</span>  <span class="comment">#监控是否有文件被删除，如果有，则进入该函数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Delete file:%s."</span> %os.path.join(event.path,event.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_IN_MODIFY</span><span class="params">(self, event)</span>:</span>  <span class="comment">#监控是否有文件修改，如果有，则进入该函数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Modify file:%s."</span> %os.path.join(event.path,event.name)</span><br><span class="line">        <span class="comment">#监控文件变化，在这里执行monitor.py</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'/home/zhangsan/monit'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            hostname = f.readlines()[<span class="number">-1</span>]</span><br><span class="line">        order = <span class="string">'python monitor.py %s'</span> % hostname</span><br><span class="line">        os.system(order)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FsMonitor</span><span class="params">(path=<span class="string">'.'</span>)</span>:</span></span><br><span class="line">    wm = WatchManager()</span><br><span class="line">    mask = IN_DELETE | IN_CREATE | IN_MODIFY</span><br><span class="line">    notifier = Notifier(wm, EventHandler())</span><br><span class="line">    wm.add_watch(path, mask, auto_add= <span class="keyword">True</span>, rec=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"now starting monitor %s."</span> %path</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            notifier.process_events()</span><br><span class="line">            <span class="keyword">if</span> notifier.check_events():</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"check event true."</span></span><br><span class="line">                notifier.read_events()</span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"keyboard Interrupt."</span></span><br><span class="line">            notifier.stop()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    FsMonitor(<span class="string">"/home/zhangsan/"</span>)  <span class="comment">#监控该目录，若该目录文件有变化，比如创建，更改，删除，则会进入到相应处理事件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> monitor </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用正则方式批量删除 redis 里的 key</title>
      <link href="//2016/08/11/linux-xargs-redis.html"/>
      <url>//2016/08/11/linux-xargs-redis.html</url>
      
        <content type="html"><![CDATA[<p>redis 里面有一批没用的 key，这些 key 以 test_开头，要求删掉这些key，在命令行中没法删除，可以写个脚本，一个一个删，也可以用下面 xargs 命令的方式<br><a id="more"></a></p><p>使用方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/redis-cli -n 0 keys <span class="string">"test_*"</span> | xargs /usr/bin/redis-cli -n 0 del</span><br></pre></td></tr></table></figure></p><p>duang，看下是不是删除了？</p><p>这里有个地方需要注意，key 里不能有空格，不然后删除失败，如果有，可以将 key 导入到文件里，然后再执行下面命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat key | xargs redis-cli del</span><br></pre></td></tr></table></figure></p><h2 id="xargs-命令的用法"><a href="#xargs-命令的用法" class="headerlink" title="xargs 命令的用法"></a>xargs 命令的用法</h2><p>有很多命令不支持 | 管道来传递参数，如<code>ls</code>而日常工作中有这个必要，所以就有了 xargs 命令，xargs 实现的是将管道传输过来的 stdin 进行处理然后传递到命令的参数位上。也就是说xargs完成了两个行为：<strong>处理管道传输过来的 stdin；将处理后的传递到正确的位置上</strong></p><p>比如像找以 test_ 开头的文件详情，有同学可能会这样写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find test_* |ls -l</span><br></pre></td></tr></table></figure></p><p>上面这个命令，没法得到以 test_ 开头的文件详情，应该使用下面的这个<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find test_* |xargs ls -l   <span class="comment">#这样才是正确的</span></span><br></pre></td></tr></table></figure></p><p>另一个例子，假如你有一个文件包含了很多你希望下载的URL，你能够使用xargs下载所有链接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat url-list.txt | xargs wget -c</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> xargs </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MYSQL 中的 JOIN</title>
      <link href="//2016/08/02/mysql-join.html"/>
      <url>//2016/08/02/mysql-join.html</url>
      
        <content type="html"><![CDATA[<p>在我们写 SQL 语句时，会用到多表联合查询，这时就需要用到 JOIN 关键字了，本文用图来看下 MYSQL 中几种 JOIN 的区别。<br><a id="more"></a></p><p>首先建两个表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`studentEO`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`scoreEO`</span> (</span><br><span class="line"><span class="string">`stu_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span>,</span><br><span class="line"><span class="string">`score`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p><p>其中，表 studentEO 中的 id 字段和 socreEO 表中的 stu_id 字段相关联。</p><p>往表中插些数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> studentEO(<span class="keyword">id</span>, age) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">15</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> studentEO(<span class="keyword">id</span>, age) <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">16</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> studentEO(<span class="keyword">id</span>, age) <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">17</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> studentEO(<span class="keyword">id</span>, age) <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> scoreEO(stu_id, score) <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">70</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> scoreEO(stu_id, score) <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> scoreEO(stu_id, score) <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> scoreEO(stu_id, score) <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><p>分别执行以下语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> studentEO <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> scoreEO <span class="keyword">ON</span> studentEO.id = scoreEO.stu_id;</span><br></pre></td></tr></table></figure></p><p>结果:<br>+——+——+——–+——-+<br>| id   | age  | stu_id | score |<br>+——+——+——–+——-+<br>|    2 |   16 |      2 |    70 |<br>|    3 |   17 |      3 |    80 |<br>|    4 |   18 |      4 |    90 |<br>|    1 |   15 |   NULL |  NULL |<br>+——+——+——–+——-+<br>4 rows in set (0.00 sec)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> studentEO <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> scoreEO <span class="keyword">ON</span> studentEO.id = scoreEO.stu_id;</span><br></pre></td></tr></table></figure><p>结果：<br>+——+——+——–+——-+<br>| id   | age  | stu_id | score |<br>+——+——+——–+——-+<br>|    2 |   16 |      2 |    70 |<br>|    3 |   17 |      3 |    80 |<br>|    4 |   18 |      4 |    90 |<br>| NULL | NULL |      5 |   100 |<br>+——+——+——–+——-+<br>4 rows in set (0.00 sec)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> studentEO <span class="keyword">INNER</span> <span class="keyword">JOIN</span> scoreEO <span class="keyword">ON</span> studentEO.id = scoreEO.stu_id;</span><br></pre></td></tr></table></figure><p>结果：<br>+——+——+——–+——-+<br>| id   | age  | stu_id | score |<br>+——+——+——–+——-+<br>|    2 |   16 |      2 |    70 |<br>|    3 |   17 |      3 |    80 |<br>|    4 |   18 |      4 |    90 |<br>+——+——+——–+——-+<br>3 rows in set (0.00 sec)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> studentEO <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> scoreEO <span class="keyword">on</span> studentEO.id=scoreEO.stu_id <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> studentEO <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> scoreEO <span class="keyword">ON</span> studentEO.id = scoreEO.stu_id;</span><br></pre></td></tr></table></figure><p><strong>注意，MYSQL 中，没有 FULL OUTER JOIN</strong><br>结果：<br>+——+——+——–+——-+<br>| id   | age  | stu_id | score |<br>+——+——+——–+——-+<br>|    2 |   16 |      2 |    70 |<br>|    3 |   17 |      3 |    80 |<br>|    4 |   18 |      4 |    90 |<br>|    1 |   15 |   NULL |  NULL |<br>| NULL | NULL |      5 |   100 |<br>+——+——+——–+——-+<br>5 rows in set (0.00 sec)</p><p>从以上的几条 SQL 结果来看，我们可以得到以下图示：<br><img src="https://www.wangbase.com/blogimg/asset/201901/bg2019011503.png" alt="内连接"><br><img src="https://www.wangbase.com/blogimg/asset/201901/bg2019011501.png" alt="左连接"><br><img src="https://www.wangbase.com/blogimg/asset/201901/bg2019011504.png" alt="右连接"><br><img src="https://www.wangbase.com/blogimg/asset/201901/bg2019011505.png" alt="外连接"></p><h2 id="用语言总结下"><a href="#用语言总结下" class="headerlink" title="用语言总结下"></a>用语言总结下</h2><ul><li>只返回两张表匹配的记录，这叫内连接（inner join）</li><li>返回匹配的记录，以及表 A 多余的记录，这叫左连接（left join）</li><li>返回匹配的记录，以及表 B 多余的记录，这叫右连接（right join）</li><li>返回匹配的记录，以及表 A 和表 B 各自的多余记录，这叫全连接（full join）</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.ruanyifeng.com/blog/2019/01/table-join.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/01/table-join.html</a><br><a href="https://blog.codinghorror.com/a-visual-explanation-of-sql-joins/" target="_blank" rel="noopener">https://blog.codinghorror.com/a-visual-explanation-of-sql-joins/</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于redis使用总结</title>
      <link href="//2016/08/02/redis.html"/>
      <url>//2016/08/02/redis.html</url>
      
        <content type="html"><![CDATA[<p>最近的项目一直在使用 redis，在参考前人文章的基础上，本文也对 redis 的使用做一个简单的归纳总结。<br><a id="more"></a></p><p>redis是一个开源的，K-V型存储的数据库，可用于构建高性能、可扩展的web应用程序的存储解决方案。<br>与MySQL的这类数据库相比，Redis有如下几个特点：</p><ul><li>redis是完全在内存中保存数据的数据库，使用磁盘只是为了持久性目的；</li><li>redis相比许多键值数据存储系统有相对丰富的数据类型；</li><li>redis可以将数据复制到任意数量的从服务器中；</li></ul><h2 id="redis-有哪些优点？"><a href="#redis-有哪些优点？" class="headerlink" title="redis 有哪些优点？"></a>redis 有哪些优点？</h2><ul><li>快速：Redis将数据保存在内存，读写速度非常快，每秒可执行8W次读写操作，适合那种对数据读写速度有要求的业务</li><li>数据类型丰富：Redis可保存的数据类型非常多，如列表，集合，可排序集合，哈希等数据类型。</li><li>操作原子性：所有 Redis 的操作都是原子，从而确保当两个客户同时访问 Redis服务器得到的是更新后的值（最新值）。</li><li>数据更新：由于Redis将数据放在内存中，时间长会导致内存占用过大，因此Redis的上数据可以设置过期时间，时间到了，数据就自动删除。</li></ul><h2 id="redis使用"><a href="#redis使用" class="headerlink" title="redis使用"></a>redis使用</h2><h3 id="Linux上安装redis"><a href="#Linux上安装redis" class="headerlink" title="Linux上安装redis"></a>Linux上安装redis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install redis <span class="comment">#cenOS用yum install redis</span></span><br></pre></td></tr></table></figure><p>或者直接下载 redis 源代码安装</p><h3 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h3><p>安装完后，就可以启动redis服务了，启动前，最好配置下redis的配置文件，一般路径在/etc/redis.conf，配置文件里写有redis启动的端口，log位置，数据备份到磁盘等常用设置，根据需要修改。为了安全，最好不要用 root 用户启动。并且给redis设置一个密码。执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server redis.conf</span><br></pre></td></tr></table></figure></p><p>启动完毕，执行下面命令进入redis交互命令行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure></p><h3 id="使用redis"><a href="#使用redis" class="headerlink" title="使用redis"></a>使用redis</h3><p>进入到交互命令行后，可以查看key和设置key，查看所有的key：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;keys *</span><br></pre></td></tr></table></figure></p><p>设置key,value：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;set test “hello”</span><br></pre></td></tr></table></figure></p><p>获得key的value：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;get test</span><br></pre></td></tr></table></figure></p><p>删除key:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;del test</span><br></pre></td></tr></table></figure></p><p>查询时，redis支持正则匹配，比如要看key为test1，test2，test3…有哪些，可以使用keys “test*” 即可</p><h3 id="关闭redis，进入到redis-cli目录，执行"><a href="#关闭redis，进入到redis-cli目录，执行" class="headerlink" title="关闭redis，进入到redis-cli目录，执行:"></a>关闭redis，进入到redis-cli目录，执行:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli shutdown</span><br></pre></td></tr></table></figure><p>其他命令，可以参看redis手册</p><h2 id="在Python中使用redis"><a href="#在Python中使用redis" class="headerlink" title="在Python中使用redis"></a>在Python中使用redis</h2><p>Python中使用redis，首先要下载一个 redis 扩展包，并安装，安装很简单，直接进入到解压目录，执行build，install等命令就完了。或者直接 pip 安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure></p><p>按照好扩展后，可以用如下方式使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisOP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,host,port,db=<span class="number">0</span>,pw=<span class="string">'password'</span>)</span>:</span></span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.db = db</span><br><span class="line">        self.pw = pw</span><br><span class="line">        self.conn = self._connect()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_connect</span><span class="params">(self)</span>:</span><span class="comment">#建立连接</span></span><br><span class="line">        <span class="keyword">return</span> redis.Redis(host=self.host,port=self.port,db=self.db,password=self.pw)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getConn</span><span class="params">(self)</span>:</span><span class="comment">#获取连接</span></span><br><span class="line">        <span class="keyword">return</span> self.conn</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    rop = RedisOP(host=<span class="string">'127.0.0.1'</span>,port=<span class="number">6379</span>)</span><br><span class="line">    rconn = rop.getConn()</span><br><span class="line">    rconn.set(<span class="string">'test'</span>,<span class="string">'value'</span>)</span><br><span class="line">    rconn.set(<span class="string">'test2'</span>,<span class="string">'othervalue'</span>) </span><br><span class="line">    rconn.expire(<span class="string">'test2'</span>,<span class="number">60</span>*<span class="number">3600</span>) <span class="comment">#给test2设置过期时间，1小时候过期</span></span><br><span class="line">    <span class="keyword">print</span> reconn.get(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 用 gevent 协程抓取海量网页</title>
      <link href="//2016/05/17/python-gevent.html"/>
      <url>//2016/05/17/python-gevent.html</url>
      
        <content type="html"><![CDATA[<p>python作为爬虫利器，抓网页的方式简洁明了。爬成百上千的网页，都可以很快爬完，但是如果网页数量上万呢？速度就不能忍受了。<br><a id="more"></a></p><p>这是一段爬取页面的函数，用了<a href="http://cn.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">requests</a>库:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchPage</span><span class="params">(url)</span>:</span></span><br><span class="line">req = requests.get(url,header = header)</span><br><span class="line">content = req.text</span><br><span class="line"><span class="keyword">return</span> content</span><br></pre></td></tr></table></figure></p><p>这种方式,对于url较少时可以使用,但是如果url量很大,比如10w+,抓取过程就十分漫长,如果用多线程,由于GIL限制,实际上效率并不高,如果用多进程,就没有GIL限制,但是多进程也有其自己的限制：相比线程更加笨重、切换耗时更长，并且在python的多进程下，进程数量不推荐超过CPU核心数（一个进程只有一个GIL，所以一个进程只能跑满一个CPU），因为一个进程占用一个CPU时能充分利用机器的性能，但是进程多了就会出现频繁的进程切换，反而得不偿失.不过特殊情况（特指IO密集型任务）下，多线程是比多进程好用的。</p><p>举个例子：给你200W条url，需要你把每个url对应的页面抓取保存起来，这种时候，单单使用多进程，效果肯定是很差的。为什么呢？<br>例如每次请求的等待时间是2秒，那么如下（忽略cpu计算时间）：</p><h2 id="单进程-单线程"><a href="#单进程-单线程" class="headerlink" title="单进程+单线程"></a>单进程+单线程</h2><p>需要2秒*200W=400W秒==1111.11个小时==46.3天，这个速度明显是不能接受的</p><h2 id="单进程-多线程"><a href="#单进程-多线程" class="headerlink" title="单进程+多线程"></a>单进程+多线程</h2><p>例如我们在这个进程中开了10个多线程，比1中能够提升10倍速度，也就是大约4.63天能够完成200W条抓取，请注意，这里的实际执行是：线程1遇见了阻塞，CPU切换到线程2去执行，遇见阻塞又切换到线程3等等，10个线程都阻塞后，这个进程就阻塞了，而直到某个线程阻塞完成后，这个进程才能继续执行，所以速度上提升大约能到10倍（这里忽略了线程切换带来的开销，实际上的提升应该是不能达到10倍的），但是需要考虑的是线程的切换也是有开销的，所以不能无限的启动多线程（开200W个线程肯定是不靠谱的）</p><h2 id="多进程-多线程"><a href="#多进程-多线程" class="headerlink" title="多进程+多线程"></a>多进程+多线程</h2><p>这里就厉害了，一般来说也有很多人用这个方法，多进程下，每个进程都能占一个cpu，而多线程从一定程度上绕过了阻塞的等待，所以比单进程下的多线程又更好使了，例如我们开10个进程，每个进程里开20W个线程，执行的速度理论上是比单进程开200W个线程快10倍以上的（为什么是10倍以上而不是10倍，主要是cpu切换200W个线程的消耗肯定比切换20W个进程大得多，考虑到这部分开销，所以是10倍以上）。<br>还有更好的方法吗？答案是肯定的，它就是：</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>使用它之前我们先讲讲what/why/how（它是什么/为什么用它/怎么使用它）</p><h3 id="what："><a href="#what：" class="headerlink" title="what："></a>what：</h3><p>协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：<br>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。<br>在并发编程中，协程与线程类似，每个协程表示一个执行单元，有自己的本地数据，与其它协程共享全局数据和其它资源。</p><h3 id="why："><a href="#why：" class="headerlink" title="why："></a>why：</h3><p>目前主流语言基本上都选择了多线程作为并发设施，与线程相关的概念是抢占式多任务（Preemptive multitasking），而与协程相关的是协作式多任务。<br>不管是进程还是线程，每次阻塞、切换都需要陷入系统调用(system call)，先让CPU跑操作系统的调度程序，然后再由调度程序决定该跑哪一个进程(线程)。<br>而且由于抢占式调度执行顺序无法确定的特点，使用线程时需要非常小心地处理同步问题，而协程完全不存在这个问题（事件驱动和异步程序也有同样的优点）。<br>因为协程是用户自己来编写调度逻辑的，对CPU来说，协程其实是单线程，所以CPU不用去考虑怎么调度、切换上下文，这就省去了CPU的切换开销，所以协程在一定程度上又好于多线程。</p><h3 id="how"><a href="#how" class="headerlink" title="how:"></a>how:</h3><p>python里面怎么使用协程？使用gevent，使用方法：看这里.<br>所以使用协程，可以不受线程开销的限制，我尝试过一次把20W条url放在单进程的协程里执行，完全没问题。<br>所以最推荐的方法，是多进程+协程（可以看作是每个进程里都是单线程，而这个单线程是协程化的）</p><p>多进程+协程下，避开了CPU切换的开销，又能把多个CPU充分利用起来，这种方式对于数据量较大的爬虫还有文件读写之类的效率提升是巨大的。<br>具体方式如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchPage</span><span class="params">(url)</span>:</span></span><br><span class="line">    req = requests.get(url,header = header)</span><br><span class="line">    content = req.text</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    geventjobs = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urllist:</span><br><span class="line">        geventjobs.append(gevent.spawn(fetchPage,url))</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> gevent </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
