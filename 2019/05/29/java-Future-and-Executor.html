<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录个人的工作，生活，感悟..."><title>Java 中 Future 和异步任务 | JimmyXu的小站</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.7.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java 中 Future 和异步任务</h1><a id="logo" href="/.">JimmyXu的小站</a><p class="description">inner peace</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/study/"><i class="fa fa-book"> 宝典</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java 中 Future 和异步任务</h1><div class="post-meta">2019 年 05 月 29 日<span> | </span><span class="category"><a href="/categories/Tech/">Tech</a></span><span> | </span><span><i class="fa fa-file-word-o"></i></span><span class="post-count"> 3.4k 字</span><span> | </span><span><i class="fa fa-clock-o"></i></span><span class="post-count"> 阅读约需 14 分钟</span></div><div class="post-content"><p>Java 中的多线程技术一直是个热门话题，而线程池、异步任务是多线程编程中绕不开的一个技术要点，本文介绍下 java 中的 Future 相关使用方法以及任务执行框架 ExecutorService。</p>
<a id="more"></a>
<h2 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h2><p>先看一个案例：用多线程输出 1 亿内的所有质数，并要求输出的质数顺序是排好序的。</p>
<p>如果单纯要完成质数输出，有很多方式，比如将 1 亿数字平均分为 100 份，每份 100 万个，用 100 个线程分别求解质数，每个线程的 run 函数里，打印质数。我们写下这样的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end   = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i += <span class="number">1000000</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                subList.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建线程打印质数</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrimeThread(subList)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span> || num % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= Math.sqrt(num); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，Runnable 中的 run 返回是 void，也就是说，每个线程只能输出结果，而没办法返回结果，因此最终的输出是无序的。有没有办法把这个结果返回呢？答案是肯定的，我们可以用 Callable</p>
<p>Callable 和 Runnable 的功能类似，但有 3 个不同点：<br>1、Callable 中的 call 是泛型方法，并且有返回值，也会抛出异常，需要对异常进行处理<br>2、Callable 不像 Runnable 可以直接用来 new Thread(new Runnable) 开一个线程，Callable 一般配合线程池使用<br>3、向线程池提交一个 Callable 任务后， 线程池并不是直接给我们返回任务的结果，而是返回一个 Future，通过这个 Future，我们才可以拿到执行结果。</p>
<h2 id="Future-是什么"><a href="#Future-是什么" class="headerlink" title="Future 是什么"></a>Future 是什么</h2><p>看了上面的描述，可能有同学还是不太理解 Future 是什么，从字面意来看，它是”将来”，但这太抽象了，事实确实如此，从 Future 的源码来看，它是一个接口，接口就是抽象的，它表示的是一个任务的执行情况。为了帮助理解，我们可以把它和<strong>句柄</strong>，或者文件描述符（fd）做类比，假如我们要对文件或者网络设备进行读写，通常会拿到一个句柄，文件的话，通常是文件句柄，网络的话，通常是 socket，调用句柄的 read 和 write 方法即可对文件或 socket 进行读写，类比过来，Future 就是一个表示<strong>任务的句柄</strong>，通过这个“句柄”，我们可以获得任务的执行情况，以及给任务发送一些指令。用一个简单例子来体会下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        String name = <span class="string">"jimmy"</span>;</span><br><span class="line">        <span class="comment">// 用 submit 方法，向线程池提交一个 Callable 任务，submit 返回一个 Future，也就是标识该任务的"句柄"</span></span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> UpperStringTask(name));</span><br><span class="line">        <span class="comment">// get 方法，获取任务的执行结果，如果任务执行过程中出错，会抛出 ExecutionException 异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperStringTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 call 方法，并返回 String</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子是一个很简单的示例，Callable 里执行的也是很简单的任务：将一个字符串转为大写，并返回。返回的结果，可以通过 future.get() 方法获得。可以看到，Callable 的使用方式和 Runnable 基本类似：Runnable 重写 run 方法，Callable 重写 call 方法。这里关键的地方在于，我们不是通过 new 一个 Thread 来启动任务，而是用 ExecutorService 的 submit 方法提交任务，submit 方法返回的也只是 Future，即一个任务的“句柄”，而不是任务结果本身。需要通过 Future 的 get 方法来获得任务结果。如果执行失败或者上面例子，就是将字符串 “jimmy” 转为大写的结果。由于任务的 call 方法返回的是 String 类型，因此 future 也应该是 String，即 <code>Future&lt;String&gt;</code> 。需要提醒的是，get 方法是个阻塞方法，这意味着，如果任务比较耗时，则 get 会一直等待任务执行完成才返回。</p>
<h3 id="Future-中的方法"><a href="#Future-中的方法" class="headerlink" title="Future 中的方法"></a>Future 中的方法</h3><p>除了 get 方法获得任务执行结果，Future 还有其他方法，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断操作是否已经完成，包括了正常完成、异常抛出、取消</span></span><br><span class="line">future.isDone()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消操作，方式是中断。参数 true 说的是，即使这个任务正在执行，也会进行中断</span></span><br><span class="line">future.cancel(<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否被取消，只有在任务正常结束之前被取消，这个方法才会返回 true</span></span><br><span class="line">future.isCancelled()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面不带参数的 get 方法是阻塞的，会一直等待任务执行完成，也可以给 get 传一个参数，设置超时时间</span></span><br><span class="line">future.get(timeout, TimeUnit)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，确实可以把 Futuere 想象成任务的句柄，通过这个句柄，获得任务的状态，以及对任务做一些操作。这一点上，Callable 要比 Runnable 灵活许多。</p>
<p>弄明白了上面简单例子，我们就可以尝试解决文章开头的那个案例了，注释已经说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 表示一批任务执行情况的 future 集合，每个任务的结果是 List&lt;Integer&gt;</span></span><br><span class="line">        List&lt;Future&lt;List&lt;Integer&gt;&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;PrimeTask&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end   = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 1 到 1 亿 分为 100 个区间，每个区间 1000000 个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i += <span class="number">1000000</span>) &#123;</span><br><span class="line">        	List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        		subList.add(j);</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="comment">// 提交一个 PrimeTask 类型的任务，返回的 future 类型是 List&lt;Integer&gt;</span></span><br><span class="line">        	Future&lt;List&lt;Integer&gt;&gt; future = executor.submit(<span class="keyword">new</span> PrimeTask(subList));</span><br><span class="line">        	<span class="comment">// 然后将 future 添加到结果集</span></span><br><span class="line">        	futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代 future 集合，获取每个任务的执行结果，集合中的 future 顺序和上面提交任务的顺序是一致的，</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Integer&gt;&gt; f : futures) &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        		<span class="comment">// 获取结果</span></span><br><span class="line">        		f.get();</span><br><span class="line">        	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            	e.printStackTrace();</span><br><span class="line">        	&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            	e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shtdown();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeTask</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span> || num % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= Math.sqrt(num); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="执行-Runnable-任务"><a href="#执行-Runnable-任务" class="headerlink" title="执行 Runnable 任务"></a>执行 Runnable 任务</h3><p>那么有没有可以执行 Runnable 类型任务的类呢？其实 submit 方法也可以接收一个 Runnable 类型参数，也会返回一个 Future，只不过由于 Runnable 任务没有返回值，因此你用返回的 Future 并调用 Future.get，任务完成后只能得到一个 null。所以，这里的 Future 只能用来查看任务状态，如 Future.isDone，或者取消任务，如 Future.cancel。此外，ExecutorService 继承于 Executor 接口，Executor 有个 execute 方法，这个方法就是用于接收 Runnable 类型的任务，因此我们也可以在 ExecutorService 中使用 execute 方法提交 Runnable，即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际是将 Runnable 任务委托给了父类 Executor 中的 execute</span></span><br><span class="line"><span class="keyword">void</span> ExecutorService.execute(Runnable task);</span><br></pre></td></tr></table></figure></p>
<p>由于本文主要侧重点在 Future，因此执行 Runnable 的例子不打算介绍了，简单总结下：</p>
<ul>
<li>ExecutorService 可以接收 Callable 和 Runnable 类型的任务，使用 submit 方法提交任务，该方法返回任务句柄 Future</li>
<li>Callable 任务执行完毕后，通过 Future.get 获取任务结果，Runnable 任务执行完后无结果</li>
</ul>
<h2 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h2><p>在绝大部分场景下，ExecutorService 都可以满足我们的需要。假设现在有这样一个场景：我们向 ExecutorService 依次提交了 4 个任务 A，B，C，D，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">futures.add(executorService.submit(A));</span><br><span class="line">futures.add(executorService.submit(B));</span><br><span class="line">futures.add(executorService.submit(C));</span><br><span class="line">futures.add(executorService.submit(D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代 futures 获取结果</span></span><br><span class="line"><span class="keyword">for</span> (Future future:futures) &#123;</span><br><span class="line">    Integer result = future.get();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，A 任务特别耗时，而 B，C，D 任务很快就完成了，由于<code>future.get()</code>是阻塞的，因此上面在迭代 future 时，我们不得不等待 A 完成后，即第一个 future.get() 返回后，才能继续拿 B，C，D的结果。这里的主要问题是，当我们提交一个任务集合时，我们事先是不知道集合中哪个任务会先执行完，因此只能拿到一个 future 集合，这个集合的顺序和我们提交任务的顺序一致，然后依次迭代 future 取结果。因此，上面我们求质数，迭代 future 集合时，可能出现这种情况：<strong>后面某个区间的质数已经求解完毕，但前面的区间还没求解完</strong>。由于上面案例需要顺序输出质数，因此我们对 future 顺序迭代取结果。</p>
<p>再假设一个情况，如果我们提交的是下载任务：从不同的镜像源下载某个安装包。如 ubuntu.iso 文件，A 任务从国外官方官网下，B 任务从 163 镜像站下，C 任务从 ali 镜像站下，哪个任务先下载完就用哪个，并终止其他任务，这时用上述迭代方式就不合适了。</p>
<p>此时我们可以使用 <strong>ExecutorCompletionService</strong>。相比于 ExecutorService，ExecutorCompletionService 这个类提供了 take 方法，这个方法也会阻塞的等待任务集合执行，一旦集合中有完成的任务，take 就返回，注意，take 返回的是 future，也即已经完成的任务的“句柄”，这时调用 get 方法，即可拿到结果了。从描述来看，take 方法似乎跟 BlockingQueue 里的 take 方法类似，事实也确实如此，ExecutorCompletionService 是在 ExecutorService 的基础上，用一个 LinkedBlockingQueue 队列存 future。一旦有任务完成，就把该任务的 future 放入到 LinkedBlockingQueue 中，<strong>如果说<br>ExecutorService = incoming queue + worker threads，那么<br>ExecutorCompletionService = incoming queue + worker threads + output queue</strong></p>
<p>使用上，ExecutorCompletionService 也非常容易，ExecutorCompletionService 提供了一个构造方法，可以直接把 ExecutorService 包装成 ExecutorCompletionService，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletionService executorCompletionService= <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executorService);</span><br></pre></td></tr></table></figure></p>
<p>上面的例子用 executorCompletionService 来改写下，注释说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">CompletionService executorCompletionService= <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executorService);</span><br><span class="line">List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">futures.add(executorCompletionService.submit(A));</span><br><span class="line">futures.add(executorCompletionService.submit(B));</span><br><span class="line">futures.add(executorCompletionService.submit(C));</span><br><span class="line">futures.add(executorCompletionService.submit(D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里就不是迭代 futures 了，而是调用 executorCompletionService 的 take 方法，然后再 get</span></span><br><span class="line"><span class="comment">// 结果的顺序和提交任务的顺序可能不一致，取决于谁先执行完，就先获取谁的结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;futures.size(); i++) &#123;</span><br><span class="line">    Integer result = executorCompletionService.take().get();</span><br><span class="line">    <span class="comment">// 拿到结果，做其他处理</span></span><br><span class="line">    <span class="comment">// doSomeThing()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在再来考虑下上述那个从不同镜像源下载安装包的场景，注释已经说明了问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Executor e, Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化一个 ExecutorCompletionService</span></span><br><span class="line">    CompletionService&lt;Result&gt; ecs = <span class="keyword">new</span> ExecutorCompletionService&lt;Result&gt;(e);</span><br><span class="line">    <span class="comment">// 获得任务总数</span></span><br><span class="line">    <span class="keyword">int</span> n = solvers.size();</span><br><span class="line">    List&lt;Future&lt;Result&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Result&gt;&gt;(n);</span><br><span class="line">    Result result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;Result&gt; s : solvers) &#123;</span><br><span class="line">            futures.add(ecs.submit(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依照任务完成顺序获取结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Result r = ecs.take().get();</span><br><span class="line">                <span class="comment">// 一旦某个任务执行完，终止循环</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = r;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(ExecutionException ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后取消所有任务，对已经完成的任务，执行 cancel 无影响</span></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Result&gt; f : futures)</span><br><span class="line">            f.cancel(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        use(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，上面的两个案例，我们不是迭代 Future 来拿结果，而是用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;task.size; i++)</span><br></pre></td></tr></table></figure></p>
<p>来迭代的，由于我们对结果的顺序不关心，而且 take 方法是 ExecutorCompletionService 类的，因此不能迭代 Future，而只能迭代个数，Future 个数或者任务个数，所以这里就得小心的处理 take 方法了。如果个数弄错，可能导致队列已经没有任务，但 仍然调用 take，导致一直阻塞。我们可以继承 ExecutorCompletionService，增加一个原子变量属性，每次提交一个任务，变量加 1，最终用这个变量表示任务的个数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Runnable 执行一个不返回结果的任务，Callable 执行一个有返回结果的任务</li>
<li>可以使用 Executors 的静态方法创建线程池，由线程池来执行任务</li>
<li>submit 方法用于提交任务，并返回 Future，可以把它当成任务的句柄</li>
<li>Future 的 get 是阻塞方法，向 ExecutorService 提交多个任务，最终迭代 Future 时，结果的顺序和任务提交的顺序一致</li>
<li>ExecutorCompletionService 的 take 方法可以获取已完成的任务的 Future，是通过将任务结果放入 BlockingQueue 实现</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://dzone.com/articles/executorservice-vs" target="_blank" rel="noopener">https://dzone.com/articles/executorservice-vs</a></li>
<li><a href="https://www.javaspecialists.eu/archive/Issue214.html" target="_blank" rel="noopener">https://www.javaspecialists.eu/archive/Issue214.html</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.7.0" async></script><a class="article-share-link" data-url="http://xujimmy.com/2019/05/29/java-Future-and-Executor.html" data-id="ck2pxfimj005o5rkw8x04zsip" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJ0lEQVR42u3awW4DIQwE0Pz/T6dST5VabWfwRm3gcYqiBHgckLH9eMTj+TmuP1///uv4/svr39w2MDAw3pbxvBzXW0n+e71WckzR/BgYGAcwJpdsewUnd2Y9GwYGBkZ5mV6Dk+sVAwMDY8KYBHxroScGBgZG/oidhHrteOFbHAMD4w0ZdxUGXvH5D+obGBgY/4zxHI88cGwTc8UeMDAwtmbMGyPyhedJt1+OAAMD4wBGu+QkSdcGgtHqGBgYBzDyVFp+Ebez5UeGgYFxGiPf4loCbi3Uy1s6MDAw9mbkTQ+T5ZMjaFs0MDAwTmYkLVxtWr9u8IrnxMDAOIGRB4hJmixfJqHOk3QYGBg7Mdb+nLRfrM3QlkgxMDD2Zqy1O+RP2bZpY+0oMTAw9mbkJcY29b9WMGhXL17DGBgYb87I2yDacsIkcBw1W2BgYGzEaC/K9vHZrpJfwT9EuBgYGJsyXhfqtWm1tZkfa6eCgYHxVoxJKr89rbZdo/gGAwNja0abs8ov1vxx26b2MDAwTmPkT9A8Zd8WOEdlSwwMjAMYa6TJRZm3XLSlCwwMjF0Zz3LkF27+TJ0XRDEwMPZm3NVbdW9CrT0IDAyMExjzVNqkOSxp5oguXAwMjAMYawHc9YbWGEkm7Zd6LAYGxvGMtRJCvrnk+0e+DAYGxmGMfFtt68YNr3AMDIwDGO0jtmW3m26fuBgYGHsz1roz1p6+a8FfEphiYGBsyvgAxaQUGWmGLAMAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/java/">java</a><a href="/tags/异步任务/">异步任务</a></div><div class="article-footer-copyright"><p>本文由 JimmyXu 发表，采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">署名-非商业性使用-禁止演绎4.0</a>进行许可</p><p>非商业转载请注明作者及出处，商业转载请联系作者本人</p><p>本文标题: Java 中 Future 和异步任务</p><p>本文链接: <a href="http://xujimmy.com/2019/05/29/java-Future-and-Executor.html">http://xujimmy.com/2019/05/29/java-Future-and-Executor.html</a></p></div><div class="post-nav"><a class="pre" href="/2019/06/27/what-is-io-multiplexing.html">什么是 I/O 多路复用</a><a class="next" href="/2019/04/23/git-pull-and-git-rebase.html">git pull 和 git rebase</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.7.0"><script src="/js/gitment.browser.js?v=0.7.0"></script><script>var gitment = new Gitment({
  owner: 'hbxjw119',
  repo: 'hbxjw119.github.io',
  oauth: {
    client_id: '6cc8e017eb97ff6696f8',
    client_secret: '042c585d7da96a9f11048ec8bdedd79920c00890',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a><span class="category-list-count">38</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/gevent/" style="font-size: 15px;">gevent</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/monitor/" style="font-size: 15px;">monitor</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/PhantomJS/" style="font-size: 15px;">PhantomJS</a> <a href="/tags/sort/" style="font-size: 15px;">sort</a> <a href="/tags/grep/" style="font-size: 15px;">grep</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/grafana/" style="font-size: 15px;">grafana</a> <a href="/tags/design-pattern/" style="font-size: 15px;">design pattern</a> <a href="/tags/xargs/" style="font-size: 15px;">xargs</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/Cookie/" style="font-size: 15px;">Cookie</a> <a href="/tags/Session/" style="font-size: 15px;">Session</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/公众号/" style="font-size: 15px;">公众号</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/lnmp/" style="font-size: 15px;">lnmp</a> <a href="/tags/zsh/" style="font-size: 15px;">zsh</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/httpie/" style="font-size: 15px;">httpie</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/fpm/" style="font-size: 15px;">fpm</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/北京/" style="font-size: 15px;">北京</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/find/" style="font-size: 15px;">find</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/acme/" style="font-size: 15px;">acme</a> <a href="/tags/阿里云/" style="font-size: 15px;">阿里云</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/记账/" style="font-size: 15px;">记账</a> <a href="/tags/vps/" style="font-size: 15px;">vps</a> <a href="/tags/shadowsocks/" style="font-size: 15px;">shadowsocks</a> <a href="/tags/bbr/" style="font-size: 15px;">bbr</a> <a href="/tags/云计算/" style="font-size: 15px;">云计算</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/maupassant/" style="font-size: 15px;">maupassant</a> <a href="/tags/配置/" style="font-size: 15px;">配置</a> <a href="/tags/csdn/" style="font-size: 15px;">csdn</a> <a href="/tags/消息队列/" style="font-size: 15px;">消息队列</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/math/" style="font-size: 15px;">math</a> <a href="/tags/公式/" style="font-size: 15px;">公式</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/随想/" style="font-size: 15px;">随想</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/KVM/" style="font-size: 15px;">KVM</a> <a href="/tags/异步任务/" style="font-size: 15px;">异步任务</a> <a href="/tags/select/" style="font-size: 15px;">select</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/BIO/" style="font-size: 15px;">BIO</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/pxe/" style="font-size: 15px;">pxe</a> <a href="/tags/ipmi/" style="font-size: 15px;">ipmi</a> <a href="/tags/dnsmasq/" style="font-size: 15px;">dnsmasq</a> <a href="/tags/dhcp/" style="font-size: 15px;">dhcp</a> <a href="/tags/book/" style="font-size: 15px;">book</a> <a href="/tags/书单/" style="font-size: 15px;">书单</a> <a href="/tags/openstack/" style="font-size: 15px;">openstack</a> <a href="/tags/k8s/" style="font-size: 15px;">k8s</a> <a href="/tags/schedule/" style="font-size: 15px;">schedule</a> <a href="/tags/资源调度/" style="font-size: 15px;">资源调度</a> <a href="/tags/CPU/" style="font-size: 15px;">CPU</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/计算机系统/" style="font-size: 15px;">计算机系统</a> <a href="/tags/protobuf/" style="font-size: 15px;">protobuf</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/C/" style="font-size: 15px;">C++</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/11/use-proto.html">使用 protobuf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/29/computer-memory.html">程序员需要知道的数量级</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/11/schedule-in-cloud.html">云计算中的资源调度</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/pxe-install-os.html">使用 PXE 从网络安装操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/27/what-is-io-multiplexing.html">什么是 I/O 多路复用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/java-Future-and-Executor.html">Java 中 Future 和异步任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/git-pull-and-git-rebase.html">git pull 和 git rebase</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/04/docker-and-vm.html">Docker 和 KVM 虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/24/java-analyzer-tools.html">Java 中常用的监控和故障处理命令行工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/22/java-concurrent.html">Java 中的同步方法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.coolguy.pw/" title="coolguy" target="_blank">coolguy</a><ul></ul><a href="https://timyang.net/" title="Tim's blog" target="_blank">Tim's blog</a><ul></ul><a href="https://coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="https://toutiao.io/" title="开发者头条" target="_blank">开发者头条</a><ul></ul><a href="https://huoding.com/" title="火丁笔记" target="_blank">火丁笔记</a><ul></ul><a href="http://blog.guoyb.com/" title="笨茄子" target="_blank">笨茄子</a><ul></ul><a href="https://mengkang.net/" title="周孟康" target="_blank">周孟康</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">JimmyXu的小站 |</a> <a rel="nofollow" target="_blank" href="http://www.miitbeian.gov.cn/">京ICP备 17056410 号 | </a> Powered by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho</a><div><i class="fa fa-eye"><span class="visitors"></span></i></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.7.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.7.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.7.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = '//hm.baidu.com/hm.js?b24b1cbb03fdc613791573423619f3e3';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.7.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.7.0"></script><script type="text/javascript" src="//xujimmy.oss-cn-beijing.aliyuncs.com/av-min.js"></script><script type="text/javascript" src="/js/leandcnt.js?v=0.7.0"></script><script>visitorCount('phNBe6j30h7xFUszRWcBTCIi-gzGzoHsz', '0MKEk5HhPkcT27ogNF4tNhQA', '5a1e63f58d6d8100628a225e')</script></div></body></html>